<!-- This file can be parsed by haxe.rtti.XmlParser -->
<haxe>
	<abstract path="Any" params="" file="/home/runner/haxe/versions/737af26/std/Any.hx">
		<from><icast><d/></icast></from>
		<this><d/></this>
		<to><icast field="__promote"><c path="__promote.T"/></icast></to>
		<haxe_doc>`Any` is a type that is compatible with any other in both ways.

	This means that a value of any type can be assigned to `Any`, and
	vice-versa, a value of `Any` type can be assigned to any other type.

	It's a more type-safe alternative to `Dynamic`, because it doesn't
	support field access or operators and it's bound to monomorphs. So,
	to work with the actual value, it needs to be explicitly promoted
	to another type.</haxe_doc>
		<meta><m n=":forward.variance"/></meta>
		<impl><class path="_Any.Any_Impl_" params="" file="/home/runner/haxe/versions/737af26/std/Any.hx" private="1" module="Any" final="1">
	<__promote params="T" get="inline" set="null" line="37" static="1">
		<f a="this">
			<d/>
			<c path="__promote.T"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":to"/>
		</meta>
	</__promote>
	<toString get="inline" set="null" line="40" static="1">
		<f a="this">
			<d/>
			<c path="String"/>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</toString>
	<meta><m n=":keep"/></meta>
</class></impl>
	</abstract>
	<class path="_Any.Any_Impl_" params="" file="/home/runner/haxe/versions/737af26/std/Any.hx" private="1" module="Any" final="1">
		<__promote params="T" get="inline" set="null" line="37" static="1">
			<f a="this">
				<d/>
				<c path="__promote.T"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":to"/>
			</meta>
		</__promote>
		<toString get="inline" set="null" line="40" static="1">
			<f a="this">
				<d/>
				<c path="String"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</toString>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="Array" params="T" file="/home/runner/haxe/versions/737af26/std/js/_std/Array.hx" extern="1">
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` Array.</haxe_doc>
		</length>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of `this` Array, with `sep` separating
		each element.

		The result of this operation is equal to `Std.string(this[0]) + sep +
		Std.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1])`

		If `this` is the empty Array `[]`, the result is the empty String `""`.
		If `this` has exactly one element, the result is equal to a call to
		`Std.string(this[0])`.

		If `sep` is null, the result is unspecified.</haxe_doc>
		</join>
		<pop public="1" set="method">
			<f a=""><x path="Null"><c path="Array.T"/></x></f>
			<haxe_doc>Removes the last element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this.length` will decrease by 1.

		If `this` is the empty Array `[]`, null is returned and the length
		remains 0.</haxe_doc>
		</pop>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Adds the element `x` at the end of `this` Array and returns the new
		length of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` increases by 1.</haxe_doc>
		</push>
		<shift public="1" set="method">
			<f a=""><x path="Null"><c path="Array.T"/></x></f>
			<haxe_doc>Removes the first element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this`.length and the index of each
		remaining element is decreased by 1.

		If `this` is the empty Array `[]`, `null` is returned and the length
		remains 0.</haxe_doc>
		</shift>
		<slice public="1" set="method">
			<f a="pos:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Creates a shallow copy of the range of `this` Array, starting at and
		including `pos`, up to but not including `end`.

		This operation does not modify `this` Array.

		The elements are not copied and retain their identity.

		If `end` is omitted or exceeds `this.length`, it defaults to the end of
		`this` Array.

		If `pos` or `end` are negative, their offsets are calculated from the
		end of `this` Array by `this.length + pos` and `this.length + end`
		respectively. If this yields a negative value, 0 is used instead.

		If `pos` exceeds `this.length` or if `end` is less than or equals
		`pos`, the result is `[]`.</haxe_doc>
		</slice>
		<iterator public="1" get="inline" set="null" line="88">
			<f a=""><c path="haxe.iterators.ArrayIterator"><c path="Array.T"/></c></f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Class" params="T" file="/home/runner/haxe/versions/737af26/std/Class.hx">
		<this><x path="Class"><c path="Class.T"/></x></this>
		<haxe_doc>An abstract type that represents a Class.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-class-instance.html</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="Date" params="" file="/home/runner/haxe/versions/737af26/std/js/_std/Date.hx" extern="1">
		<now public="1" get="inline" set="null" line="46" static="1">
			<f a=""><c path="Date"/></f>
			<haxe_doc>Returns a Date representing the current local time.</haxe_doc>
		</now>
		<fromTime public="1" get="inline" set="null" line="50" static="1">
			<f a="t">
				<x path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Creates a Date from the timestamp (in milliseconds) `t`.</haxe_doc>
		</fromTime>
		<fromString public="1" get="inline" set="null" line="54" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Creates a Date from the formatted string `s`. The following formats are
		accepted by the function:

		- `"YYYY-MM-DD hh:mm:ss"`
		- `"YYYY-MM-DD"`
		- `"hh:mm:ss"`

		The first two formats expressed a date in local time. The third is a time
		relative to the UTC epoch.</haxe_doc>
		</fromString>
		<getTime public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the timestamp (in milliseconds) of `this` date.
		On cpp and neko, this function only has a second resolution, so the
		result will always be a multiple of `1000.0`, e.g. `1454698271000.0`.
		To obtain the current timestamp with better precision on cpp and neko,
		see the `Sys.time` API.

		For measuring time differences with millisecond accuracy on
		all platforms, see `haxe.Timer.stamp`.</haxe_doc>
		</getTime>
		<getHours public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the hours of `this` Date (0-23 range) in the local timezone.</haxe_doc>
		</getHours>
		<getMinutes public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the minutes of `this` Date (0-59 range) in the local timezone.</haxe_doc>
		</getMinutes>
		<getSeconds public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the seconds of `this` Date (0-59 range) in the local timezone.</haxe_doc>
		</getSeconds>
		<getFullYear public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the full year of `this` Date (4 digits) in the local timezone.</haxe_doc>
		</getFullYear>
		<getMonth public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the month of `this` Date (0-11 range) in the local timezone.
		Note that the month number is zero-based.</haxe_doc>
		</getMonth>
		<getDate public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of `this` Date (1-31 range) in the local timezone.</haxe_doc>
		</getDate>
		<getDay public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of the week of `this` Date (0-6 range, where `0` is Sunday)
		in the local timezone.</haxe_doc>
		</getDay>
		<getUTCHours public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the hours of `this` Date (0-23 range) in UTC.</haxe_doc>
		</getUTCHours>
		<getUTCMinutes public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the minutes of `this` Date (0-59 range) in UTC.</haxe_doc>
		</getUTCMinutes>
		<getUTCSeconds public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the seconds of `this` Date (0-59 range) in UTC.</haxe_doc>
		</getUTCSeconds>
		<getUTCFullYear public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the full year of `this` Date (4 digits) in UTC.</haxe_doc>
		</getUTCFullYear>
		<getUTCMonth public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the month of `this` Date (0-11 range) in UTC.
		Note that the month number is zero-based.</haxe_doc>
		</getUTCMonth>
		<getUTCDate public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of `this` Date (1-31 range) in UTC.</haxe_doc>
		</getUTCDate>
		<getUTCDay public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of the week of `this` Date (0-6 range, where `0` is Sunday)
		in UTC.</haxe_doc>
		</getUTCDay>
		<getTimezoneOffset public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the time zone difference of `this` Date in the current locale
		to UTC, in minutes.

		Assuming the function is executed on a machine in a UTC+2 timezone,
		`Date.now().getTimezoneOffset()` will return `-120`.</haxe_doc>
		</getTimezoneOffset>
		<toString public="1" get="inline" set="null" line="42">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Date in the local timezone
		using the standard format `YYYY-MM-DD HH:MM:SS`. See `DateTools.format` for
		other formatting rules.</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="year:month:day:hour:min:sec">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new date object from the given arguments.

		The behaviour of a Date instance is only consistent across platforms if
		the the arguments describe a valid date.

		- month: 0 to 11 (note that this is zero-based)
		- day: 1 to 31
		- hour: 0 to 23
		- min: 0 to 59
		- sec: 0 to 59</haxe_doc>
		</new>
		<haxe_doc>The Date class provides a basic structure for date and time related
	information. Date instances can be created by

	- `new Date()` for a specific date,
	- `Date.now()` to obtain information about the current time,
	- `Date.fromTime()` with a given timestamp or
	- `Date.fromString()` by parsing from a String.

	There are some extra functions available in the `DateTools` class.

	In the context of Haxe dates, a timestamp is defined as the number of
	milliseconds elapsed since 1st January 1970 UTC.

	## Supported range

	Due to platform limitations, only dates in the range 1970 through 2038 are
	supported consistently. Some targets may support dates outside this range,
	depending on the OS at runtime. The `Date.fromTime` method will not work with
	timestamps outside the range on any target.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<class path="js.lib.RegExp" params="" file="/home/runner/haxe/versions/737af26/std/js/lib/RegExp.hx" extern="1">
		<global public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Indicates whether or not the "g" flag is used with the regular expression.</haxe_doc>
		</global>
		<ignoreCase public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Indicates whether or not the "i" flag is used with the regular expression.</haxe_doc>
		</ignoreCase>
		<multiline public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Indicates whether or not the "m" flag is used with the regular expression.</haxe_doc>
		</multiline>
		<source public="1" set="null">
			<c path="String"/>
			<haxe_doc>The source text of the regexp object, it doesn't contain the two forward slashes on both sides and any flags.</haxe_doc>
		</source>
		<lastIndex public="1">
			<x path="Int"/>
			<haxe_doc>The index at which to start the next match.</haxe_doc>
		</lastIndex>
		<exec public="1" set="method">
			<f a="str">
				<c path="String"/>
				<x path="Null"><c path="js.lib.RegExpMatch"/></x>
			</f>
			<haxe_doc>Execute a search for a match in a specified string.
		Returns a result array, or null.</haxe_doc>
		</exec>
		<test public="1" set="method">
			<f a="str">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Execute a search for a match between a regular expression and a specified string.
		Returns true or false.</haxe_doc>
		</test>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Return a string representing the regular expression.</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="pattern:?flags">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a regular expression object for matching text with a pattern.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[Native JavaScript regular expressions.

	For cross-platform regular expressions, use Haxe `EReg` class or
	[regexp literals](https://haxe.org/manual/std-regex.html).

	@see <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp>]]></haxe_doc>
		<meta><m n=":native"><e>"RegExp"</e></m></meta>
	</class>
	<class path="_EReg.HaxeRegExp" params="" file="/home/runner/haxe/versions/737af26/std/js/_std/EReg.hx" private="1" module="EReg" extern="1">
		<extends path="js.lib.RegExp"/>
		<m public="1"><c path="js.lib.RegExpMatch"/></m>
		<s public="1"><c path="String"/></s>
		<meta><m n=":native"><e>"RegExp"</e></m></meta>
	</class>
	<abstract path="Enum" params="T" file="/home/runner/haxe/versions/737af26/std/Enum.hx">
		<this><x path="Enum"><c path="Enum.T"/></x></this>
		<haxe_doc>An abstract type that represents an Enum type.

	The corresponding enum instance type is `EnumValue`.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="EnumValue" params="" file="/home/runner/haxe/versions/737af26/std/EnumValue.hx">
		<this><x path="EnumValue"/></this>
		<haxe_doc>An abstract type that represents any enum value.
	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
		<impl><class path="_EnumValue.EnumValue_Impl_" params="" file="/home/runner/haxe/versions/737af26/std/EnumValue.hx" private="1" module="EnumValue" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="js.Syntax" params="" file="/home/runner/haxe/versions/737af26/std/js/Syntax.hx" extern="1">
		<code public="1" set="method" static="1">
			<f a="code:args">
				<c path="String"/>
				<t path="haxe.extern.Rest"><d/></t>
				<d/>
			</f>
			<haxe_doc>Inject `code` directly into generated source.

		`code` must be a string constant.

		Additional `args` are supported to provide code interpolation, for example:
		```haxe
		Syntax.code("console.log({0}, {1})", "hi", 42);
		```
		will generate
		```haxe
		console.log("hi", 42);
		```

		Emits a compilation error if the count of `args` does not match the count of placeholders in `code`.</haxe_doc>
		</code>
		<plainCode public="1" set="method" static="1">
			<f a="code">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Inject `code` directly into generated source.
		The same as `js.Syntax.code` except this one does not provide code interpolation.</haxe_doc>
		</plainCode>
		<construct public="1" params="T" set="method" static="1">
			<f a="cl:args">
				<x path="Class"><c path="construct.T"/></x>
				<t path="haxe.extern.Rest"><d/></t>
				<c path="construct.T"/>
			</f>
			<haxe_doc>Generate `new cl(...args)` expression.</haxe_doc>
			<overloads><construct public="1" set="method">
	<f a="cl:args">
		<c path="String"/>
		<t path="haxe.extern.Rest"><d/></t>
		<d/>
	</f>
	<haxe_doc>Generate `new cl(...args)` expression.</haxe_doc>
</construct></overloads>
		</construct>
		<instanceof public="1" set="method" static="1">
			<f a="v:cl">
				<d/>
				<x path="Class"><d/></x>
				<x path="Bool"/>
			</f>
			<haxe_doc>Generate `v instanceof cl` expression.</haxe_doc>
		</instanceof>
		<typeof public="1" set="method" static="1">
			<f a="o">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Generate `typeof o` expression.</haxe_doc>
		</typeof>
		<strictEq public="1" set="method" static="1">
			<f a="a:b">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Genearte `a === b` expression.</haxe_doc>
		</strictEq>
		<strictNeq public="1" set="method" static="1">
			<f a="a:b">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Genearte `a !== b` expression.</haxe_doc>
		</strictNeq>
		<delete public="1" set="method" static="1">
			<f a="o:f">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Generate `delete o[f]` expression.</haxe_doc>
			<overloads><delete public="1" set="method">
	<f a="o:f">
		<d/>
		<x path="Int"/>
		<x path="Bool"/>
	</f>
	<haxe_doc>Generate `delete o[f]` expression.</haxe_doc>
</delete></overloads>
		</delete>
		<field public="1" set="method" static="1">
			<f a="o:f">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Generate `o.f` expression, if `f` is a constant string,
		or `o[f]` if it's any other expression.</haxe_doc>
		</field>
		<haxe_doc>Generate JavaScript syntax not directly supported by Haxe.
	Use only at low-level when specific target-specific code-generation is required.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":noClosure"/>
		</meta>
	</class>
	<class path="js.lib.Date" params="" file="/home/runner/haxe/versions/737af26/std/js/lib/Date.hx" extern="1">
		<fromHaxeDate public="1" get="inline" set="null" line="40" static="1">
			<f a="date">
				<t path="_Date.HaxeDate"/>
				<c path="js.lib.Date"/>
			</f>
			<haxe_doc>Cast Haxe's Date to js.lib.Date.</haxe_doc>
		</fromHaxeDate>
		<toHaxeDate public="1" get="inline" set="null" line="47" static="1">
			<f a="date">
				<c path="js.lib.Date"/>
				<t path="_Date.HaxeDate"/>
			</f>
			<haxe_doc>Cast js.lib.Date to Haxe's Date.</haxe_doc>
		</toHaxeDate>
		<now public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the numeric value corresponding to the current time - the number of milliseconds elapsed since January 1, 1970 00:00:00 UTC, with leap seconds ignored</haxe_doc>
		</now>
		<parse public="1" set="method" static="1">
			<f a="str">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Parses a string representation of a date and returns the number of milliseconds since 1 January, 1970, 00:00:00, UTC, with leap seconds ignored.</haxe_doc>
		</parse>
		<UTC public="1" set="method" static="1">
			<f a="year:month:?day:?hours:?minutes:?seconds:?milliseconds">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the number of milliseconds since January 1, 1970, 00:00:00 UTC, with leap seconds ignored.</haxe_doc>
		</UTC>
		<getDate public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of the month (1-31) for the specified date according to local time.</haxe_doc>
		</getDate>
		<getDay public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of the week (0-6) for the specified date according to local time.</haxe_doc>
		</getDay>
		<getFullYear public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the year (4 digits for 4-digit years) of the specified date according to local time.</haxe_doc>
		</getFullYear>
		<getHours public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the hour (0-23) in the specified date according to local time.</haxe_doc>
		</getHours>
		<getMilliseconds public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the milliseconds (0-999) in the specified date according to local time.</haxe_doc>
		</getMilliseconds>
		<getMinutes public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the minutes (0-59) in the specified date according to local time.</haxe_doc>
		</getMinutes>
		<getMonth public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the month (0-11) in the specified date according to local time.</haxe_doc>
		</getMonth>
		<getSeconds public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the seconds (0-59) in the specified date according to local time.</haxe_doc>
		</getSeconds>
		<getTime public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the numeric value of the specified date as the number of milliseconds since January 1, 1970, 00:00:00 UTC (negative for prior times).</haxe_doc>
		</getTime>
		<getTimezoneOffset public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the time-zone offset in minutes for the current locale.</haxe_doc>
		</getTimezoneOffset>
		<getUTCDate public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day (date) of the month (1-31) in the specified date according to universal time.</haxe_doc>
		</getUTCDate>
		<getUTCDay public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of the week (0-6) in the specified date according to universal time.</haxe_doc>
		</getUTCDay>
		<getUTCFullYear public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the year (4 digits for 4-digit years) in the specified date according to universal time.</haxe_doc>
		</getUTCFullYear>
		<getUTCHours public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the hours (0-23) in the specified date according to universal time.</haxe_doc>
		</getUTCHours>
		<getUTCMilliseconds public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the milliseconds (0-999) in the specified date according to universal time.</haxe_doc>
		</getUTCMilliseconds>
		<getUTCMinutes public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the minutes (0-59) in the specified date according to universal time.</haxe_doc>
		</getUTCMinutes>
		<getUTCMonth public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the month (0-11) in the specified date according to universal time.</haxe_doc>
		</getUTCMonth>
		<getUTCSeconds public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the seconds (0-59) in the specified date according to universal time.</haxe_doc>
		</getUTCSeconds>
		<setDate public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the day of the month for a specified date according to local time.</haxe_doc>
		</setDate>
		<setFullYear public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the full year (e.g. 4 digits for 4-digit years) for a specified date according to local time.</haxe_doc>
		</setFullYear>
		<setHours public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the hours for a specified date according to local time.</haxe_doc>
		</setHours>
		<setMilliseconds public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the milliseconds for a specified date according to local time.</haxe_doc>
		</setMilliseconds>
		<setMinutes public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the minutes for a specified date according to local time.</haxe_doc>
		</setMinutes>
		<setMonth public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the month for a specified date according to local time.</haxe_doc>
		</setMonth>
		<setSeconds public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the seconds for a specified date according to local time.</haxe_doc>
		</setSeconds>
		<setTime public="1" set="method">
			<f a="value">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the Date object to the time represented by a number of milliseconds since January 1, 1970, 00:00:00 UTC, allowing for negative numbers for times prior.</haxe_doc>
		</setTime>
		<setUTCDate public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the day of the month for a specified date according to universal time.</haxe_doc>
		</setUTCDate>
		<setUTCFullYear public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the full year (e.g. 4 digits for 4-digit years) for a specified date according to universal time.</haxe_doc>
		</setUTCFullYear>
		<setUTCHours public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the hour for a specified date according to universal time.</haxe_doc>
		</setUTCHours>
		<setUTCMilliseconds public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the milliseconds for a specified date according to universal time.</haxe_doc>
		</setUTCMilliseconds>
		<setUTCMinutes public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the minutes for a specified date according to universal time.</haxe_doc>
		</setUTCMinutes>
		<setUTCMonth public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the month for a specified date according to universal time.</haxe_doc>
		</setUTCMonth>
		<setUTCSeconds public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the seconds for a specified date according to universal time.</haxe_doc>
		</setUTCSeconds>
		<toDateString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the "date" portion of the Date as a human-readable string.</haxe_doc>
		</toDateString>
		<toISOString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Converts a date to a string following the ISO 8601 Extended Format.</haxe_doc>
		</toISOString>
		<toJSON public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representing the Date using toISOString(). Intended for use by JSON.stringify().</haxe_doc>
		</toJSON>
		<toLocaleDateString public="1" set="method">
			<f a="?locales:?options">
				<c path="String"/>
				<d><d/></d>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string with a locality sensitive representation of the date portion of this date based on system settings.</haxe_doc>
			<overloads><toLocaleDateString public="1" set="method">
	<f a="?locales:?options">
		<c path="Array"><c path="String"/></c>
		<d><d/></d>
		<c path="String"/>
	</f>
	<haxe_doc>Returns a string with a locality sensitive representation of the date portion of this date based on system settings.</haxe_doc>
</toLocaleDateString></overloads>
		</toLocaleDateString>
		<toLocaleFormat public="1" set="method">
			<f a="format">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Converts a date to a string, using a format string.</haxe_doc>
		</toLocaleFormat>
		<toLocaleString public="1" set="method">
			<f a="?locales:?options">
				<c path="String"/>
				<d><d/></d>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string with a locality sensitive representation of this date. Overrides the Object.prototype.toLocaleString() method.</haxe_doc>
			<overloads><toLocaleString public="1" set="method">
	<f a="?locales:?options">
		<c path="Array"><c path="String"/></c>
		<d><d/></d>
		<c path="String"/>
	</f>
	<haxe_doc>Returns a string with a locality sensitive representation of this date. Overrides the Object.prototype.toLocaleString() method.</haxe_doc>
</toLocaleString></overloads>
		</toLocaleString>
		<toLocaleTimeString public="1" set="method">
			<f a="?locales:?options">
				<c path="String"/>
				<d><d/></d>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string with a locality sensitive representation of the time portion of this date based on system settings.</haxe_doc>
			<overloads><toLocaleTimeString public="1" set="method">
	<f a="?locales:?options">
		<c path="Array"><c path="String"/></c>
		<d><d/></d>
		<c path="String"/>
	</f>
	<haxe_doc>Returns a string with a locality sensitive representation of the time portion of this date based on system settings.</haxe_doc>
</toLocaleTimeString></overloads>
		</toLocaleTimeString>
		<toSource public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representing the source for an equivalent Date object; you can use this value to create a new object. Overrides the Object.prototype.toSource() method.</haxe_doc>
		</toSource>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representing the specified Date object. Overrides the Object.prototype.toString() method.</haxe_doc>
		</toString>
		<toTimeString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the "time" portion of the Date as a human-readable string.</haxe_doc>
		</toTimeString>
		<toUTCString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Converts a date to a string using the UTC timezone.</haxe_doc>
		</toUTCString>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<overloads>
				<new public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></new>
				<new public="1" set="method"><f a="dateString">
	<c path="String"/>
	<x path="Void"/>
</f></new>
				<new public="1" set="method"><f a="year:month:?day:?hours:?minutes:?seconds:?milliseconds">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
			</overloads>
		</new>
		<haxe_doc>Creates a JavaScript Date instance that represents a single moment in time. Date objects are based on a time value that is the number of milliseconds since 1 January 1970 UTC.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"Date"</e></m>
		</meta>
	</class>
	<typedef path="Map" params="K:V" file="/home/runner/haxe/versions/737af26/std/Map.hx"><x path="haxe.ds.Map">
	<c path="Map.K"/>
	<c path="Map.V"/>
</x></typedef>
	<typedef path="IMap" params="K:V" file="/home/runner/haxe/versions/737af26/std/Map.hx" module="Map">
		<c path="haxe.IMap">
			<c path="IMap.K"/>
			<c path="IMap.V"/>
		</c>
		<meta>
			<m n=":dox"><e>hide</e></m>
			<m n=":deprecated"/>
		</meta>
	</typedef>
	<class path="Math" params="" file="/home/runner/haxe/versions/737af26/std/js/_std/Math.hx" extern="1"><meta>
	<m n=":keep"/>
	<m n=":keepInit"/>
</meta></class>
	<class path="String" params="" file="/home/runner/haxe/versions/737af26/std/js/_std/String.hx" extern="1">
		<fromCharCode public="1" get="inline" set="null" line="43" static="1">
			<f a="code">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the String corresponding to the character code `code`.

		If `code` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</fromCharCode>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The number of characters in `this` String.</haxe_doc>
		</length>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are upper case.</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are lower case.</haxe_doc>
		</toLowerCase>
		<charAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, the empty String `""`
		is returned.</haxe_doc>
		</charAt>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the leftmost occurrence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String starting from `startIndex`.

		If `startIndex` exceeds `this.length`, -1 is returned.

		If `startIndex` is negative, the result is unspecifed.

		Otherwise the search is performed within `this` String. In either case,
		the returned position is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the rightmost occurrence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String from 0 to `startIndex + str.length`. Otherwise the search
		is performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `startIndex` is negative, the result is unspecifed.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits `this` String at each occurrence of `delimiter`.

		If `this` String is the empty String `""`, the result is not consistent
		across targets and may either be `[]` (on Js, Cpp) or `[""]`.

		If `delimiter` is the empty String `""`, `this` String is split into an
		Array of `this.length` elements, where the elements correspond to the
		characters of `this` String.

		If `delimiter` is not found within `this` String, the result is an Array
		with one element, which equals `this` String.

		If `delimiter` is null, the result is unspecified.

		Otherwise, `this` String is split into parts at each occurrence of
		`delimiter`. If `this` String starts (or ends) with `delimiter`, the
		result `Array` contains a leading (or trailing) empty String `""` element.
		Two subsequent delimiters also result in an empty String `""` element.</haxe_doc>
		</split>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<substring public="1" set="method">
			<f a="startIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the part of `this` String from `startIndex` to but not including `endIndex`.

		If `startIndex` or `endIndex` are negative, 0 is used instead.

		If `startIndex` exceeds `endIndex`, they are swapped.

		If the (possibly swapped) `endIndex` is omitted or exceeds
		`this.length`, `this.length` is used instead.

		If the (possibly swapped) `startIndex` exceeds `this.length`, the empty
		String `""` is returned.</haxe_doc>
		</substring>
		<charCodeAt public="1" get="inline" set="null" line="35">
			<f a="index">
				<x path="Int"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>Returns the character code at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, `null` is returned.

		To obtain the character code of a single character, `"x".code` can be
		used instead to inline the character code at compile time. Note that
		this only works on String literals of length 1.</haxe_doc>
		</charCodeAt>
		<substr public="1" get="inline" set="null" line="39">
			<f a="pos:?len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns `len` characters of `this` String, starting at position `pos`.

		If `len` is omitted, all characters from position `pos` to the end of
		`this` String are included.

		If `pos` is negative, its value is calculated from the end of `this`
		String by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the calculated position + `len` exceeds `this.length`, the characters
		from that position to the end of `this` String are returned.

		If `len` is negative, the result is unspecified.</haxe_doc>
		</substr>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.

	A Haxe String is immutable, it is not possible to modify individual
	characters. No method of this class changes the state of `this` String.

	Strings can be constructed using the String literal syntax `"string value"`.

	String can be concatenated by using the `+` operator. If an operand is not a
	String, it is passed through `Std.string()` first.

	@see https://haxe.org/manual/std-String.html</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="Std" params="" file="/home/runner/haxe/versions/737af26/std/js/_std/Std.hx">
		<string public="1" set="method" line="47" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Converts any value to a String.

		If `s` is of `String`, `Int`, `Float` or `Bool`, its value is returned.

		If `s` is an instance of a class and that class or one of its parent classes has
		a `toString` method, that method is called. If no such method is present, the result
		is unspecified.

		If `s` is an enum constructor without argument, the constructor's name is returned. If
		arguments exists, the constructor's name followed by the String representations of
		the arguments is returned.

		If `s` is a structure, the field names along with their values are returned. The field order
		and the operator separating field names and values are unspecified.

		If s is null, "null" is returned.</haxe_doc>
		</string>
		<parseInt public="1" set="method" line="56" static="1">
			<f a="x">
				<c path="String"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>Converts a `String` to an `Int`.

		Leading whitespaces are ignored.

		If `x` starts with 0x or 0X, hexadecimal notation is recognized where the following digits may
		contain 0-9 and A-F.

		Otherwise `x` is read as decimal number with 0-9 being allowed characters. `x` may also start with
		a - to denote a negative value.

		In decimal mode, parsing continues until an invalid character is detected, in which case the
		result up to that point is returned. For hexadecimal notation, the effect of invalid characters
		is unspecified.

		Leading 0s that are not part of the 0x/0X hexadecimal notation are ignored, which means octal
		notation is not supported.

		If `x` is null, the result is unspecified.
		If `x` cannot be parsed as integer, the result is `null`.</haxe_doc>
		</parseInt>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":keepInit"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Void" params="" file="/home/runner/haxe/versions/737af26/std/StdTypes.hx" module="StdTypes">
		<this><x path="Void"/></this>
		<haxe_doc>The standard `Void` type. Only `null` values can be of the type `Void`.

	@see https://haxe.org/manual/types-void.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<abstract path="Float" params="" file="/home/runner/haxe/versions/737af26/std/StdTypes.hx" module="StdTypes">
		<this><x path="Float"/></this>
		<haxe_doc><![CDATA[The standard `Float` type, this is a double-precision IEEE 64bit float.

	On static targets, `null` cannot be assigned to Float. If this is necessary,
	`Null<Float>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseFloat` converts a `String` to a `Float`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Int" params="" file="/home/runner/haxe/versions/737af26/std/StdTypes.hx" module="StdTypes">
		<this><x path="Int"/></this>
		<to><icast><x path="Float"/></icast></to>
		<haxe_doc><![CDATA[The standard `Int` type. Its precision depends on the platform.

	On static targets, `null` cannot be assigned to `Int`. If this is necessary,
	`Null<Int>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseInt` converts a `String` to an `Int`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/std-math-integer-math.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Null" params="T" file="/home/runner/haxe/versions/737af26/std/StdTypes.hx" module="StdTypes">
		<from><icast><c path="Null.T"/></icast></from>
		<this><x path="Null"><c path="Null.T"/></x></this>
		<to><icast><c path="Null.T"/></icast></to>
		<haxe_doc><![CDATA[`Null<T>` is a wrapper that can be used to make the basic types `Int`,
	`Float` and `Bool` nullable on static targets.

	If null safety is enabled, only types wrapped in `Null<T>` are nullable.

	Otherwise, it has no effect on non-basic-types, but it can be useful as a way to document
	that `null` is an acceptable value for a method argument, return value or variable.

	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":forward"/>
			<m n=":coreType"/>
		</meta>
	</abstract>
	<abstract path="Bool" params="" file="/home/runner/haxe/versions/737af26/std/StdTypes.hx" module="StdTypes">
		<this><x path="Bool"/></this>
		<haxe_doc><![CDATA[The standard Boolean type, which can either be `true` or `false`.

	On static targets, `null` cannot be assigned to `Bool`. If this is necessary,
	`Null<Bool>` can be used instead.

	@see https://haxe.org/manual/types-bool.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Dynamic" params="T" file="/home/runner/haxe/versions/737af26/std/StdTypes.hx" module="StdTypes">
		<this><x path="Dynamic"><c path="Dynamic.T"/></x></this>
		<haxe_doc>`Dynamic` is a special type which is compatible with all other types.

	Use of `Dynamic` should be minimized as it prevents several compiler
	checks and optimizations. See `Any` type for a safer alternative for
	representing values of any type.

	@see https://haxe.org/manual/types-dynamic.html</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Iterator" params="T" file="/home/runner/haxe/versions/737af26/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method">
				<f a=""><c path="Iterator.T"/></f>
				<haxe_doc>Returns the current item of the `Iterator` and advances to the next one.

		This method is not required to check `hasNext()` first. A call to this
		method while `hasNext()` is `false` yields unspecified behavior.

		On the other hand, iterators should not require a call to `hasNext()`
		before the first call to `next()` if an element is available.</haxe_doc>
			</next>
			<hasNext set="method">
				<f a=""><x path="Bool"/></f>
				<haxe_doc>Returns `false` if the iteration is complete, `true` otherwise.

		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to `next()`. However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
			</hasNext>
		</a>
		<haxe_doc>An `Iterator` is a structure that permits iteration over elements of type `T`.

	Any class with matching `hasNext()` and `next()` fields is considered an `Iterator`
	and can then be used e.g. in `for`-loops. This makes it easy to implement
	custom iterators.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="/home/runner/haxe/versions/737af26/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An `Iterable` is a data structure which has an `iterator()` method.
	See `Lambda` for generic functions on iterable structures.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<typedef path="KeyValueIterator" params="K:V" file="/home/runner/haxe/versions/737af26/std/StdTypes.hx" module="StdTypes">
		<t path="Iterator"><a>
	<value><c path="KeyValueIterator.V"/></value>
	<key><c path="KeyValueIterator.K"/></key>
</a></t>
		<haxe_doc>A `KeyValueIterator` is an `Iterator` that has a key and a value.</haxe_doc>
	</typedef>
	<typedef path="KeyValueIterable" params="K:V" file="/home/runner/haxe/versions/737af26/std/StdTypes.hx" module="StdTypes">
		<a><keyValueIterator set="method"><f a=""><t path="KeyValueIterator">
	<c path="KeyValueIterable.K"/>
	<c path="KeyValueIterable.V"/>
</t></f></keyValueIterator></a>
		<haxe_doc>A `KeyValueIterable` is a data structure which has a `keyValueIterator()`
	method to iterate over key-value-pairs.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="/home/runner/haxe/versions/737af26/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>`ArrayAccess` is used to indicate a class that can be accessed using brackets.
	The type parameter represents the type of the elements stored.

	This interface should be used for externs only. Haxe does not support custom
	array access on classes. However, array access can be implemented for
	abstract types.

	@see https://haxe.org/manual/types-abstract-array-access.html</haxe_doc></class>
	<class path="StringBuf" params="" file="/home/runner/haxe/versions/737af26/std/StringBuf.hx">
		<b><c path="String"/></b>
		<new public="1" get="inline" set="null" line="44">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringBuf instance.

		This may involve initialization of the internal buffer.</haxe_doc>
		</new>
		<haxe_doc>A String buffer is an efficient way to build a big string by appending small
	elements together.

	Unlike String, an instance of StringBuf is not immutable in the sense that
	it can be passed as argument to functions which modify it by appending more
	values.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="StringTools" params="" file="/home/runner/haxe/versions/737af26/std/StringTools.hx">
		<isSpace public="1" set="method" line="278" static="1">
			<f a="s:pos">
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the character in the string `s` at position `pos` is a space.

		A character is considered to be a space character if its character code
		is 9,10,11,12,13 or 32.

		If `s` is the empty String `""`, or if pos is not a valid position within
		`s`, the result is false.</haxe_doc>
		</isSpace>
		<ltrim public="1" set="method" line="296" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes leading space characters of `s`.

		This function internally calls `isSpace()` to decide which characters to
		remove.

		If `s` is the empty String `""` or consists only of space characters, the
		result is the empty String `""`.</haxe_doc>
		</ltrim>
		<rtrim public="1" set="method" line="321" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes trailing space characters of `s`.

		This function internally calls `isSpace()` to decide which characters to
		remove.

		If `s` is the empty String `""` or consists only of space characters, the
		result is the empty String `""`.</haxe_doc>
		</rtrim>
		<trim public="1" set="method" line="343" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes leading and trailing space characters of `s`.

		This is a convenience function for `ltrim(rtrim(s))`.</haxe_doc>
		</trim>
		<haxe_doc>This class provides advanced methods on Strings. It is ideally used with
	`using StringTools` and then acts as an [extension](https://haxe.org/manual/lf-static-extension.html)
	to the `String` class.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<enum path="haxe.StackItem" params="" file="/home/runner/haxe/versions/737af26/std/haxe/CallStack.hx" module="haxe.CallStack">
		<CFunction/>
		<Module a="m"><c path="String"/></Module>
		<FilePos a="s:file:line:?column">
			<x path="Null"><e path="haxe.StackItem"/></x>
			<c path="String"/>
			<x path="Int"/>
			<x path="Int"/>
		</FilePos>
		<Method a="classname:method">
			<x path="Null"><c path="String"/></x>
			<c path="String"/>
		</Method>
		<LocalFunction a="?v"><x path="Int"/></LocalFunction>
		<haxe_doc>Elements return by `CallStack` methods.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<abstract path="haxe.CallStack" params="" file="/home/runner/haxe/versions/737af26/std/haxe/CallStack.hx">
		<from><icast><c path="Array"><e path="haxe.StackItem"/></c></icast></from>
		<this><c path="Array"><e path="haxe.StackItem"/></c></this>
		<haxe_doc>Get information about the call stack.</haxe_doc>
		<meta>
			<m n=":allow"><e>haxe.Exception</e></m>
			<m n=":using"><e>haxe.CallStack</e></m>
		</meta>
		<impl><class path="haxe._CallStack.CallStack_Impl_" params="" file="/home/runner/haxe/versions/737af26/std/haxe/CallStack.hx" private="1" module="haxe.CallStack" final="1">
	<callStack public="1" set="method" line="51" static="1">
		<f a=""><c path="Array"><e path="haxe.StackItem"/></c></f>
		<haxe_doc>Return the call stack elements, or an empty array if not available.</haxe_doc>
	</callStack>
	<exceptionStack public="1" set="method" line="63" static="1">
		<f a="?fullStack" v="false">
			<x path="Bool"/>
			<c path="Array"><e path="haxe.StackItem"/></c>
		</f>
		<meta><m n=":value"><e>{ fullStack : false }</e></m></meta>
		<haxe_doc>Return the exception stack : this is the stack elements between
		the place the last exception was thrown and the place it was
		caught, or an empty array if not available.
		Set `fullStack` parameter to true in order to return the full exception stack.

		May not work if catch type was a derivative from `haxe.Exception`.</haxe_doc>
	</exceptionStack>
	<toString public="1" set="method" line="71" static="1">
		<f a="stack">
			<x path="haxe.CallStack"/>
			<c path="String"/>
		</f>
		<haxe_doc>Returns a representation of the stack as a printable string.</haxe_doc>
	</toString>
	<subtract public="1" set="method" line="84" static="1">
		<f a="this:stack">
			<c path="Array"><e path="haxe.StackItem"/></c>
			<x path="haxe.CallStack"/>
			<x path="haxe.CallStack"/>
		</f>
		<haxe_doc>Returns a range of entries of current stack from the beginning to the the
		common part of this and `stack`.</haxe_doc>
	</subtract>
	<equalItems set="method" line="119" static="1"><f a="item1:item2">
	<x path="Null"><e path="haxe.StackItem"/></x>
	<x path="Null"><e path="haxe.StackItem"/></x>
	<x path="Bool"/>
</f></equalItems>
	<itemToString set="method" line="155" static="1"><f a="b:s">
	<c path="StringBuf"/>
	<e path="haxe.StackItem"/>
	<x path="Void"/>
</f></itemToString>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
		<m n=":using"><e>haxe.CallStack</e></m>
		<m n=":allow"><e>haxe.Exception</e></m>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe._CallStack.CallStack_Impl_" params="" file="/home/runner/haxe/versions/737af26/std/haxe/CallStack.hx" private="1" module="haxe.CallStack" final="1">
		<callStack public="1" set="method" line="51" static="1">
			<f a=""><c path="Array"><e path="haxe.StackItem"/></c></f>
			<haxe_doc>Return the call stack elements, or an empty array if not available.</haxe_doc>
		</callStack>
		<exceptionStack public="1" set="method" line="63" static="1">
			<f a="?fullStack" v="false">
				<x path="Bool"/>
				<c path="Array"><e path="haxe.StackItem"/></c>
			</f>
			<meta><m n=":value"><e>{ fullStack : false }</e></m></meta>
			<haxe_doc>Return the exception stack : this is the stack elements between
		the place the last exception was thrown and the place it was
		caught, or an empty array if not available.
		Set `fullStack` parameter to true in order to return the full exception stack.

		May not work if catch type was a derivative from `haxe.Exception`.</haxe_doc>
		</exceptionStack>
		<toString public="1" set="method" line="71" static="1">
			<f a="stack">
				<x path="haxe.CallStack"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a representation of the stack as a printable string.</haxe_doc>
		</toString>
		<subtract public="1" set="method" line="84" static="1">
			<f a="this:stack">
				<c path="Array"><e path="haxe.StackItem"/></c>
				<x path="haxe.CallStack"/>
				<x path="haxe.CallStack"/>
			</f>
			<haxe_doc>Returns a range of entries of current stack from the beginning to the the
		common part of this and `stack`.</haxe_doc>
		</subtract>
		<equalItems set="method" line="119" static="1"><f a="item1:item2">
	<x path="Null"><e path="haxe.StackItem"/></x>
	<x path="Null"><e path="haxe.StackItem"/></x>
	<x path="Bool"/>
</f></equalItems>
		<itemToString set="method" line="155" static="1"><f a="b:s">
	<c path="StringBuf"/>
	<e path="haxe.StackItem"/>
	<x path="Void"/>
</f></itemToString>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":using"><e>haxe.CallStack</e></m>
			<m n=":allow"><e>haxe.Exception</e></m>
		</meta>
	</class>
	<abstract path="haxe.Function" params="" file="/home/runner/haxe/versions/737af26/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with any function type.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<meta><m n=":callable"/></meta>
		<impl><class path="haxe._Constraints.Function_Impl_" params="" file="/home/runner/haxe/versions/737af26/std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.FlatEnum" params="" file="/home/runner/haxe/versions/737af26/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with an enum instance if all constructors of the enum
	require no arguments.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<impl><class path="haxe._Constraints.FlatEnum_Impl_" params="" file="/home/runner/haxe/versions/737af26/std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.NotVoid" params="" file="/home/runner/haxe/versions/737af26/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with anything but `Void`.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<impl><class path="haxe._Constraints.NotVoid_Impl_" params="" file="/home/runner/haxe/versions/737af26/std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.Constructible" params="T" file="/home/runner/haxe/versions/737af26/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc><![CDATA[This type unifies with any instance of classes that have a constructor
	which

	  * is `public` and
	  * unifies with the type used for type parameter `T`.

	If a type parameter `A` is assigned to a type parameter `B` which is constrained
	to `Constructible<T>`, A must be explicitly constrained to
	`Constructible<T>` as well.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.]]></haxe_doc>
		<impl><class path="haxe._Constraints.Constructible_Impl_" params="" file="/home/runner/haxe/versions/737af26/std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.IMap" params="K:V" file="/home/runner/haxe/versions/737af26/std/haxe/Constraints.hx" module="haxe.Constraints" interface="1"><meta><m n=":keep"/></meta></class>
	<abstract path="haxe.DynamicAccess" params="T" file="/home/runner/haxe/versions/737af26/std/haxe/DynamicAccess.hx">
		<from><icast><d><c path="haxe.DynamicAccess.T"/></d></icast></from>
		<this><d><c path="haxe.DynamicAccess.T"/></d></this>
		<to><icast><d><c path="haxe.DynamicAccess.T"/></d></icast></to>
		<haxe_doc>DynamicAccess is an abstract type for working with anonymous structures
	that are intended to hold collections of objects by the string key.

	For example, these types of structures are often created from JSON.

	Basically, it wraps `Reflect` calls in a `Map`-like interface.</haxe_doc>
		<impl><class path="haxe._DynamicAccess.DynamicAccess_Impl_" params="" file="/home/runner/haxe/versions/737af26/std/haxe/DynamicAccess.hx" private="1" module="haxe.DynamicAccess" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.EnumTools" params="" file="/home/runner/haxe/versions/737af26/std/haxe/EnumTools.hx" extern="1">
		<getName public="1" params="T" get="inline" set="null" line="52" static="1">
			<f a="e">
				<x path="Enum"><c path="getName.T"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:

			pack1.pack2.(...).packN.EnumName

		If `e` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is `null`, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getName>
		<createByName public="1" params="T" get="inline" set="null" line="65" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createByName.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createByName.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is `null`, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByName>
		<createByIndex public="1" params="T" get="inline" set="null" line="81" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createByIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createByIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.

		The constructor indices are preserved from Haxe syntax, so the first
		declared is index 0, the next index 1 etc.

		If `e` or `index` is `null`, or if enum `e` has no constructor
		corresponding to index `index`, or if the number of elements in `params`
		does not match the expected number of constructor arguments, or if any
		argument has an invalid type, the result is unspecified.</haxe_doc>
		</createByIndex>
		<createAll public="1" params="T" get="inline" set="null" line="98" static="1">
			<f a="e">
				<x path="Enum"><c path="createAll.T"/></x>
				<c path="Array"><c path="createAll.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array `[]` if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</createAll>
		<getConstructors public="1" params="T" get="inline" set="null" line="110" static="1">
			<f a="e">
				<x path="Enum"><c path="getConstructors.T"/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `c` is `null`, the result is unspecified.</haxe_doc>
		</getConstructors>
		<haxe_doc>This class provides advanced methods on enums. It is ideally used with
	`using EnumTools` and then acts as an
	  [extension](https://haxe.org/manual/lf-static-extension.html) to the
	  `enum` types.

	If the first argument to any of the methods is `null`, the result is
	unspecified.</haxe_doc>
	</class>
	<class path="haxe.EnumValueTools" params="" file="/home/runner/haxe/versions/737af26/std/haxe/EnumTools.hx" module="haxe.EnumTools" extern="1">
		<equals public="1" params="T" get="inline" set="null" line="138" static="1">
			<f a="a:b">
				<c path="equals.T"/>
				<c path="equals.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors (if there are any).

		If `a` or `b` are `null`, the result is unspecified.</haxe_doc>
		</equals>
		<getName public="1" get="inline" set="null" line="149" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getName>
		<getParameters public="1" get="inline" set="null" line="163" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is `[]`.

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getParameters>
		<getIndex public="1" get="inline" set="null" line="175" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getIndex>
		<haxe_doc>This class provides advanced methods on enum values. It is ideally used with
	`using EnumValueTools` and then acts as an
	  [extension](https://haxe.org/manual/lf-static-extension.html) to the
	  `EnumValue` types.

	If the first argument to any of the methods is `null`, the result is
	unspecified.</haxe_doc>
	</class>
	<class path="haxe._Exception.NativeException" params="" file="/home/runner/haxe/versions/737af26/std/js/_std/haxe/Exception.hx" private="1" module="haxe.Exception" extern="1">
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":native"><e>"Error"</e></m>
		</meta>
	</class>
	<class path="haxe.Exception" params="" file="/home/runner/haxe/versions/737af26/std/js/_std/haxe/Exception.hx">
		<extends path="haxe._Exception.NativeException"/>
		<caught set="method" line="18" static="1"><f a="value">
	<x path="Any"/>
	<c path="haxe.Exception"/>
</f></caught>
		<thrown set="method" line="28" static="1">
			<f a="value">
				<x path="Any"/>
				<x path="Any"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</thrown>
		<stack public="1" get="accessor" set="null">
			<x path="haxe.CallStack"/>
			<haxe_doc>The call stack at the moment of the exception creation.</haxe_doc>
		</stack>
		<native public="1" get="accessor" set="null">
			<x path="Any"/>
			<haxe_doc>Native exception, which caused this exception.</haxe_doc>
		</native>
		<__skipStack>
			<x path="Int"/>
			<meta>
				<m n=":ifFeature"><e>"haxe.Exception.get_stack"</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__skipStack>
		<__nativeException>
			<x path="Any"/>
			<meta><m n=":noCompletion"/></meta>
		</__nativeException>
		<__previousException>
			<x path="Null"><c path="haxe.Exception"/></x>
			<meta><m n=":noCompletion"/></meta>
		</__previousException>
		<unwrap set="method" line="70"><f a=""><x path="Any"/></f></unwrap>
		<__shiftStack get="inline" set="null" line="84">
			<f a=""><x path="Void"/></f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":ifFeature"><e>"haxe.Exception.get_stack"</e></m>
			</meta>
		</__shiftStack>
		<get_native final="1" set="method" line="96"><f a=""><x path="Any"/></f></get_native>
		<get_stack set="method" line="101">
			<f a=""><x path="haxe.CallStack"/></f>
			<meta><m n=":ifFeature"><e>"haxe.NativeStackTrace.exceptionStack"</e></m></meta>
		</get_stack>
		<setProperty set="method" line="110">
			<f a="name:value">
				<c path="String"/>
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</setProperty>
		<new public="1" set="method" line="40">
			<f a="message:?previous:?native">
				<c path="String"/>
				<c path="haxe.Exception"/>
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Create a new Exception instance.

		The `previous` argument could be used for exception chaining.

		The `native` argument is for internal usage only.
		There is no need to provide `native` argument manually and no need to keep it
		upon extending `haxe.Exception` unless you know what you're doing.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[Base class for exceptions.

	If this class (or derivatives) is used to catch an exception, then
	`haxe.CallStack.exceptionStack()` will not return a stack for the exception
	caught. Use `haxe.Exception.stack` property instead:
	```haxe
	try {
		throwSomething();
	} catch(e:Exception) {
		trace(e.stack);
	}
	```

	Custom exceptions should extend this class:
	```haxe
	class MyException extends haxe.Exception {}
	//...
	throw new MyException('terrible exception');
	```

	`haxe.Exception` is also a wildcard type to catch any exception:
	```haxe
	try {
		throw 'Catch me!';
	} catch(e:haxe.Exception) {
		trace(e.message); // Output: Catch me!
	}
	```

	To rethrow an exception just throw it again.
	Haxe will try to rethrow an original native exception whenever possible.
	```haxe
	try {
		var a:Array<Int> = null;
		a.push(1); // generates target-specific null-pointer exception
	} catch(e:haxe.Exception) {
		throw e; // rethrows native exception instead of haxe.Exception
	}
	```]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.Json" params="" file="/home/runner/haxe/versions/737af26/std/js/_std/haxe/Json.hx" extern="1">
		<parse public="1" set="method" static="1">
			<f a="text">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc><![CDATA[Parses given JSON-encoded `text` and returns the resulting object.

		JSON objects are parsed into anonymous structures and JSON arrays
		are parsed into `Array<Dynamic>`.

		If given `text` is not valid JSON, an exception will be thrown.

		@see https://haxe.org/manual/std-Json-parsing.html]]></haxe_doc>
		</parse>
		<stringify public="1" set="method" static="1">
			<f a="value:?replacer:?space">
				<d/>
				<f a="key:value">
					<d/>
					<d/>
					<d/>
				</f>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encodes the given `value` and returns the resulting JSON string.

		If `replacer` is given and is not null, it is used to retrieve the
		actual object to be encoded. The `replacer` function takes two parameters,
		the key and the value being encoded. Initial key value is an empty string.

		If `space` is given and is not null, the result will be pretty-printed.
		Successive levels will be indented by this string.

		@see https://haxe.org/manual/std-Json-encoding.html</haxe_doc>
		</stringify>
		<haxe_doc>Cross-platform JSON API: it will automatically use the optimized native API if available.
	Use `-D haxeJSON` to force usage of the Haxe implementation even if a native API is found:
	This will provide extra encoding features such as enums (replaced by their index) and StringMaps.

	@see https://haxe.org/manual/std-Json.html</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
			<m n=":native"><e>"JSON"</e></m>
		</meta>
	</class>
	<class path="haxe._NativeStackTrace.V8Error" params="" file="/home/runner/haxe/versions/737af26/std/js/_std/haxe/NativeStackTrace.hx" private="1" module="haxe.NativeStackTrace" extern="1">
		<prepareStackTrace public="1" static="1"><f a="error:structuredStackTrace">
	<c path="js.lib.Error"/>
	<c path="Array"><t path="haxe.V8CallSite"/></c>
	<x path="Any"/>
</f></prepareStackTrace>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"Error"</e></m>
		</meta>
	</class>
	<typedef path="haxe.V8CallSite" params="" file="/home/runner/haxe/versions/737af26/std/js/_std/haxe/NativeStackTrace.hx" module="haxe.NativeStackTrace"><a>
	<getLineNumber set="method"><f a=""><x path="Int"/></f></getLineNumber>
	<getFunctionName set="method"><f a=""><c path="String"/></f></getFunctionName>
	<getFileName set="method"><f a=""><c path="String"/></f></getFileName>
	<getColumnNumber set="method"><f a=""><x path="Int"/></f></getColumnNumber>
</a></typedef>
	<class path="haxe.NativeStackTrace" params="" file="/home/runner/haxe/versions/737af26/std/js/_std/haxe/NativeStackTrace.hx">
		<lastError static="1"><c path="js.lib.Error"/></lastError>
		<wrapCallSite public="1" static="1">
			<f a="">
				<t path="haxe.V8CallSite"/>
				<t path="haxe.V8CallSite"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</wrapCallSite>
		<saveStack public="1" get="inline" set="null" line="34" static="1">
			<f a="e">
				<c path="js.lib.Error"/>
				<x path="Void"/>
			</f>
			<meta><m n=":ifFeature"><e>"haxe.NativeStackTrace.exceptionStack"</e></m></meta>
		</saveStack>
		<callStack public="1" set="method" line="38" static="1"><f a=""><x path="Any"/></f></callStack>
		<exceptionStack public="1" set="method" line="49" static="1"><f a=""><x path="Any"/></f></exceptionStack>
		<toHaxe public="1" set="method" line="53" static="1">
			<f a="s:?skip" v=":0">
				<x path="Null"><x path="Any"/></x>
				<x path="Int"/>
				<c path="Array"><e path="haxe.StackItem"/></c>
			</f>
			<meta><m n=":value"><e>{ skip : 0 }</e></m></meta>
		</toHaxe>
		<tryHaxeStack set="method" line="89" static="1"><f a="e">
	<x path="Null"><c path="js.lib.Error"/></x>
	<x path="Any"/>
</f></tryHaxeStack>
		<prepareHxStackTrace set="method" line="101" static="1"><f a="e:callsites">
	<c path="js.lib.Error"/>
	<c path="Array"><t path="haxe.V8CallSite"/></c>
	<x path="Any"/>
</f></prepareHxStackTrace>
		<normalize set="method" line="127" static="1">
			<f a="stack:?skipItems" v=":0">
				<x path="Any"/>
				<x path="Int"/>
				<x path="Any"/>
			</f>
			<meta><m n=":value"><e>{ skipItems : 0 }</e></m></meta>
		</normalize>
		<skipLines set="method" line="142" static="1">
			<f a="stack:skip:?pos" v="::0">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ pos : 0 }</e></m></meta>
		</skipLines>
		<haxe_doc>Do not use manually.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":allow"><e>haxe.Exception</e></m>
		</meta>
	</class>
	<typedef path="haxe._Rest.NativeRest" params="T" file="/home/runner/haxe/versions/737af26/std/haxe/Rest.hx" private="1" module="haxe.Rest"><c path="Array"><c path="haxe._Rest.NativeRest.T"/></c></typedef>
	<abstract path="haxe.Rest" params="T" file="/home/runner/haxe/versions/737af26/std/haxe/Rest.hx">
		<from><icast field="of"><c path="Array"><c path="of.T"/></c></icast></from>
		<this><t path="haxe._Rest.NativeRest"><c path="haxe.Rest.T"/></t></this>
		<to><icast field="toArray"><c path="Array"><c path="haxe.Rest.T"/></c></icast></to>
		<haxe_doc><![CDATA[A special type that represents a "rest" function argument.

	The special `...` syntax can be used for convenience and improved readability:

	```haxe
	function f(...rest:Int) {
		$type(rest); // haxe.Rest<Int>
	}

	f(1, 2, 3);

	final array = [1, 2, 3];
	f(...array);
	```

	Should be used as a type for the last argument of a method, indicating that
	an arbitrary number of arguments of the given type can be passed to that method.

	Allows to use array access by index to get values of rest arguments.
	If the index exceeds the amount of rest arguments passed, the result is unspecified.]]></haxe_doc>
		<meta><m n=":coreApi"/></meta>
		<impl><class path="haxe._Rest.Rest_Impl_" params="" file="/home/runner/haxe/versions/737af26/std/haxe/Rest.hx" private="1" module="haxe.Rest" final="1"><meta>
	<m n=":keep"/>
	<m n=":coreApi"/>
</meta></class></impl>
	</abstract>
	<class path="haxe.ValueException" params="" file="/home/runner/haxe/versions/737af26/std/haxe/ValueException.hx">
		<extends path="haxe.Exception"/>
		<value public="1" set="null">
			<x path="Any"/>
			<haxe_doc>Thrown value.</haxe_doc>
		</value>
		<unwrap set="method" line="35" override="1">
			<f a=""><x path="Any"/></f>
			<haxe_doc>Extract an originally thrown value.

		This method must return the same value on subsequent calls.
		Used internally for catching non-native exceptions.
		Do _not_ override unless you know what you are doing.</haxe_doc>
		</unwrap>
		<new public="1" set="method" line="23"><f a="value:?previous:?native">
	<x path="Any"/>
	<c path="haxe.Exception"/>
	<x path="Any"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>An exception containing arbitrary value.

	This class is automatically used for throwing values, which don't extend `haxe.Exception`
	or native exception type.
	For example:
	```haxe
	throw "Terrible error";
	```
	will be compiled to
	```haxe
	throw new ValueException("Terrible error");
	```</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ds.TreeNode" params="K:V" file="/home/runner/haxe/versions/737af26/std/haxe/ds/BalancedTree.hx" module="haxe.ds.BalancedTree">
		<left public="1"><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
</c></left>
		<right public="1"><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
</c></right>
		<key public="1"><c path="haxe.ds.TreeNode.K"/></key>
		<value public="1"><c path="haxe.ds.TreeNode.V"/></value>
		<_height><x path="Int"/></_height>
		<get_height public="1" get="inline" set="null" line="264"><f a=""><x path="Int"/></f></get_height>
		<new public="1" set="method" line="252">
			<f a="l:k:v:r:?h" v="::::-1">
				<c path="haxe.ds.TreeNode">
					<c path="haxe.ds.TreeNode.K"/>
					<c path="haxe.ds.TreeNode.V"/>
				</c>
				<c path="haxe.ds.TreeNode.K"/>
				<c path="haxe.ds.TreeNode.V"/>
				<c path="haxe.ds.TreeNode">
					<c path="haxe.ds.TreeNode.K"/>
					<c path="haxe.ds.TreeNode.V"/>
				</c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ h : -1 }</e></m></meta>
		</new>
		<haxe_doc>A tree node of `haxe.ds.BalancedTree`.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.ds.IntMap" params="T" file="/home/runner/haxe/versions/737af26/std/js/_std/haxe/ds/IntMap.hx">
		<implements path="haxe.IMap">
			<x path="Int"/>
			<c path="haxe.ds.IntMap.T"/>
		</implements>
		<h><d/></h>
		<remove public="1" set="method" line="44">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<new public="1" get="inline" set="null" line="28">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new IntMap.</haxe_doc>
		</new>
		<haxe_doc>IntMap allows mapping of Int keys to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="haxe.ds.Map" params="K:V" file="/home/runner/haxe/versions/737af26/std/haxe/ds/Map.hx">
		<from>
			<icast field="fromStringMap"><c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c></icast>
			<icast field="fromIntMap"><c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c></icast>
			<icast field="fromObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="fromObjectMap.K"/>
	<c path="fromObjectMap.V"/>
</c></icast>
		</from>
		<this><c path="haxe.IMap">
	<c path="haxe.ds.Map.K"/>
	<c path="haxe.ds.Map.V"/>
</c></this>
		<to>
			<icast field="toStringMap"><c path="haxe.ds.StringMap"><c path="toStringMap.V"/></c></icast>
			<icast field="toIntMap"><c path="haxe.ds.IntMap"><c path="toIntMap.V"/></c></icast>
			<icast field="toEnumValueMapMap"><c path="haxe.ds.EnumValueMap">
	<c path="toEnumValueMapMap.K"/>
	<c path="toEnumValueMapMap.V"/>
</c></icast>
			<icast field="toObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="toObjectMap.K"/>
	<c path="toObjectMap.V"/>
</c></icast>
		</to>
		<haxe_doc><![CDATA[Map allows key to value mapping for arbitrary value types, and many key
	types.

	This is a multi-type abstract, it is instantiated as one of its
	specialization types depending on its type parameters.

	A Map can be instantiated without explicit type parameters. Type inference
	will then determine the type parameters from the usage.

	Maps can also be created with `[key1 => value1, key2 => value2]` syntax.

	Map is an abstract type, it is not available at runtime.

	@see https://haxe.org/manual/std-Map.html]]></haxe_doc>
		<meta>
			<m n=":transitive"/>
			<m n=":multiType"><e>@:followWithAbstracts K</e></m>
		</meta>
		<impl><class path="haxe.ds._Map.Map_Impl_" params="" file="/home/runner/haxe/versions/737af26/std/haxe/ds/Map.hx" private="1" module="haxe.ds.Map" final="1">
	<_new public="1" set="method" static="1">
		<f a=""><x path="haxe.ds.Map">
	<c path="haxe.ds.Map.K"/>
	<c path="haxe.ds.Map.V"/>
</x></f>
		<meta><m n=":noCompletion"/></meta>
		<haxe_doc>Creates a new Map.

		This becomes a constructor call to one of the specialization types in
		the output. The rules for that are as follows:

		1. if `K` is a `String`, `haxe.ds.StringMap` is used
		2. if `K` is an `Int`, `haxe.ds.IntMap` is used
		3. if `K` is an `EnumValue`, `haxe.ds.EnumValueMap` is used
		4. if `K` is any other class or structure, `haxe.ds.ObjectMap` is used
		5. if `K` is any other type, it causes a compile-time error

		(Cpp) Map does not use weak keys on `ObjectMap` by default.</haxe_doc>
	</_new>
	<meta><m n=":keep"/></meta>
</class></impl>
	</abstract>
	<class path="haxe.ds._Map.Map_Impl_" params="" file="/home/runner/haxe/versions/737af26/std/haxe/ds/Map.hx" private="1" module="haxe.ds.Map" final="1">
		<_new public="1" set="method" static="1">
			<f a=""><x path="haxe.ds.Map">
	<c path="haxe.ds.Map.K"/>
	<c path="haxe.ds.Map.V"/>
</x></f>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>Creates a new Map.

		This becomes a constructor call to one of the specialization types in
		the output. The rules for that are as follows:

		1. if `K` is a `String`, `haxe.ds.StringMap` is used
		2. if `K` is an `Int`, `haxe.ds.IntMap` is used
		3. if `K` is an `EnumValue`, `haxe.ds.EnumValueMap` is used
		4. if `K` is any other class or structure, `haxe.ds.ObjectMap` is used
		5. if `K` is any other type, it causes a compile-time error

		(Cpp) Map does not use weak keys on `ObjectMap` by default.</haxe_doc>
		</_new>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.ds.ObjectMap" params="K:V" file="/home/runner/haxe/versions/737af26/std/js/_std/haxe/ds/ObjectMap.hx">
		<implements path="haxe.IMap">
			<c path="haxe.ds.ObjectMap.K"/>
			<c path="haxe.ds.ObjectMap.V"/>
		</implements>
		<h><a><__keys__><a/></__keys__></a></h>
		<set public="1" set="method" line="45">
			<f a="key:value">
				<c path="haxe.ds.ObjectMap.K"/>
				<c path="haxe.ds.ObjectMap.V"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<remove public="1" set="method" line="62">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<new public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new ObjectMap.</haxe_doc>
		</new>
		<haxe_doc>ObjectMap allows mapping of object keys to arbitrary values.

	On static targets, the keys are considered to be strong references. Refer
	to `haxe.ds.WeakMap` for a weak reference version.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="haxe.ds.ReadOnlyArray" params="T" file="/home/runner/haxe/versions/737af26/std/haxe/ds/ReadOnlyArray.hx">
		<from><icast><c path="Array"><c path="haxe.ds.ReadOnlyArray.T"/></c></icast></from>
		<this><c path="Array"><c path="haxe.ds.ReadOnlyArray.T"/></c></this>
		<to><icast><t path="Iterable"><c path="haxe.ds.ReadOnlyArray.T"/></t></icast></to>
		<haxe_doc>`ReadOnlyArray` is an abstract over an ordinary `Array` which only exposes
	APIs that don't modify the instance, hence "read-only".

	Note that this doesn't necessarily mean that the instance is *immutable*.
	Other code holding a reference to the underlying `Array` can still modify it,
	and the reference can be obtained with a `cast`.</haxe_doc>
		<meta><m n=":forward">
	<e>copy</e>
	<e>filter</e>
	<e>indexOf</e>
	<e>iterator</e>
	<e>keyValueIterator</e>
	<e>join</e>
	<e>lastIndexOf</e>
	<e>map</e>
	<e>slice</e>
	<e>contains</e>
	<e>toString</e>
</m></meta>
		<impl><class path="haxe.ds._ReadOnlyArray.ReadOnlyArray_Impl_" params="" file="/home/runner/haxe/versions/737af26/std/haxe/ds/ReadOnlyArray.hx" private="1" module="haxe.ds.ReadOnlyArray" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.ds.StringMap" params="T" file="/home/runner/haxe/versions/737af26/std/js/_std/haxe/ds/StringMap.hx">
		<implements path="haxe.IMap">
			<c path="String"/>
			<c path="haxe.ds.StringMap.T"/>
		</implements>
		<h><d/></h>
		<new public="1" get="inline" set="null" line="33">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringMap.</haxe_doc>
		</new>
		<haxe_doc>StringMap allows mapping of String keys to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="haxe.extern.EitherType" params="T1:T2" file="/home/runner/haxe/versions/737af26/std/haxe/extern/EitherType.hx">
		<from>
			<icast><c path="haxe.extern.EitherType.T1"/></icast>
			<icast><c path="haxe.extern.EitherType.T2"/></icast>
		</from>
		<this><d/></this>
		<to>
			<icast><c path="haxe.extern.EitherType.T1"/></icast>
			<icast><c path="haxe.extern.EitherType.T2"/></icast>
		</to>
		<haxe_doc><![CDATA[An abstract type allowing values to be either of `T1` or `T2` type.
	Supports implicit casts from/to either types.

	It is useful for interfacing with external code on dynamic platforms
	such as JavaScript or Python.

	Otherwise, use of this type is discouraged.

	@see <https://haxe.org/manual/lf-externs.html>]]></haxe_doc>
		<meta><m n=":transitive"/></meta>
		<impl><class path="haxe.extern._EitherType.EitherType_Impl_" params="" file="/home/runner/haxe/versions/737af26/std/haxe/extern/EitherType.hx" private="1" module="haxe.extern.EitherType" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<typedef path="haxe.extern.Rest" params="T" file="/home/runner/haxe/versions/737af26/std/haxe/extern/Rest.hx">
		<x path="haxe.Rest"><c path="haxe.extern.Rest.T"/></x>
		<haxe_doc><![CDATA[DEPRECATED: use haxe.Rest instead.
	
	A special type that represents "rest" function argument.
	Should be used as a type for the last argument of an extern method,
	representing that arbitrary number of arguments of given type can be
	passed to that method.
	@see <https://haxe.org/manual/lf-externs.html>]]></haxe_doc>
	</typedef>
	<class path="haxe.iterators.ArrayIterator" params="T" file="/home/runner/haxe/versions/737af26/std/haxe/iterators/ArrayIterator.hx">
		<array final="1"><c path="Array"><c path="haxe.iterators.ArrayIterator.T"/></c></array>
		<current expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</current>
		<hasNext public="1" get="inline" set="null" line="44">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>See `Iterator.hasNext`</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="52">
			<f a=""><c path="haxe.iterators.ArrayIterator.T"/></f>
			<haxe_doc>See `Iterator.next`</haxe_doc>
		</next>
		<new public="1" get="inline" set="null" line="35">
			<f a="array">
				<c path="Array"><c path="haxe.iterators.ArrayIterator.T"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a new `ArrayIterator`.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[This iterator is used only when `Array<T>` is passed to `Iterable<T>`]]></haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="js.Boot" params="" file="/home/runner/haxe/versions/737af26/std/js/Boot.hx">
		<__string_rec set="method" line="58" static="1">
			<f a="o:s">
				<a>
					<toString set="null"><f a=""><c path="String"/></f></toString>
					<length set="null"><x path="Int"/></length>
					<hasOwnProperty set="null"><f a="">
	<c path="String"/>
	<x path="Bool"/>
</f></hasOwnProperty>
					<_hx_index set="null"><x path="Int"/></_hx_index>
					<__enum__ set="null"><x path="Bool"/></__enum__>
				</a>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":ifFeature"><e>"has_enum"</e></m>
			</meta>
		</__string_rec>
		<__toStr static="1"><c path="js.lib.Function"/></__toStr>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="js.Lib" params="" file="/home/runner/haxe/versions/737af26/std/js/Lib.hx">
		<require public="1" get="inline" set="null" line="65" static="1">
			<f a="module">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Inserts a `require` expression that loads JavaScript object from
		a module or file specified in the `module` argument.

		This is only supported in environments where `require` function
		is available, such as Node.js or RequireJS.</haxe_doc>
		</require>
		<parseInt public="1" get="accessor" set="null" static="1">
			<f a="string:?radix">
				<c path="String"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Native JavaScript `parseInt` function.

		Its specification is different from `Std.parseInt`, so one
		might want to access the native one.</haxe_doc>
		</parseInt>
		<get_parseInt get="inline" set="null" line="77" static="1"><f a=""><f a="string:?radix">
	<c path="String"/>
	<x path="Int"/>
	<x path="Float"/>
</f></f></get_parseInt>
		<nativeThis public="1" get="accessor" set="null" static="1">
			<d/>
			<haxe_doc>`nativeThis` is the JavaScript `this`, which is semantically different
		from the Haxe `this`. Use `nativeThis` only when working with external
		JavaScript code.

		In Haxe, `this` is always bound to a class instance.
		In JavaScript, `this` in a function can be bound to an arbitrary
		variable when the function is called using `func.call(thisObj, ...)` or
		`func.apply(thisObj, [...])`.

		Read more at https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this</haxe_doc>
		</nativeThis>
		<get_nativeThis get="inline" set="null" line="108" static="1"><f a=""><d/></f></get_nativeThis>
		<typeof public="1" get="inline" set="null" line="118" static="1">
			<f a="o">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Call JavaScript `typeof` operator on the `o` value
		and return a string representing the JavaScript type of a value.

		Read more at https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof</haxe_doc>
		</typeof>
		<global public="1" get="accessor" set="null" static="1">
			<d/>
			<haxe_doc>An alias of the JS "global" object.

		Concretely, it is set as the first defined value in the list of
		`window`, `global`, `self`, and `this` in the top-level of the compiled output.</haxe_doc>
		</global>
		<get_global get="inline" set="null" line="130" static="1">
			<f a=""><d/></f>
			<meta><m n=":has_untyped"/></meta>
		</get_global>
		<haxe_doc>Platform-specific JavaScript Library. Provides some platform-specific functions
	for the JavaScript target.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="js.lib.Error" params="" file="/home/runner/haxe/versions/737af26/std/js/lib/Error.hx" extern="1">
		<message public="1"><c path="String"/></message>
		<name public="1"><c path="String"/></name>
		<stack public="1" set="null"><c path="String"/></stack>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"Error"</e></m>
		</meta>
	</class>
	<class path="js.lib.EvalError" params="" file="/home/runner/haxe/versions/737af26/std/js/lib/Error.hx" module="js.lib.Error" extern="1">
		<extends path="js.lib.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"EvalError"</e></m></meta>
	</class>
	<class path="js.lib.RangeError" params="" file="/home/runner/haxe/versions/737af26/std/js/lib/Error.hx" module="js.lib.Error" extern="1">
		<extends path="js.lib.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"RangeError"</e></m></meta>
	</class>
	<class path="js.lib.ReferenceError" params="" file="/home/runner/haxe/versions/737af26/std/js/lib/Error.hx" module="js.lib.Error" extern="1">
		<extends path="js.lib.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"ReferenceError"</e></m></meta>
	</class>
	<class path="js.lib.SyntaxError" params="" file="/home/runner/haxe/versions/737af26/std/js/lib/Error.hx" module="js.lib.Error" extern="1">
		<extends path="js.lib.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"SyntaxError"</e></m></meta>
	</class>
	<class path="js.lib.TypeError" params="" file="/home/runner/haxe/versions/737af26/std/js/lib/Error.hx" module="js.lib.Error" extern="1">
		<extends path="js.lib.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"TypeError"</e></m></meta>
	</class>
	<class path="js.lib.URIError" params="" file="/home/runner/haxe/versions/737af26/std/js/lib/Error.hx" module="js.lib.Error" extern="1">
		<extends path="js.lib.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"URIError"</e></m></meta>
	</class>
	<class path="js.lib.Function" params="" file="/home/runner/haxe/versions/737af26/std/js/lib/Function.hx" extern="1">
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>Specifies the number of arguments expected by the function.</haxe_doc>
		</length>
		<name public="1">
			<c path="String"/>
			<haxe_doc>The name of the function.</haxe_doc>
		</name>
		<apply public="1" set="method">
			<f a="thisArg:argsArray">
				<d/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>Calls a function and sets its this to the provided value, arguments can be passed as an Array object.</haxe_doc>
		</apply>
		<call public="1" set="method">
			<f a="thisArg:args">
				<d/>
				<t path="haxe.extern.Rest"><d/></t>
				<d/>
			</f>
			<haxe_doc>Calls (executes) a function and sets its this to the provided value, arguments can be passed as they are.</haxe_doc>
		</call>
		<bind public="1" set="method">
			<f a="thisArg:args">
				<d/>
				<t path="haxe.extern.Rest"><d/></t>
				<c path="js.lib.Function"/>
			</f>
			<haxe_doc>Creates a new function which, when called, has its this set to the provided value,
		with a given sequence of arguments preceding any provided when the new function was called.</haxe_doc>
		</bind>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representing the source code of the function.</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="arg:rest">
				<c path="String"/>
				<t path="haxe.extern.Rest"><c path="String"/></t>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new Function object.</haxe_doc>
		</new>
		<meta><m n=":native"><e>"Function"</e></m></meta>
	</class>
	<class path="js.lib.Object" params="" file="/home/runner/haxe/versions/737af26/std/js/lib/Object.hx" extern="1">
		<assign public="1" params="T" set="method" static="1">
			<f a="target:sources">
				<c path="assign.T"/>
				<t path="haxe.extern.Rest"><a/></t>
				<c path="assign.T"/>
			</f>
			<haxe_doc>Copies the values of all enumerable own properties from one or more
		source objects to a target object.</haxe_doc>
		</assign>
		<create public="1" params="T" set="method" static="1">
			<f a="proto:?propertiesObject">
				<a/>
				<x path="haxe.DynamicAccess"><t path="js.lib.ObjectPropertyDescriptor"/></x>
				<c path="create.T"/>
			</f>
			<haxe_doc>Creates a new object with the specified prototype object and properties.</haxe_doc>
		</create>
		<defineProperties public="1" params="T" set="method" static="1">
			<f a="obj:props">
				<c path="defineProperties.T"/>
				<x path="haxe.DynamicAccess"><t path="js.lib.ObjectPropertyDescriptor"/></x>
				<c path="defineProperties.T"/>
			</f>
			<haxe_doc>Adds the named properties described by the given descriptors to an object.</haxe_doc>
		</defineProperties>
		<defineProperty public="1" params="T" set="method" static="1">
			<f a="obj:prop:descriptor">
				<c path="defineProperty.T"/>
				<c path="String"/>
				<t path="js.lib.ObjectPropertyDescriptor"/>
				<c path="defineProperty.T"/>
			</f>
			<haxe_doc>Adds the named property described by a given descriptor to an object.</haxe_doc>
			<overloads><defineProperty public="1" params="T" set="method">
	<f a="obj:prop:descriptor">
		<c path="defineProperty.T"/>
		<c path="js.lib.Symbol"/>
		<t path="js.lib.ObjectPropertyDescriptor"/>
		<c path="defineProperty.T"/>
	</f>
	<haxe_doc>Adds the named property described by a given descriptor to an object.</haxe_doc>
</defineProperty></overloads>
		</defineProperty>
		<entries public="1" set="method" static="1">
			<f a="obj">
				<a/>
				<c path="Array"><x path="js.lib.ObjectEntry"/></c>
			</f>
			<haxe_doc>Returns an array containing all of the [key, value] pairs of a given
		object's own enumerable string properties.</haxe_doc>
		</entries>
		<freeze public="1" params="T" set="method" static="1">
			<f a="obj">
				<c path="freeze.T"/>
				<c path="freeze.T"/>
			</f>
			<haxe_doc>Freezes an object: other code can't delete or change any properties.</haxe_doc>
		</freeze>
		<fromEntries public="1" params="T" set="method" static="1">
			<f a="iterable">
				<x path="Any"/>
				<c path="fromEntries.T"/>
			</f>
			<haxe_doc>Returns a new object from an iterable of key-value pairs
		(reverses Object.entries).</haxe_doc>
		</fromEntries>
		<getOwnPropertyDescriptor public="1" set="method" static="1">
			<f a="obj:prop">
				<a/>
				<c path="String"/>
				<x path="Null"><t path="js.lib.ObjectPropertyDescriptor"/></x>
			</f>
			<haxe_doc>Returns a property descriptor for a named property on an object.</haxe_doc>
			<overloads>
				<getOwnPropertyDescriptor public="1" params="T" set="method">
					<f a="target:propertyKey">
						<c path="Array"><c path="getOwnPropertyDescriptor.T"/></c>
						<x path="Int"/>
						<x path="Null"><t path="js.lib.ObjectPropertyDescriptor"/></x>
					</f>
					<haxe_doc>Returns a property descriptor for a named property on an object.</haxe_doc>
				</getOwnPropertyDescriptor>
				<getOwnPropertyDescriptor public="1" set="method">
					<f a="obj:prop">
						<a/>
						<c path="js.lib.Symbol"/>
						<x path="Null"><t path="js.lib.ObjectPropertyDescriptor"/></x>
					</f>
					<haxe_doc>Returns a property descriptor for a named property on an object.</haxe_doc>
				</getOwnPropertyDescriptor>
			</overloads>
		</getOwnPropertyDescriptor>
		<getOwnPropertyNames public="1" set="method" static="1">
			<f a="obj">
				<a/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns an array containing the names of all of the given object's own
		enumerable and non-enumerable properties.</haxe_doc>
		</getOwnPropertyNames>
		<getOwnPropertySymbols public="1" set="method" static="1">
			<f a="obj">
				<a/>
				<c path="Array"><c path="js.lib.Symbol"/></c>
			</f>
			<haxe_doc>Returns an array of all symbol properties found directly upon a given object.</haxe_doc>
		</getOwnPropertySymbols>
		<getPrototypeOf public="1" params="TProto" set="method" static="1">
			<f a="obj">
				<a/>
				<x path="Null"><c path="getPrototypeOf.TProto"/></x>
			</f>
			<haxe_doc>Returns the prototype of the specified object.</haxe_doc>
		</getPrototypeOf>
		<is public="1" params="T" set="method" static="1">
			<f a="value1:value2">
				<c path="is.T"/>
				<c path="is.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Compares if two values are the same value. Equates all NaN values
		(which differs from both Abstract Equality Comparison and
		Strict Equality Comparison).</haxe_doc>
		</is>
		<isExtensible public="1" set="method" static="1">
			<f a="obj">
				<a/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Determines if extending of an object is allowed.</haxe_doc>
		</isExtensible>
		<isFrozen public="1" set="method" static="1">
			<f a="obj">
				<a/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Determines if an object was frozen.</haxe_doc>
		</isFrozen>
		<isSealed public="1" set="method" static="1">
			<f a="obj">
				<a/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Determines if an object is sealed.</haxe_doc>
		</isSealed>
		<keys public="1" set="method" static="1">
			<f a="obj">
				<a/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns an array containing the names of all of the given object's own
		enumerable string properties.</haxe_doc>
		</keys>
		<preventExtensions public="1" params="T" set="method" static="1">
			<f a="obj">
				<c path="preventExtensions.T"/>
				<c path="preventExtensions.T"/>
			</f>
			<haxe_doc>Prevents any extensions of an object.</haxe_doc>
		</preventExtensions>
		<seal public="1" params="T" set="method" static="1">
			<f a="obj">
				<c path="seal.T"/>
				<c path="seal.T"/>
			</f>
			<haxe_doc>Prevents other code from deleting properties of an object.</haxe_doc>
		</seal>
		<setPrototypeOf public="1" params="T" set="method" static="1">
			<f a="obj:prototype">
				<c path="setPrototypeOf.T"/>
				<x path="Null"><a/></x>
				<c path="setPrototypeOf.T"/>
			</f>
			<haxe_doc>Sets the prototype (i.e., the internal Prototype property).</haxe_doc>
		</setPrototypeOf>
		<values public="1" set="method" static="1">
			<f a="obj">
				<a/>
				<c path="Array"><x path="Any"/></c>
			</f>
			<haxe_doc>Returns an array containing the values that correspond to all of
		a given object's own enumerable string properties.</haxe_doc>
		</values>
		<prototype public="1" set="null" static="1">
			<t path="js.lib.ObjectPrototype"/>
			<haxe_doc>Allows the addition of properties to all objects of type Object.</haxe_doc>
		</prototype>
		<new public="1" set="method">
			<f a="?value">
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<haxe_doc>The Object constructor creates an object wrapper.</haxe_doc>
		</new>
		<haxe_doc>The `js.lib.Object` constructor creates an object wrapper.

	Documentation [Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"Object"</e></m>
		</meta>
	</class>
	<typedef path="js.lib.ObjectPrototype" params="" file="/home/runner/haxe/versions/737af26/std/js/lib/Object.hx" module="js.lib.Object">
		<a>
			<valueOf set="null">
				<c path="js.lib.Function"/>
				<haxe_doc>Returns the primitive value of the specified object.</haxe_doc>
			</valueOf>
			<toString set="null">
				<c path="js.lib.Function"/>
				<haxe_doc>Returns a string representation of the object.</haxe_doc>
			</toString>
			<toLocaleString set="null">
				<c path="js.lib.Function"/>
				<haxe_doc>Calls `toString()`.</haxe_doc>
			</toLocaleString>
			<propertyIsEnumerable set="null">
				<c path="js.lib.Function"/>
				<haxe_doc>Returns a boolean indicating if the internal enumerable attribute is set.</haxe_doc>
			</propertyIsEnumerable>
			<isPrototypeOf set="null">
				<c path="js.lib.Function"/>
				<haxe_doc>Returns a boolean indicating whether the object this method is called
		upon is in the prototype chain of the specified object.</haxe_doc>
			</isPrototypeOf>
			<hasOwnProperty set="null">
				<c path="js.lib.Function"/>
				<haxe_doc>Returns a boolean indicating whether an object contains the specified
		property as a direct property of that object and not inherited through
		the prototype chain.</haxe_doc>
			</hasOwnProperty>
		</a>
		<haxe_doc><![CDATA[Type for
	@see <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object>]]></haxe_doc>
	</typedef>
	<typedef path="js.lib.ObjectPropertyDescriptor" params="" file="/home/runner/haxe/versions/737af26/std/js/lib/Object.hx" module="js.lib.Object">
		<a>
			<writable>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>`true` if and only if the value associated with the property may be
		changed with an assignment operator.

		Defaults to `false`.</haxe_doc>
			</writable>
			<value>
				<x path="Null"><x path="Any"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The value associated with the property.
		Can be any valid JavaScript value (number, object, function, etc).</haxe_doc>
			</value>
			<set>
				<x path="Null"><f a="">
	<x path="Any"/>
	<x path="Void"/>
</f></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>A function which serves as a setter for the property, or undefined if
		there is no setter. When the property is assigned to, this function
		is called with one argument (the value being assigned to the property)
		and with `this` set to the object through which the property is assigned.</haxe_doc>
			</set>
			<get>
				<x path="Null"><f a=""><x path="Any"/></f></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>A function which serves as a getter for the property, or `undefined` if
		there is no getter. When the property is accessed, this function is
		called without arguments and with `this` set to the object through which
		the property is accessed (this may not be the object on which the
		property is defined due to inheritance).
		The return value will be used as the value of the property.</haxe_doc>
			</get>
			<enumerable>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>`true` if and only if this property shows up during enumeration of the
		properties on the corresponding object.

		Defaults to `false`.</haxe_doc>
			</enumerable>
			<configurable>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>`true` if and only if the type of this property descriptor may be
		changed and if the property may be deleted from the corresponding object.

		Defaults to `false`.</haxe_doc>
			</configurable>
		</a>
		<haxe_doc><![CDATA[@see <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty>]]></haxe_doc>
	</typedef>
	<abstract path="js.lib.ObjectEntry" params="" file="/home/runner/haxe/versions/737af26/std/js/lib/Object.hx" module="js.lib.Object">
		<this><c path="Array"><x path="Any"/></c></this>
		<haxe_doc>Key/value access helper for `js.lib.Object.entries()`.</haxe_doc>
		<impl><class path="js.lib._Object.ObjectEntry_Impl_" params="" file="/home/runner/haxe/versions/737af26/std/js/lib/Object.hx" private="1" module="js.lib.Object" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="js.lib.Promise" params="T" file="/home/runner/haxe/versions/737af26/std/js/lib/Promise.hx" extern="1">
		<resolve public="1" params="T" set="method" static="1">
			<f a="thenable">
				<x path="js.lib.Thenable"><c path="resolve.T"/></x>
				<c path="js.lib.Promise"><c path="resolve.T"/></c>
			</f>
			<haxe_doc>Returns a Promise object that is resolved with the given value. If the
		value is Thenable, the returned promise will "follow" that
		thenable, adopting its eventual state;
		otherwise the returned promise will be fulfilled with the value.
		Generally, when it's unknown when value is a promise or not,
		use `Promise.resolve(value)` instead and work with the return value as
		a promise.</haxe_doc>
			<overloads><resolve public="1" params="T" set="method">
	<f a="?value">
		<c path="resolve.T"/>
		<c path="js.lib.Promise"><c path="resolve.T"/></c>
	</f>
	<haxe_doc>Returns a Promise object that is resolved with the given value. If the
		value is Thenable, the returned promise will "follow" that
		thenable, adopting its eventual state;
		otherwise the returned promise will be fulfilled with the value.
		Generally, when it's unknown when value is a promise or not,
		use `Promise.resolve(value)` instead and work with the return value as
		a promise.</haxe_doc>
</resolve></overloads>
		</resolve>
		<reject public="1" params="T" set="method" static="1">
			<f a="?reason">
				<d/>
				<c path="js.lib.Promise"><c path="reject.T"/></c>
			</f>
			<haxe_doc>Returns a Promise object that is rejected with the given reason.</haxe_doc>
		</reject>
		<all public="1" params="T" set="method" static="1">
			<f a="iterable">
				<c path="Array"><c path="js.lib.Promise"><c path="all.T"/></c></c>
				<c path="js.lib.Promise"><c path="Array"><c path="all.T"/></c></c>
			</f>
			<haxe_doc>Returns a promise that either fulfills when all of the promises in the
		iterable argument have fulfilled or rejects as soon as one of the
		promises in the iterable argument rejects. If the returned promise
		fulfills, it is fulfilled with an array of the values from the
		fulfilled promises in the same order as defined in the iterable.
		If the returned promise rejects, it is rejected with the reason from
		the first promise in the iterable that rejected. This method can be
		useful for aggregating results of multiple promises.</haxe_doc>
			<overloads><all public="1" set="method">
	<f a="iterable">
		<c path="Array"><d/></c>
		<c path="js.lib.Promise"><c path="Array"><d/></c></c>
	</f>
	<haxe_doc>Returns a promise that either fulfills when all of the promises in the
		iterable argument have fulfilled or rejects as soon as one of the
		promises in the iterable argument rejects. If the returned promise
		fulfills, it is fulfilled with an array of the values from the
		fulfilled promises in the same order as defined in the iterable.
		If the returned promise rejects, it is rejected with the reason from
		the first promise in the iterable that rejected. This method can be
		useful for aggregating results of multiple promises.</haxe_doc>
</all></overloads>
		</all>
		<allSettled public="1" params="T" set="method" static="1">
			<f a="iterable">
				<c path="Array"><c path="js.lib.Promise"><c path="allSettled.T"/></c></c>
				<c path="js.lib.Promise"><c path="Array"><t path="js.lib.PromiseSettleOutcome"><c path="allSettled.T"/></t></c></c>
			</f>
			<haxe_doc>Returns a promise that resolves after all of the given promises have either fulfilled or rejected,
		with an array of objects that each describes the outcome of each promise.

		It is typically used when you have multiple asynchronous tasks that are not dependent on one another
		to complete successfully, or you'd always like to know the result of each promise.

		In comparison, the Promise returned by `Promise.all` may be more appropriate if the tasks are dependent
		on each other / if you'd like to immediately reject upon any of them rejecting.</haxe_doc>
			<overloads><allSettled public="1" set="method">
	<f a="iterable">
		<c path="Array"><d/></c>
		<c path="js.lib.Promise"><c path="Array"><t path="js.lib.PromiseSettleOutcome"><d/></t></c></c>
	</f>
	<haxe_doc>Returns a promise that resolves after all of the given promises have either fulfilled or rejected,
		with an array of objects that each describes the outcome of each promise.

		It is typically used when you have multiple asynchronous tasks that are not dependent on one another
		to complete successfully, or you'd always like to know the result of each promise.

		In comparison, the Promise returned by `Promise.all` may be more appropriate if the tasks are dependent
		on each other / if you'd like to immediately reject upon any of them rejecting.</haxe_doc>
</allSettled></overloads>
		</allSettled>
		<race public="1" params="T" set="method" static="1">
			<f a="iterable">
				<c path="Array"><c path="js.lib.Promise"><c path="race.T"/></c></c>
				<c path="js.lib.Promise"><c path="race.T"/></c>
			</f>
			<haxe_doc>Returns a promise that fulfills or rejects as soon as one of the
		promises in the iterable fulfills or rejects, with the value or reason
		from that promise.</haxe_doc>
			<overloads><race public="1" set="method">
	<f a="iterable">
		<c path="Array"><d/></c>
		<c path="js.lib.Promise"><d/></c>
	</f>
	<haxe_doc>Returns a promise that fulfills or rejects as soon as one of the
		promises in the iterable fulfills or rejects, with the value or reason
		from that promise.</haxe_doc>
</race></overloads>
		</race>
		<then public="1" params="TOut" set="method">
			<f a="onFulfilled:?onRejected">
				<x path="Null"><x path="js.lib.PromiseHandler">
	<c path="js.lib.Promise.T"/>
	<c path="then.TOut"/>
</x></x>
				<x path="js.lib.PromiseHandler">
					<d/>
					<c path="then.TOut"/>
				</x>
				<c path="js.lib.Promise"><c path="then.TOut"/></c>
			</f>
			<haxe_doc>Appends fulfillment and rejection handlers to the promise and returns a
		new promise resolving to the return value of the called handler, or to
		its original settled value if the promise was not handled
		(i.e. if the relevant handler onFulfilled or onRejected is not a function).</haxe_doc>
		</then>
		<catchError public="1" set="method">
			<f a="onRejected">
				<x path="js.lib.PromiseHandler">
					<d/>
					<c path="js.lib.Promise.T"/>
				</x>
				<c path="js.lib.Promise"><c path="js.lib.Promise.T"/></c>
			</f>
			<meta><m n=":native"><e>"catch"</e></m></meta>
			<haxe_doc>Appends a rejection handler callback to the promise, and returns a new
		promise resolving to the return value of the callback if it is called,
		or to its original fulfillment value if the promise is instead fulfilled.</haxe_doc>
			<overloads><catch public="1" params="TOut" set="method">
	<f a="onRejected">
		<x path="js.lib.PromiseHandler">
			<d/>
			<c path="catchError.TOut"/>
		</x>
		<c path="js.lib.Promise"><x path="haxe.extern.EitherType">
	<c path="js.lib.Promise.T"/>
	<c path="catchError.TOut"/>
</x></c>
	</f>
	<meta><m n=":native"><e>"catch"</e></m></meta>
	<haxe_doc>Appends a rejection handler callback to the promise, and returns a new
		promise resolving to the return value of the callback if it is called,
		or to its original fulfillment value if the promise is instead fulfilled.</haxe_doc>
</catch></overloads>
		</catchError>
		<finally public="1" set="method">
			<f a="onFinally">
				<f a=""><x path="Void"/></f>
				<c path="js.lib.Promise"><c path="js.lib.Promise.T"/></c>
			</f>
			<haxe_doc>Returns a Promise. When the promise is settled, i.e either fulfilled or rejected,
		the specified callback function is executed. This provides a way for code to be run
		whether the promise was fulfilled successfully or rejected once the Promise has been dealt with.</haxe_doc>
		</finally>
		<new public="1" set="method">
			<f a="init">
				<f a="resolve:reject">
					<f a="value">
						<c path="js.lib.Promise.T"/>
						<x path="Void"/>
					</f>
					<f a="reason">
						<d/>
						<x path="Void"/>
					</f>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<haxe_doc>The Promise object represents the eventual completion (or failure) of an
	asynchronous operation and its resulting value.

	Documentation [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).</haxe_doc>
		<meta><m n=":native"><e>"Promise"</e></m></meta>
	</class>
	<abstract path="js.lib.PromiseHandler" params="T:TOut" file="/home/runner/haxe/versions/737af26/std/js/lib/Promise.hx" module="js.lib.Promise">
		<from>
			<icast><f a="">
	<c path="js.lib.PromiseHandler.T"/>
	<c path="js.lib.Promise"><c path="js.lib.PromiseHandler.TOut"/></c>
</f></icast>
			<icast><f a="">
	<c path="js.lib.PromiseHandler.T"/>
	<x path="js.lib.Thenable"><c path="js.lib.PromiseHandler.TOut"/></x>
</f></icast>
			<icast><f a="">
	<c path="js.lib.PromiseHandler.T"/>
	<c path="js.lib.PromiseHandler.TOut"/>
</f></icast>
		</from>
		<this><f a="">
	<c path="js.lib.PromiseHandler.T"/>
	<d/>
</f></this>
		<haxe_doc>Handler type for the Promise object.</haxe_doc>
		<impl><class path="js.lib._Promise.PromiseHandler_Impl_" params="" file="/home/runner/haxe/versions/737af26/std/js/lib/Promise.hx" private="1" module="js.lib.Promise" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="js.lib.Thenable" params="T" file="/home/runner/haxe/versions/737af26/std/js/lib/Promise.hx" module="js.lib.Promise">
		<from><icast><t path="js.lib.ThenableStruct"><c path="js.lib.Thenable.T"/></t></icast></from>
		<this><t path="js.lib.ThenableStruct"><c path="js.lib.Thenable.T"/></t></this>
		<haxe_doc>A value with a `then` method.</haxe_doc>
		<meta>
			<m n=":forward"/>
			<m n=":transitive"/>
		</meta>
		<impl><class path="js.lib._Promise.Thenable_Impl_" params="" file="/home/runner/haxe/versions/737af26/std/js/lib/Promise.hx" private="1" module="js.lib.Promise" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<typedef path="js.lib.ThenableStruct" params="T" file="/home/runner/haxe/versions/737af26/std/js/lib/Promise.hx" module="js.lib.Promise"><a><then params="TOut" set="method"><f a="onFulfilled:?onRejected">
	<x path="Null"><x path="js.lib.PromiseHandler">
	<c path="js.lib.ThenableStruct.T"/>
	<c path="then.TOut"/>
</x></x>
	<x path="js.lib.PromiseHandler">
		<d/>
		<c path="then.TOut"/>
	</x>
	<x path="js.lib.Thenable"><c path="then.TOut"/></x>
</f></then></a></typedef>
	<typedef path="js.lib.PromiseSettleOutcome" params="T" file="/home/runner/haxe/versions/737af26/std/js/lib/Promise.hx" module="js.lib.Promise"><a>
	<value>
		<x path="Null"><c path="js.lib.PromiseSettleOutcome.T"/></x>
		<meta><m n=":optional"/></meta>
	</value>
	<status><x path="js.lib.PromiseSettleStatus"/></status>
	<reason>
		<x path="Null"><d/></x>
		<meta><m n=":optional"/></meta>
	</reason>
</a></typedef>
	<abstract path="js.lib.PromiseSettleStatus" params="" file="/home/runner/haxe/versions/737af26/std/js/lib/Promise.hx" module="js.lib.Promise">
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.lib._Promise.PromiseSettleStatus_Impl_" params="" file="/home/runner/haxe/versions/737af26/std/js/lib/Promise.hx" private="1" module="js.lib.Promise" final="1"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.lib.RegExpMatch" params="" file="/home/runner/haxe/versions/737af26/std/js/lib/RegExp.hx" module="js.lib.RegExp" extern="1">
		<extends path="Array"><c path="String"/></extends>
		<index public="1">
			<x path="Int"/>
			<haxe_doc>The index of the search at which the result was found.</haxe_doc>
		</index>
		<input public="1">
			<c path="String"/>
			<haxe_doc>A copy of the search string.</haxe_doc>
		</input>
		<groups public="1">
			<x path="Null"><x path="haxe.DynamicAccess"><c path="String"/></x></x>
			<haxe_doc>Named capturing groups or undefined if no named capturing groups were defined.
		See [Groups and Ranges](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Groups_and_Ranges) for more information.

		Note: Not all browsers support this feature; refer to the [compatibility table](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Browser_compatibility).</haxe_doc>
		</groups>
		<haxe_doc>A return value of the `RegExp.exec` method.</haxe_doc>
	</class>
	<class path="js.lib.Symbol" params="" file="/home/runner/haxe/versions/737af26/std/js/lib/Symbol.hx" extern="1">
		<for_ public="1" set="method" static="1">
			<f a="key">
				<c path="String"/>
				<c path="js.lib.Symbol"/>
			</f>
			<meta><m n=":native"><e>"for"</e></m></meta>
			<haxe_doc>Searches for existing symbols with the given key and returns it if found.
		Otherwise a new symbol gets created in the global symbol registry with this key.</haxe_doc>
		</for_>
		<keyFor public="1" set="method" static="1">
			<f a="sym">
				<c path="js.lib.Symbol"/>
				<x path="Null"><c path="String"/></x>
			</f>
			<haxe_doc>Retrieves a shared symbol key from the global symbol registry for the given symbol.</haxe_doc>
		</keyFor>
		<iterator public="1" set="null" static="1">
			<c path="js.lib.Symbol"/>
			<haxe_doc>A method returning the default iterator for an object.</haxe_doc>
		</iterator>
		<asyncIterator public="1" set="null" static="1">
			<c path="js.lib.Symbol"/>
			<haxe_doc>A method that returns the default AsyncIterator for an object.</haxe_doc>
		</asyncIterator>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string containing the description of the Symbol.</haxe_doc>
		</toString>
		<ofObject public="1" params="T" get="inline" set="null" line="67">
			<f a="object">
				<a/>
				<x path="Null"><c path="ofObject.T"/></x>
			</f>
			<haxe_doc>Retrieve symbol from a given `object`.

		NOTE: This is a Haxe-specific method that generates an `object[symbol]` expression.</haxe_doc>
		</ofObject>
		<new public="1" set="method">
			<f a="?description">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":selfCall"/></meta>
			<haxe_doc>To create a new primitive symbol, use `new Symbol()` with an optional string as its `description`.

		NOTE: Unlike in plain JavaScript, `new Symbol()` syntax is used in Haxe. This generates a `Symbol(...)`
		expression as required by the JavaScript specification.</haxe_doc>
		</new>
		<meta><m n=":native"><e>"Symbol"</e></m></meta>
	</class>
	<abstract path="jsonrpc.CancellationToken" params="" file="/home/runner/haxe/haxe_libraries/vscode-json-rpc/0.0.1/github/1fbfeabd42d4b3fb8d86214cb2943e738bfee5bd/src/jsonrpc/CancellationToken.hx">
		<this><c path="jsonrpc._CancellationToken.CancellationTokenImpl"/></this>
		<impl><class path="jsonrpc._CancellationToken.CancellationToken_Impl_" params="" file="/home/runner/haxe/haxe_libraries/vscode-json-rpc/0.0.1/github/1fbfeabd42d4b3fb8d86214cb2943e738bfee5bd/src/jsonrpc/CancellationToken.hx" private="1" module="jsonrpc.CancellationToken" final="1">
	<canceled public="1" get="accessor" set="null" static="1"><x path="Bool"/></canceled>
	<get_canceled get="inline" set="null" line="7" static="1"><f a="this">
	<c path="jsonrpc._CancellationToken.CancellationTokenImpl"/>
	<x path="Bool"/>
</f></get_canceled>
	<setCallback public="1" get="inline" set="null" line="10" static="1"><f a="this:cb">
	<c path="jsonrpc._CancellationToken.CancellationTokenImpl"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></setCallback>
</class></impl>
	</abstract>
	<class path="jsonrpc._CancellationToken.CancellationToken_Impl_" params="" file="/home/runner/haxe/haxe_libraries/vscode-json-rpc/0.0.1/github/1fbfeabd42d4b3fb8d86214cb2943e738bfee5bd/src/jsonrpc/CancellationToken.hx" private="1" module="jsonrpc.CancellationToken" final="1">
		<canceled public="1" get="accessor" set="null" static="1"><x path="Bool"/></canceled>
		<get_canceled get="inline" set="null" line="7" static="1"><f a="this">
	<c path="jsonrpc._CancellationToken.CancellationTokenImpl"/>
	<x path="Bool"/>
</f></get_canceled>
		<setCallback public="1" get="inline" set="null" line="10" static="1"><f a="this:cb">
	<c path="jsonrpc._CancellationToken.CancellationTokenImpl"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></setCallback>
	</class>
	<abstract path="jsonrpc.CancellationTokenSource" params="" file="/home/runner/haxe/haxe_libraries/vscode-json-rpc/0.0.1/github/1fbfeabd42d4b3fb8d86214cb2943e738bfee5bd/src/jsonrpc/CancellationToken.hx" module="jsonrpc.CancellationToken">
		<this><c path="jsonrpc._CancellationToken.CancellationTokenImpl"/></this>
		<impl><class path="jsonrpc._CancellationToken.CancellationTokenSource_Impl_" params="" file="/home/runner/haxe/haxe_libraries/vscode-json-rpc/0.0.1/github/1fbfeabd42d4b3fb8d86214cb2943e738bfee5bd/src/jsonrpc/CancellationToken.hx" private="1" module="jsonrpc.CancellationToken" final="1">
	<token public="1" get="accessor" set="null" static="1"><x path="jsonrpc.CancellationToken"/></token>
	<get_token get="inline" set="null" line="17" static="1"><f a="this">
	<c path="jsonrpc._CancellationToken.CancellationTokenImpl"/>
	<x path="jsonrpc.CancellationToken"/>
</f></get_token>
	<_new public="1" get="inline" set="null" line="19" static="1">
		<f a=""><x path="jsonrpc.CancellationTokenSource"/></f>
		<meta><m n=":noCompletion"/></meta>
	</_new>
	<cancel public="1" get="inline" set="null" line="23" static="1"><f a="this">
	<c path="jsonrpc._CancellationToken.CancellationTokenImpl"/>
	<x path="Void"/>
</f></cancel>
</class></impl>
	</abstract>
	<class path="jsonrpc._CancellationToken.CancellationTokenSource_Impl_" params="" file="/home/runner/haxe/haxe_libraries/vscode-json-rpc/0.0.1/github/1fbfeabd42d4b3fb8d86214cb2943e738bfee5bd/src/jsonrpc/CancellationToken.hx" private="1" module="jsonrpc.CancellationToken" final="1">
		<token public="1" get="accessor" set="null" static="1"><x path="jsonrpc.CancellationToken"/></token>
		<get_token get="inline" set="null" line="17" static="1"><f a="this">
	<c path="jsonrpc._CancellationToken.CancellationTokenImpl"/>
	<x path="jsonrpc.CancellationToken"/>
</f></get_token>
		<_new public="1" get="inline" set="null" line="19" static="1">
			<f a=""><x path="jsonrpc.CancellationTokenSource"/></f>
			<meta><m n=":noCompletion"/></meta>
		</_new>
		<cancel public="1" get="inline" set="null" line="23" static="1"><f a="this">
	<c path="jsonrpc._CancellationToken.CancellationTokenImpl"/>
	<x path="Void"/>
</f></cancel>
	</class>
	<class path="jsonrpc._CancellationToken.CancellationTokenImpl" params="" file="/home/runner/haxe/haxe_libraries/vscode-json-rpc/0.0.1/github/1fbfeabd42d4b3fb8d86214cb2943e738bfee5bd/src/jsonrpc/CancellationToken.hx" private="1" module="jsonrpc.CancellationToken">
		<canceled public="1" set="null"><x path="Bool"/></canceled>
		<callback public="1"><f a=""><x path="Void"/></f></callback>
		<cancel public="1" get="inline" set="null" line="34"><f a=""><x path="Void"/></f></cancel>
		<new public="1" get="inline" set="null" line="30"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="jsonrpc.ErrorUtils" params="" file="/home/runner/haxe/haxe_libraries/vscode-json-rpc/0.0.1/github/1fbfeabd42d4b3fb8d86214cb2943e738bfee5bd/src/jsonrpc/ErrorUtils.hx">
		<errorToString public="1" set="method" line="4" static="1"><f a="error:intro">
	<d/>
	<c path="String"/>
	<c path="String"/>
</f></errorToString>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="jsonrpc.CancelParams" params="" file="/home/runner/haxe/haxe_libraries/vscode-json-rpc/0.0.1/github/1fbfeabd42d4b3fb8d86214cb2943e738bfee5bd/src/jsonrpc/Protocol.hx" module="jsonrpc.Protocol"><a><id>
	<x path="haxe.extern.EitherType">
		<x path="Int"/>
		<c path="String"/>
	</x>
	<haxe_doc>The request id to cancel.</haxe_doc>
</id></a></typedef>
	<class path="jsonrpc.CancelNotification" params="" file="/home/runner/haxe/haxe_libraries/vscode-json-rpc/0.0.1/github/1fbfeabd42d4b3fb8d86214cb2943e738bfee5bd/src/jsonrpc/Protocol.hx" module="jsonrpc.Protocol"><type final="1" public="1" get="inline" set="null" expr="new NotificationType&lt;CancelParams&gt;(&quot;$/cancelRequest&quot;)" line="16" static="1">
	<x path="jsonrpc.NotificationType"><t path="jsonrpc.CancelParams"/></x>
	<meta><m n=":value"><e><![CDATA[new NotificationType<CancelParams>("$/cancelRequest")]]></e></m></meta>
</type></class>
	<typedef path="jsonrpc.ProgressToken" params="" file="/home/runner/haxe/haxe_libraries/vscode-json-rpc/0.0.1/github/1fbfeabd42d4b3fb8d86214cb2943e738bfee5bd/src/jsonrpc/Protocol.hx" module="jsonrpc.Protocol"><x path="haxe.extern.EitherType">
	<x path="Int"/>
	<c path="String"/>
</x></typedef>
	<typedef path="jsonrpc.ProgressParams" params="T" file="/home/runner/haxe/haxe_libraries/vscode-json-rpc/0.0.1/github/1fbfeabd42d4b3fb8d86214cb2943e738bfee5bd/src/jsonrpc/Protocol.hx" module="jsonrpc.Protocol"><a>
	<value>
		<c path="jsonrpc.ProgressParams.T"/>
		<haxe_doc>The progress data.</haxe_doc>
	</value>
	<token>
		<t path="jsonrpc.ProgressToken"/>
		<haxe_doc>The progress token provided by the client.</haxe_doc>
	</token>
</a></typedef>
	<class path="jsonrpc.ProgressNotification" params="" file="/home/runner/haxe/haxe_libraries/vscode-json-rpc/0.0.1/github/1fbfeabd42d4b3fb8d86214cb2943e738bfee5bd/src/jsonrpc/Protocol.hx" module="jsonrpc.Protocol"><type final="1" public="1" get="inline" set="null" expr="new NotificationType&lt;ProgressParams&lt;Any&gt;&gt;(&quot;$/progress&quot;)" line="34" static="1">
	<x path="jsonrpc.NotificationType"><t path="jsonrpc.ProgressParams"><x path="Any"/></t></x>
	<meta><m n=":value"><e><![CDATA[new NotificationType<ProgressParams<Any>>("$/progress")]]></e></m></meta>
</type></class>
	<class path="jsonrpc.ProgressType" params="P" file="/home/runner/haxe/haxe_libraries/vscode-json-rpc/0.0.1/github/1fbfeabd42d4b3fb8d86214cb2943e738bfee5bd/src/jsonrpc/Protocol.hx" module="jsonrpc.Protocol">
		<new public="1" set="method" line="38"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="jsonrpc.RequestHandler" params="P:R:E" file="/home/runner/haxe/haxe_libraries/vscode-json-rpc/0.0.1/github/1fbfeabd42d4b3fb8d86214cb2943e738bfee5bd/src/jsonrpc/Protocol.hx" module="jsonrpc.Protocol"><f a="params:token:resolve:reject">
	<c path="jsonrpc.RequestHandler.P"/>
	<x path="jsonrpc.CancellationToken"/>
	<f a="response">
		<c path="jsonrpc.RequestHandler.R"/>
		<x path="Void"/>
	</f>
	<f a="error">
		<x path="jsonrpc.ResponseError"><c path="jsonrpc.RequestHandler.E"/></x>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></typedef>
	<typedef path="jsonrpc.NotificationHandler" params="P" file="/home/runner/haxe/haxe_libraries/vscode-json-rpc/0.0.1/github/1fbfeabd42d4b3fb8d86214cb2943e738bfee5bd/src/jsonrpc/Protocol.hx" module="jsonrpc.Protocol"><f a="params">
	<c path="jsonrpc.NotificationHandler.P"/>
	<x path="Void"/>
</f></typedef>
	<typedef path="jsonrpc.Disposable" params="" file="/home/runner/haxe/haxe_libraries/vscode-json-rpc/0.0.1/github/1fbfeabd42d4b3fb8d86214cb2943e738bfee5bd/src/jsonrpc/Protocol.hx" module="jsonrpc.Protocol"><a><dispose set="method">
	<f a=""><x path="Void"/></f>
	<haxe_doc>Dispose this object.</haxe_doc>
</dispose></a></typedef>
	<class path="jsonrpc.Protocol" params="" file="/home/runner/haxe/haxe_libraries/vscode-json-rpc/0.0.1/github/1fbfeabd42d4b3fb8d86214cb2943e738bfee5bd/src/jsonrpc/Protocol.hx">
		<PROTOCOL_VERSION public="1" get="inline" set="null" expr="&quot;2.0&quot;" line="55" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"2.0"</e></m></meta>
		</PROTOCOL_VERSION>
		<didRespondToRequest public="1"><x path="Null"><f a="request:response">
	<t path="jsonrpc.RequestMessage"/>
	<t path="jsonrpc.ResponseMessage"/>
	<x path="Void"/>
</f></x></didRespondToRequest>
		<didSendNotification public="1"><x path="Null"><f a="notification">
	<t path="jsonrpc.NotificationMessage"/>
	<x path="Void"/>
</f></x></didSendNotification>
		<writeMessage><f a="message:token">
	<t path="jsonrpc.Message"/>
	<x path="Null"><x path="jsonrpc.CancellationToken"/></x>
	<x path="Void"/>
</f></writeMessage>
		<requestTokens><t path="Map">
	<c path="String"/>
	<x path="jsonrpc.CancellationTokenSource"/>
</t></requestTokens>
		<nextRequestId><x path="Int"/></nextRequestId>
		<requestHandlers><t path="Map">
	<c path="String"/>
	<t path="jsonrpc.RequestHandler">
		<d/>
		<d/>
		<d/>
	</t>
</t></requestHandlers>
		<notificationHandlers><t path="Map">
	<c path="String"/>
	<t path="jsonrpc.NotificationHandler"><d/></t>
</t></notificationHandlers>
		<progressHandlers><t path="Map">
	<a/>
	<t path="jsonrpc.NotificationHandler"><d/></t>
</t></progressHandlers>
		<responseCallbacks><t path="Map">
	<x path="Int"/>
	<c path="jsonrpc._Protocol.ResponseCallbackEntry"/>
</t></responseCallbacks>
		<handleMessage public="1" set="method" line="89"><f a="message">
	<t path="jsonrpc.Message"/>
	<x path="Void"/>
</f></handleMessage>
		<onRequest public="1" params="P:R:E" get="inline" set="null" line="100"><f a="method:handler">
	<x path="jsonrpc.RequestType">
		<c path="onRequest.P"/>
		<c path="onRequest.R"/>
		<c path="onRequest.E"/>
	</x>
	<t path="jsonrpc.RequestHandler">
		<c path="onRequest.P"/>
		<c path="onRequest.R"/>
		<c path="onRequest.E"/>
	</t>
	<x path="Void"/>
</f></onRequest>
		<onNotification public="1" params="P" get="inline" set="null" line="104"><f a="method:handler">
	<x path="jsonrpc.NotificationType"><c path="onNotification.P"/></x>
	<t path="jsonrpc.NotificationHandler"><c path="onNotification.P"/></t>
	<x path="Void"/>
</f></onNotification>
		<onProgress public="1" params="P" set="method" line="108"><f a="type:token:handler">
	<c path="jsonrpc.ProgressType"><c path="onProgress.P"/></c>
	<t path="jsonrpc.ProgressToken"/>
	<t path="jsonrpc.NotificationHandler"><c path="onProgress.P"/></t>
	<t path="jsonrpc.Disposable"/>
</f></onProgress>
		<handleRequest set="method" line="120"><f a="request">
	<t path="jsonrpc.RequestMessage"/>
	<x path="Void"/>
</f></handleRequest>
		<handleNotification set="method" line="167"><f a="notification">
	<t path="jsonrpc.NotificationMessage"/>
	<x path="Void"/>
</f></handleNotification>
		<handleResponse set="method" line="187"><f a="response">
	<t path="jsonrpc.ResponseMessage"/>
	<x path="Void"/>
</f></handleResponse>
		<sendNotification public="1" params="P" get="inline" set="null" line="211"><f a="name:?params">
	<x path="jsonrpc.NotificationType"><c path="sendNotification.P"/></x>
	<c path="sendNotification.P"/>
	<x path="Void"/>
</f></sendNotification>
		<sendProgress public="1" params="P" get="inline" set="null" line="225"><f a="type:token:value">
	<c path="jsonrpc.ProgressType"><c path="sendProgress.P"/></c>
	<t path="jsonrpc.ProgressToken"/>
	<c path="sendProgress.P"/>
	<x path="Void"/>
</f></sendProgress>
		<sendRequest public="1" params="P:R:E" set="method" line="230"><f a="method:params:?token:?resolve:?reject">
	<x path="jsonrpc.RequestType">
		<c path="sendRequest.P"/>
		<c path="sendRequest.R"/>
		<c path="sendRequest.E"/>
	</x>
	<c path="sendRequest.P"/>
	<x path="jsonrpc.CancellationToken"/>
	<f a="result">
		<c path="sendRequest.R"/>
		<x path="Void"/>
	</f>
	<f a="error">
		<c path="sendRequest.E"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></sendRequest>
		<logError public="1" set="dynamic" line="245"><f a="message">
	<c path="String"/>
	<x path="Void"/>
</f></logError>
		<new public="1" set="method" line="70"><f a="writeMessage">
	<f a="message:token">
		<t path="jsonrpc.Message"/>
		<x path="Null"><x path="jsonrpc.CancellationToken"/></x>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></new>
		<haxe_doc>A simple JSON-RPC protocol base class.</haxe_doc>
	</class>
	<class path="jsonrpc._Protocol.ResponseCallbackEntry" params="" file="/home/runner/haxe/haxe_libraries/vscode-json-rpc/0.0.1/github/1fbfeabd42d4b3fb8d86214cb2943e738bfee5bd/src/jsonrpc/Protocol.hx" private="1" module="jsonrpc.Protocol">
		<method public="1"><c path="String"/></method>
		<resolve public="1"><x path="Null"><f a="">
	<d/>
	<x path="Void"/>
</f></x></resolve>
		<reject public="1"><x path="Null"><f a="">
	<d/>
	<x path="Void"/>
</f></x></reject>
		<new public="1" set="method" line="253"><f a="method:resolve:reject">
	<c path="String"/>
	<x path="Null"><f a="">
	<d/>
	<x path="Void"/>
</f></x>
	<x path="Null"><f a="">
	<d/>
	<x path="Void"/>
</f></x>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="jsonrpc.ResponseError" params="T" file="/home/runner/haxe/haxe_libraries/vscode-json-rpc/0.0.1/github/1fbfeabd42d4b3fb8d86214cb2943e738bfee5bd/src/jsonrpc/ResponseError.hx">
		<this><t path="jsonrpc.ResponseErrorData"/></this>
		<to><icast><t path="jsonrpc.ResponseErrorData"/></icast></to>
		<impl><class path="jsonrpc._ResponseError.ResponseError_Impl_" params="" file="/home/runner/haxe/haxe_libraries/vscode-json-rpc/0.0.1/github/1fbfeabd42d4b3fb8d86214cb2943e738bfee5bd/src/jsonrpc/ResponseError.hx" private="1" module="jsonrpc.ResponseError" final="1">
	<ParseError public="1" get="inline" set="null" expr="-32700" line="10" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>-32700</e></m></meta>
		<haxe_doc>Invalid JSON was received by the server.
		An error occurred on the server while parsing the JSON text.</haxe_doc>
	</ParseError>
	<InvalidRequest public="1" get="inline" set="null" expr="-32600" line="15" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>-32600</e></m></meta>
		<haxe_doc>The JSON sent is not a valid Request object.</haxe_doc>
	</InvalidRequest>
	<MethodNotFound public="1" get="inline" set="null" expr="-32601" line="20" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>-32601</e></m></meta>
		<haxe_doc>The method does not exist / is not available.</haxe_doc>
	</MethodNotFound>
	<InvalidParams public="1" get="inline" set="null" expr="-32602" line="25" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>-32602</e></m></meta>
		<haxe_doc>Invalid method parameter(s).</haxe_doc>
	</InvalidParams>
	<InternalError public="1" get="inline" set="null" expr="-32603" line="30" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>-32603</e></m></meta>
		<haxe_doc>Internal JSON-RPC error.</haxe_doc>
	</InternalError>
	<ServerNotInitialized public="1" get="inline" set="null" expr="-32002" line="31" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>-32002</e></m></meta>
	</ServerNotInitialized>
	<UnknownErrorCode public="1" get="inline" set="null" expr="-32001" line="32" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>-32001</e></m></meta>
	</UnknownErrorCode>
	<_new public="1" get="inline" set="null" line="34" static="1">
		<f a="code:message:?data">
			<x path="Int"/>
			<c path="String"/>
			<d/>
			<x path="jsonrpc.ResponseError"><c path="jsonrpc.ResponseError.T"/></x>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</_new>
	<internalError public="1" get="inline" set="null" line="40" static="1"><f a="message">
	<c path="String"/>
	<x path="jsonrpc.ResponseError"><e path="jsonrpc.NoData"/></x>
</f></internalError>
</class></impl>
	</abstract>
	<class path="jsonrpc._ResponseError.ResponseError_Impl_" params="" file="/home/runner/haxe/haxe_libraries/vscode-json-rpc/0.0.1/github/1fbfeabd42d4b3fb8d86214cb2943e738bfee5bd/src/jsonrpc/ResponseError.hx" private="1" module="jsonrpc.ResponseError" final="1">
		<ParseError public="1" get="inline" set="null" expr="-32700" line="10" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-32700</e></m></meta>
			<haxe_doc>Invalid JSON was received by the server.
		An error occurred on the server while parsing the JSON text.</haxe_doc>
		</ParseError>
		<InvalidRequest public="1" get="inline" set="null" expr="-32600" line="15" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-32600</e></m></meta>
			<haxe_doc>The JSON sent is not a valid Request object.</haxe_doc>
		</InvalidRequest>
		<MethodNotFound public="1" get="inline" set="null" expr="-32601" line="20" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-32601</e></m></meta>
			<haxe_doc>The method does not exist / is not available.</haxe_doc>
		</MethodNotFound>
		<InvalidParams public="1" get="inline" set="null" expr="-32602" line="25" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-32602</e></m></meta>
			<haxe_doc>Invalid method parameter(s).</haxe_doc>
		</InvalidParams>
		<InternalError public="1" get="inline" set="null" expr="-32603" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-32603</e></m></meta>
			<haxe_doc>Internal JSON-RPC error.</haxe_doc>
		</InternalError>
		<ServerNotInitialized public="1" get="inline" set="null" expr="-32002" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-32002</e></m></meta>
		</ServerNotInitialized>
		<UnknownErrorCode public="1" get="inline" set="null" expr="-32001" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-32001</e></m></meta>
		</UnknownErrorCode>
		<_new public="1" get="inline" set="null" line="34" static="1">
			<f a="code:message:?data">
				<x path="Int"/>
				<c path="String"/>
				<d/>
				<x path="jsonrpc.ResponseError"><c path="jsonrpc.ResponseError.T"/></x>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_new>
		<internalError public="1" get="inline" set="null" line="40" static="1"><f a="message">
	<c path="String"/>
	<x path="jsonrpc.ResponseError"><e path="jsonrpc.NoData"/></x>
</f></internalError>
	</class>
	<typedef path="jsonrpc.Message" params="" file="/home/runner/haxe/haxe_libraries/vscode-json-rpc/0.0.1/github/1fbfeabd42d4b3fb8d86214cb2943e738bfee5bd/src/jsonrpc/Types.hx" module="jsonrpc.Types">
		<a><jsonrpc>
	<c path="String"/>
	<haxe_doc>JSON-RPC version (2.0).</haxe_doc>
</jsonrpc></a>
		<haxe_doc>A general message as defined by JSON-RPC.</haxe_doc>
	</typedef>
	<typedef path="jsonrpc.RequestId" params="" file="/home/runner/haxe/haxe_libraries/vscode-json-rpc/0.0.1/github/1fbfeabd42d4b3fb8d86214cb2943e738bfee5bd/src/jsonrpc/Types.hx" module="jsonrpc.Types"><x path="haxe.extern.EitherType">
	<x path="Int"/>
	<c path="String"/>
</x></typedef>
	<typedef path="jsonrpc.RequestMessage" params="" file="/home/runner/haxe/haxe_libraries/vscode-json-rpc/0.0.1/github/1fbfeabd42d4b3fb8d86214cb2943e738bfee5bd/src/jsonrpc/Types.hx" module="jsonrpc.Types">
		<a>
			<params>
				<x path="Null"><d/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The method's params.</haxe_doc>
			</params>
			<method>
				<c path="String"/>
				<haxe_doc>The method to be invoked.</haxe_doc>
			</method>
			<jsonrpc>
				<c path="String"/>
				<haxe_doc>JSON-RPC version (2.0).</haxe_doc>
			</jsonrpc>
			<id>
				<t path="jsonrpc.RequestId"/>
				<haxe_doc>The request id.</haxe_doc>
			</id>
		</a>
		<haxe_doc>A request message to decribe a request between the client and the server.
	Every processed request must send a response back to the sender of the request.</haxe_doc>
	</typedef>
	<typedef path="jsonrpc.ResponseMessage" params="" file="/home/runner/haxe/haxe_libraries/vscode-json-rpc/0.0.1/github/1fbfeabd42d4b3fb8d86214cb2943e738bfee5bd/src/jsonrpc/Types.hx" module="jsonrpc.Types">
		<a>
			<result>
				<x path="Null"><d/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The result of a request. This member is REQUIRED on success.
		This member MUST NOT exist if there was an error invoking the method.</haxe_doc>
			</result>
			<jsonrpc>
				<c path="String"/>
				<haxe_doc>JSON-RPC version (2.0).</haxe_doc>
			</jsonrpc>
			<id>
				<x path="Null"><t path="jsonrpc.RequestId"/></x>
				<haxe_doc>The request id.</haxe_doc>
			</id>
			<error>
				<x path="Null"><t path="jsonrpc.ResponseErrorData"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The error object in case a request fails.</haxe_doc>
			</error>
		</a>
		<haxe_doc>Response Message send as a result of a request. If a request doesn't provide a result value the receiver of a request still needs
	to return a response message to conform to the JSON RPC specification. The result property of the ResponseMessage should be set to
	`null` in this case to signal a successful request.</haxe_doc>
	</typedef>
	<typedef path="jsonrpc.ResponseErrorData" params="" file="/home/runner/haxe/haxe_libraries/vscode-json-rpc/0.0.1/github/1fbfeabd42d4b3fb8d86214cb2943e738bfee5bd/src/jsonrpc/Types.hx" module="jsonrpc.Types">
		<a>
			<message>
				<c path="String"/>
				<haxe_doc>A string providing a short decription of the error.</haxe_doc>
			</message>
			<data>
				<x path="Null"><d/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>A Primitive or Structured value that contains additional information about the error.</haxe_doc>
			</data>
			<code>
				<x path="Int"/>
				<haxe_doc>A number indicating the error type that occured.</haxe_doc>
			</code>
		</a>
		<haxe_doc>Error object sent in the `ResponseMessage.error` field.</haxe_doc>
	</typedef>
	<typedef path="jsonrpc.NotificationMessage" params="" file="/home/runner/haxe/haxe_libraries/vscode-json-rpc/0.0.1/github/1fbfeabd42d4b3fb8d86214cb2943e738bfee5bd/src/jsonrpc/Types.hx" module="jsonrpc.Types">
		<a>
			<params>
				<x path="Null"><d/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The notification's params.</haxe_doc>
			</params>
			<method>
				<c path="String"/>
				<haxe_doc>The method to be invoked.</haxe_doc>
			</method>
			<jsonrpc>
				<c path="String"/>
				<haxe_doc>JSON-RPC version (2.0).</haxe_doc>
			</jsonrpc>
		</a>
		<haxe_doc>A notification message. A processed notification message must not send a response back.
	They work like events.</haxe_doc>
	</typedef>
	<abstract path="jsonrpc.RequestType" params="TParams:TResponse:TError" file="/home/runner/haxe/haxe_libraries/vscode-json-rpc/0.0.1/github/1fbfeabd42d4b3fb8d86214cb2943e738bfee5bd/src/jsonrpc/Types.hx" module="jsonrpc.Types">
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<impl><class path="jsonrpc._Types.RequestType_Impl_" params="" file="/home/runner/haxe/haxe_libraries/vscode-json-rpc/0.0.1/github/1fbfeabd42d4b3fb8d86214cb2943e738bfee5bd/src/jsonrpc/Types.hx" private="1" module="jsonrpc.Types" final="1"><_new public="1" get="inline" set="null" line="102" static="1">
	<f a="method">
		<c path="String"/>
		<x path="jsonrpc.RequestType">
			<c path="jsonrpc.RequestType.TParams"/>
			<c path="jsonrpc.RequestType.TResponse"/>
			<c path="jsonrpc.RequestType.TError"/>
		</x>
	</f>
	<meta><m n=":noCompletion"/></meta>
</_new></class></impl>
	</abstract>
	<class path="jsonrpc._Types.RequestType_Impl_" params="" file="/home/runner/haxe/haxe_libraries/vscode-json-rpc/0.0.1/github/1fbfeabd42d4b3fb8d86214cb2943e738bfee5bd/src/jsonrpc/Types.hx" private="1" module="jsonrpc.Types" final="1"><_new public="1" get="inline" set="null" line="102" static="1">
	<f a="method">
		<c path="String"/>
		<x path="jsonrpc.RequestType">
			<c path="jsonrpc.RequestType.TParams"/>
			<c path="jsonrpc.RequestType.TResponse"/>
			<c path="jsonrpc.RequestType.TError"/>
		</x>
	</f>
	<meta><m n=":noCompletion"/></meta>
</_new></class>
	<abstract path="jsonrpc.NotificationType" params="TParams" file="/home/runner/haxe/haxe_libraries/vscode-json-rpc/0.0.1/github/1fbfeabd42d4b3fb8d86214cb2943e738bfee5bd/src/jsonrpc/Types.hx" module="jsonrpc.Types">
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<impl><class path="jsonrpc._Types.NotificationType_Impl_" params="" file="/home/runner/haxe/haxe_libraries/vscode-json-rpc/0.0.1/github/1fbfeabd42d4b3fb8d86214cb2943e738bfee5bd/src/jsonrpc/Types.hx" private="1" module="jsonrpc.Types" final="1"><_new public="1" get="inline" set="null" line="107" static="1">
	<f a="method">
		<c path="String"/>
		<x path="jsonrpc.NotificationType"><c path="jsonrpc.NotificationType.TParams"/></x>
	</f>
	<meta><m n=":noCompletion"/></meta>
</_new></class></impl>
	</abstract>
	<class path="jsonrpc._Types.NotificationType_Impl_" params="" file="/home/runner/haxe/haxe_libraries/vscode-json-rpc/0.0.1/github/1fbfeabd42d4b3fb8d86214cb2943e738bfee5bd/src/jsonrpc/Types.hx" private="1" module="jsonrpc.Types" final="1"><_new public="1" get="inline" set="null" line="107" static="1">
	<f a="method">
		<c path="String"/>
		<x path="jsonrpc.NotificationType"><c path="jsonrpc.NotificationType.TParams"/></x>
	</f>
	<meta><m n=":noCompletion"/></meta>
</_new></class>
	<enum path="jsonrpc.NoData" params="" file="/home/runner/haxe/haxe_libraries/vscode-json-rpc/0.0.1/github/1fbfeabd42d4b3fb8d86214cb2943e738bfee5bd/src/jsonrpc/Types.hx" module="jsonrpc.Types"><meta><m n=":flatEnum"/></meta></enum>
	<abstract path="languageServerProtocol.URI" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<this><c path="String"/></this>
		<haxe_doc>A tagging type for string properties that are actually URIs

	@since 3.16.0 - Proposed state</haxe_doc>
		<impl><class path="languageServerProtocol._Types.URI_Impl_" params="" file="src/languageServerProtocol/Types.hx" private="1" module="languageServerProtocol.Types" final="1">
	<_new public="1" get="inline" set="null" line="9" static="1">
		<f a="uri">
			<c path="String"/>
			<x path="languageServerProtocol.URI"/>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</_new>
	<toString public="1" get="inline" set="null" line="13" static="1"><f a="this">
	<c path="String"/>
	<c path="String"/>
</f></toString>
</class></impl>
	</abstract>
	<class path="languageServerProtocol._Types.URI_Impl_" params="" file="src/languageServerProtocol/Types.hx" private="1" module="languageServerProtocol.Types" final="1">
		<_new public="1" get="inline" set="null" line="9" static="1">
			<f a="uri">
				<c path="String"/>
				<x path="languageServerProtocol.URI"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_new>
		<toString public="1" get="inline" set="null" line="13" static="1"><f a="this">
	<c path="String"/>
	<c path="String"/>
</f></toString>
	</class>
	<typedef path="languageServerProtocol.LSPAny" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<d/>
		<haxe_doc>The LSP any type.

	Please note that strictly speaking a property with the value `undefined`
	can't be converted into JSON preserving the property name. However for
	convenience it is allowed and assumed that all these properties are
	optional as well.

	@since 3.17.0</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.LSPObject" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<x path="haxe.DynamicAccess"><c path="Array"><t path="languageServerProtocol.LSPAny"/></c></x>
		<haxe_doc>LSP object definition.

	@since 3.17.0</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.LSPArray" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<c path="Array"><t path="languageServerProtocol.LSPAny"/></c>
		<haxe_doc>LSP arrays.

	@since 3.17.0</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.Location" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<uri><x path="languageServerProtocol.textdocument.DocumentUri"/></uri>
			<range><t path="languageServerProtocol.textdocument.Range"/></range>
		</a>
		<haxe_doc>Represents a location inside a resource, such as a line inside a text file.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.LocationLink" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<targetUri>
				<x path="languageServerProtocol.textdocument.DocumentUri"/>
				<haxe_doc>The target resource identifier of this link.</haxe_doc>
			</targetUri>
			<targetSelectionRange>
				<t path="languageServerProtocol.textdocument.Range"/>
				<haxe_doc>The range that should be selected and revealed when this link is being followed, e.g the name of a function.
		Must be contained by the the `targetRange`. See also `DocumentSymbol#range`</haxe_doc>
			</targetSelectionRange>
			<targetRange>
				<t path="languageServerProtocol.textdocument.Range"/>
				<haxe_doc>The full target range of this link. If the target for example is a symbol then target range is the
		range enclosing this symbol not including leading/trailing whitespace but everything else
		like comments. This information is typically used to highlight the range in the editor.</haxe_doc>
			</targetRange>
			<originSelectionRange>
				<x path="Null"><t path="languageServerProtocol.textdocument.Range"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Span of the origin of this link.

		Used as the underlined span for mouse definition hover. Defaults to the word range at
		the definition position.</haxe_doc>
			</originSelectionRange>
		</a>
		<haxe_doc>Represents the connection of two locations. Provides additional metadata over normal [locations](#Location),
	including an origin range.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.Color" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<red final="1" set="null">
				<x path="Float"/>
				<haxe_doc>The red component of this color in the range [0-1].</haxe_doc>
			</red>
			<green final="1" set="null">
				<x path="Float"/>
				<haxe_doc>The green component of this color in the range [0-1].</haxe_doc>
			</green>
			<blue final="1" set="null">
				<x path="Float"/>
				<haxe_doc>The blue component of this color in the range [0-1].</haxe_doc>
			</blue>
			<alpha final="1" set="null">
				<x path="Float"/>
				<haxe_doc>The alpha component of this color in the range [0-1].</haxe_doc>
			</alpha>
		</a>
		<haxe_doc>Represents a color in RGBA space.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.ColorInformation" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<range>
				<t path="languageServerProtocol.textdocument.Range"/>
				<haxe_doc>The range in the document where this color appers.</haxe_doc>
			</range>
			<color>
				<t path="languageServerProtocol.Color"/>
				<haxe_doc>The actual color value for this color range.</haxe_doc>
			</color>
		</a>
		<haxe_doc>Represents a color range from a document.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.ColorPresentation" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types"><a>
	<textEdit>
		<x path="Null"><t path="languageServerProtocol.textdocument.TextEdit"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>An edit which is applied to a document when selecting
		this presentation for the color. When `falsy` the `label`
		is used.</haxe_doc>
	</textEdit>
	<label>
		<c path="String"/>
		<haxe_doc>The label of this color presentation. It will be shown on the color
		picker header. By default this is also the text that is inserted when selecting
		this color presentation.</haxe_doc>
	</label>
	<additionalTextEdits>
		<x path="Null"><c path="Array"><t path="languageServerProtocol.textdocument.TextEdit"/></c></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>An optional array of additional text edits that are applied when
		selecting this color presentation. Edits must not overlap with the main `edit` nor with themselves.</haxe_doc>
	</additionalTextEdits>
</a></typedef>
	<abstract path="languageServerProtocol.FoldingRangeKind" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<haxe_doc>A set of predefined range kinds.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="languageServerProtocol._Types.FoldingRangeKind_Impl_" params="" file="src/languageServerProtocol/Types.hx" private="1" module="languageServerProtocol.Types" extern="1" final="1">
	<Comment public="1" get="inline" set="null" expr="cast &quot;comment&quot;" line="153" static="1">
		<x path="languageServerProtocol.FoldingRangeKind"/>
		<meta>
			<m n=":value"><e>cast "comment"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Folding range for a comment</haxe_doc>
	</Comment>
	<Imports public="1" get="inline" set="null" expr="cast &quot;imports&quot;" line="158" static="1">
		<x path="languageServerProtocol.FoldingRangeKind"/>
		<meta>
			<m n=":value"><e>cast "imports"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Folding range for a imports or includes</haxe_doc>
	</Imports>
	<Region public="1" get="inline" set="null" expr="cast &quot;region&quot;" line="163" static="1">
		<x path="languageServerProtocol.FoldingRangeKind"/>
		<meta>
			<m n=":value"><e>cast "region"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Folding range for a region (e.g. `#region`)</haxe_doc>
	</Region>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="languageServerProtocol._Types.FoldingRangeKind_Impl_" params="" file="src/languageServerProtocol/Types.hx" private="1" module="languageServerProtocol.Types" extern="1" final="1">
		<Comment public="1" get="inline" set="null" expr="cast &quot;comment&quot;" line="153" static="1">
			<x path="languageServerProtocol.FoldingRangeKind"/>
			<meta>
				<m n=":value"><e>cast "comment"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Folding range for a comment</haxe_doc>
		</Comment>
		<Imports public="1" get="inline" set="null" expr="cast &quot;imports&quot;" line="158" static="1">
			<x path="languageServerProtocol.FoldingRangeKind"/>
			<meta>
				<m n=":value"><e>cast "imports"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Folding range for a imports or includes</haxe_doc>
		</Imports>
		<Region public="1" get="inline" set="null" expr="cast &quot;region&quot;" line="163" static="1">
			<x path="languageServerProtocol.FoldingRangeKind"/>
			<meta>
				<m n=":value"><e>cast "region"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Folding range for a region (e.g. `#region`)</haxe_doc>
		</Region>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="languageServerProtocol.FoldingRange" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<startLine>
				<x path="Int"/>
				<haxe_doc>The zero-based line number from where the folded range starts.</haxe_doc>
			</startLine>
			<startCharacter>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The zero-based character offset from where the folded range starts. If not defined, defaults to the length of the start line.</haxe_doc>
			</startCharacter>
			<kind>
				<x path="Null"><x path="languageServerProtocol.FoldingRangeKind"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Describes the kind of the folding range such as `comment' or 'region'. The kind
		is used to categorize folding ranges. See [FoldingRangeKind](#FoldingRangeKind)
		for an enumeration of standardized kinds.</haxe_doc>
			</kind>
			<endLine>
				<x path="Int"/>
				<haxe_doc>The zero-based line number where the folded range ends.</haxe_doc>
			</endLine>
			<endCharacter>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The zero-based character offset before the folded range ends. If not defined, defaults to the length of the end line.</haxe_doc>
			</endCharacter>
			<collapsedText>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The text that the client should show when the specified range is
		collapsed. If not defined or not supported by the client, a default
		will be chosen by the client.

		@since 3.17.0
		@proposed</haxe_doc>
			</collapsedText>
		</a>
		<haxe_doc>Represents a folding range.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.DiagnosticRelatedInformation" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<message>
				<c path="String"/>
				<haxe_doc>The message of this related diagnostic information.</haxe_doc>
			</message>
			<location>
				<t path="languageServerProtocol.Location"/>
				<haxe_doc>The location of this related diagnostic information.</haxe_doc>
			</location>
		</a>
		<haxe_doc>Represents a related message and source code location for a diagnostic. This should be
	used to point to code locations that cause or related to a diagnostics, e.g when duplicating
	a symbol in a scope.</haxe_doc>
	</typedef>
	<abstract path="languageServerProtocol.DiagnosticSeverity" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<this><x path="Int"/></this>
		<haxe_doc>The diagnostic's serverity.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="languageServerProtocol._Types.DiagnosticSeverity_Impl_" params="" file="src/languageServerProtocol/Types.hx" private="1" module="languageServerProtocol.Types" extern="1" final="1">
	<Error public="1" get="inline" set="null" expr="cast 1" line="232" static="1">
		<x path="languageServerProtocol.DiagnosticSeverity"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Reports an error.</haxe_doc>
	</Error>
	<Warning public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
		<x path="languageServerProtocol.DiagnosticSeverity"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Reports a warning.</haxe_doc>
	</Warning>
	<Information public="1" get="inline" set="null" expr="cast 3" line="1" static="1">
		<x path="languageServerProtocol.DiagnosticSeverity"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Reports an information.</haxe_doc>
	</Information>
	<Hint public="1" get="inline" set="null" expr="cast 4" line="1" static="1">
		<x path="languageServerProtocol.DiagnosticSeverity"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Reports a hint.</haxe_doc>
	</Hint>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="languageServerProtocol._Types.DiagnosticSeverity_Impl_" params="" file="src/languageServerProtocol/Types.hx" private="1" module="languageServerProtocol.Types" extern="1" final="1">
		<Error public="1" get="inline" set="null" expr="cast 1" line="232" static="1">
			<x path="languageServerProtocol.DiagnosticSeverity"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Reports an error.</haxe_doc>
		</Error>
		<Warning public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
			<x path="languageServerProtocol.DiagnosticSeverity"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Reports a warning.</haxe_doc>
		</Warning>
		<Information public="1" get="inline" set="null" expr="cast 3" line="1" static="1">
			<x path="languageServerProtocol.DiagnosticSeverity"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Reports an information.</haxe_doc>
		</Information>
		<Hint public="1" get="inline" set="null" expr="cast 4" line="1" static="1">
			<x path="languageServerProtocol.DiagnosticSeverity"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Reports a hint.</haxe_doc>
		</Hint>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="languageServerProtocol.DiagnosticTag" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<this><x path="Int"/></this>
		<haxe_doc>The diagnostic tags.

	@since 3.15.0</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="languageServerProtocol._Types.DiagnosticTag_Impl_" params="" file="src/languageServerProtocol/Types.hx" private="1" module="languageServerProtocol.Types" extern="1" final="1">
	<Unnecessary public="1" get="inline" set="null" expr="cast 1" line="262" static="1">
		<x path="languageServerProtocol.DiagnosticTag"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Unused or unnecessary code.

		Clients are allowed to render diagnostics with this tag faded out instead of having
		an error squiggle.</haxe_doc>
	</Unnecessary>
	<Deprecated public="1" get="inline" set="null" expr="cast 2" line="269" static="1">
		<x path="languageServerProtocol.DiagnosticTag"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Deprecated or obsolete code.

		Clients are allowed to rendered diagnostics with this tag strike through.</haxe_doc>
	</Deprecated>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="languageServerProtocol._Types.DiagnosticTag_Impl_" params="" file="src/languageServerProtocol/Types.hx" private="1" module="languageServerProtocol.Types" extern="1" final="1">
		<Unnecessary public="1" get="inline" set="null" expr="cast 1" line="262" static="1">
			<x path="languageServerProtocol.DiagnosticTag"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Unused or unnecessary code.

		Clients are allowed to render diagnostics with this tag faded out instead of having
		an error squiggle.</haxe_doc>
		</Unnecessary>
		<Deprecated public="1" get="inline" set="null" expr="cast 2" line="269" static="1">
			<x path="languageServerProtocol.DiagnosticTag"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Deprecated or obsolete code.

		Clients are allowed to rendered diagnostics with this tag strike through.</haxe_doc>
		</Deprecated>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="languageServerProtocol.CodeDescription" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a><href>
	<x path="languageServerProtocol.URI"/>
	<haxe_doc>An URI to open with more information about the diagnostic error.</haxe_doc>
</href></a>
		<haxe_doc>Structure to capture a description for an error code.

	@since 3.16.0</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.Diagnostic" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<tags>
				<x path="Null"><c path="Array"><x path="languageServerProtocol.DiagnosticTag"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Additional metadata about the diagnostic.

		@since 3.15.0</haxe_doc>
			</tags>
			<source>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>A human-readable string describing the source of this diagnostic, e.g. 'typescript' or 'super lint'.</haxe_doc>
			</source>
			<severity>
				<x path="Null"><x path="languageServerProtocol.DiagnosticSeverity"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The diagnostic's severity.
		If omitted it is up to the client to interpret diagnostics as error, warning, info or hint.</haxe_doc>
			</severity>
			<relatedInformation>
				<x path="Null"><c path="Array"><t path="languageServerProtocol.DiagnosticRelatedInformation"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An array of related diagnostic information, e.g. when symbol-names within
		a scope collide all definitions can be marked via this property.</haxe_doc>
			</relatedInformation>
			<range>
				<t path="languageServerProtocol.textdocument.Range"/>
				<haxe_doc>The range at which the message applies</haxe_doc>
			</range>
			<message>
				<c path="String"/>
				<haxe_doc>The diagnostic's message. It usually appears in the user interface</haxe_doc>
			</message>
			<data>
				<x path="Null"><t path="languageServerProtocol.LSPAny"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>A data entry field that is preserved between a `textDocument/publishDiagnostics`
		notification and `textDocument/codeAction` request.

		@since 3.16.0</haxe_doc>
			</data>
			<codeDescription>
				<x path="Null"><t path="languageServerProtocol.CodeDescription"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional property to describe the error code.
		Requires the code field (above) to be present/not null.

		@since 3.16.0</haxe_doc>
			</codeDescription>
			<code>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Int"/>
	<c path="String"/>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The diagnostic's code, which usually appear in the user interface.</haxe_doc>
			</code>
		</a>
		<haxe_doc>Represents a diagnostic, such as a compiler error or warning.
	Diagnostic objects are only valid in the scope of a resource.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.Command" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<title>
				<c path="String"/>
				<haxe_doc>Title of the command, like `save`.</haxe_doc>
			</title>
			<command>
				<c path="String"/>
				<haxe_doc>The identifier of the actual command handler.</haxe_doc>
			</command>
			<arguments>
				<x path="Null"><c path="Array"><t path="languageServerProtocol.LSPAny"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Arguments that the command handler should be invoked with.</haxe_doc>
			</arguments>
		</a>
		<haxe_doc>Represents a reference to a command.
	Provides a title which will be used to represent a command in the UI and,
	optionally, an array of arguments which will be passed to the command handler function when invoked.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.ChangeAnnotation" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<needsConfirmation>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>A flag which indicates that user confirmation is needed
		before applying the change.</haxe_doc>
			</needsConfirmation>
			<label>
				<c path="String"/>
				<haxe_doc>A human-readable string describing the actual change. The string
		is rendered prominent in the user interface.</haxe_doc>
			</label>
			<description>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>A human-readable string which is rendered less prominent in
		the user interface.</haxe_doc>
			</description>
		</a>
		<haxe_doc>Additional information that describes document changes.

	@since 3.16.0</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.ChangeAnnotationIdentifier" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<c path="String"/>
		<haxe_doc>An identifier to refer to a change annotation stored with a workspace edit.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.AnnotatedTextEdit" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<range>
				<t path="languageServerProtocol.textdocument.Range"/>
				<haxe_doc>The range of the text document to be manipulated. To insert
		text into a document create a range where start === end.</haxe_doc>
			</range>
			<newText>
				<c path="String"/>
				<haxe_doc>The string to be inserted. For delete operations use an
		empty string.</haxe_doc>
			</newText>
			<annotationId>
				<t path="languageServerProtocol.ChangeAnnotationIdentifier"/>
				<haxe_doc>The actual identifier of the change annotation</haxe_doc>
			</annotationId>
		</a>
		<haxe_doc>A special text edit with an additional change annotation.

	@since 3.16.0</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.TextDocumentEdit" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<textDocument>
				<t path="languageServerProtocol.OptionalVersionedTextDocumentIdentifier"/>
				<haxe_doc>The text document to change.</haxe_doc>
			</textDocument>
			<edits>
				<c path="Array"><x path="haxe.extern.EitherType">
	<t path="languageServerProtocol.textdocument.TextEdit"/>
	<t path="languageServerProtocol.AnnotatedTextEdit"/>
</x></c>
				<haxe_doc>The edits to be applied.</haxe_doc>
			</edits>
		</a>
		<haxe_doc>Describes textual changes on a text document. A TextDocumentEdit describes all changes
	on a document version Si and after they are applied move the document to version Si+1.
	So the creator of a TextDocumentEdit doesn't need to sort the array of edits or do any
	kind of ordering. However the edits must be non overlapping.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.ResourceOperation" params="T" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<kind>
				<c path="languageServerProtocol.ResourceOperation.T"/>
				<haxe_doc>The resource operation kind.</haxe_doc>
			</kind>
			<annotationId>
				<x path="Null"><t path="languageServerProtocol.ChangeAnnotationIdentifier"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional annotation identifier describing the operation.

		@since 3.16.0</haxe_doc>
			</annotationId>
		</a>
		<haxe_doc>A generic resource operation.</haxe_doc>
	</typedef>
	<abstract path="languageServerProtocol.CreateFileKind" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="languageServerProtocol._Types.CreateFileKind_Impl_" params="" file="src/languageServerProtocol/Types.hx" private="1" module="languageServerProtocol.Types" extern="1" final="1">
	<Create public="1" get="inline" set="null" expr="cast &quot;create&quot;" line="445" static="1">
		<x path="languageServerProtocol.CreateFileKind"/>
		<meta>
			<m n=":value"><e>cast "create"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Create>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="languageServerProtocol._Types.CreateFileKind_Impl_" params="" file="src/languageServerProtocol/Types.hx" private="1" module="languageServerProtocol.Types" extern="1" final="1">
		<Create public="1" get="inline" set="null" expr="cast &quot;create&quot;" line="445" static="1">
			<x path="languageServerProtocol.CreateFileKind"/>
			<meta>
				<m n=":value"><e>cast "create"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Create>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="languageServerProtocol.CreateFileOptions" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<overwrite>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Overwrite existing file. Overwrite wins over `ignoreIfExists`</haxe_doc>
			</overwrite>
			<ignoreIfExists>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Ignore if exists.</haxe_doc>
			</ignoreIfExists>
		</a>
		<haxe_doc>Options to create a file.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.CreateFile" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<uri>
				<x path="languageServerProtocol.textdocument.DocumentUri"/>
				<haxe_doc>The resource to create.</haxe_doc>
			</uri>
			<options>
				<x path="Null"><t path="languageServerProtocol.CreateFileOptions"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Additional options</haxe_doc>
			</options>
			<kind>
				<x path="languageServerProtocol.CreateFileKind"/>
				<haxe_doc>The resource operation kind.</haxe_doc>
			</kind>
			<annotationId>
				<x path="Null"><t path="languageServerProtocol.ChangeAnnotationIdentifier"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional annotation identifier describing the operation.

		@since 3.16.0</haxe_doc>
			</annotationId>
		</a>
		<haxe_doc>Create file operation.</haxe_doc>
	</typedef>
	<abstract path="languageServerProtocol.RenameFileKind" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="languageServerProtocol._Types.RenameFileKind_Impl_" params="" file="src/languageServerProtocol/Types.hx" private="1" module="languageServerProtocol.Types" extern="1" final="1">
	<Kind public="1" get="inline" set="null" expr="cast &quot;rename&quot;" line="479" static="1">
		<x path="languageServerProtocol.RenameFileKind"/>
		<meta>
			<m n=":value"><e>cast "rename"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Kind>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="languageServerProtocol._Types.RenameFileKind_Impl_" params="" file="src/languageServerProtocol/Types.hx" private="1" module="languageServerProtocol.Types" extern="1" final="1">
		<Kind public="1" get="inline" set="null" expr="cast &quot;rename&quot;" line="479" static="1">
			<x path="languageServerProtocol.RenameFileKind"/>
			<meta>
				<m n=":value"><e>cast "rename"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Kind>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="languageServerProtocol.RenameFileOptions" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<overwrite>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Overwrite target if existing. Overwrite wins over `ignoreIfExists`</haxe_doc>
			</overwrite>
			<ignoreIfExists>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Ignores if target exists.</haxe_doc>
			</ignoreIfExists>
		</a>
		<haxe_doc>Rename file options</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.RenameFile" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<options>
				<x path="Null"><t path="languageServerProtocol.RenameFileOptions"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Rename options.</haxe_doc>
			</options>
			<oldUri>
				<x path="languageServerProtocol.textdocument.DocumentUri"/>
				<haxe_doc>The old (existing) location.</haxe_doc>
			</oldUri>
			<newUri>
				<x path="languageServerProtocol.textdocument.DocumentUri"/>
				<haxe_doc>The new location.</haxe_doc>
			</newUri>
			<kind>
				<x path="languageServerProtocol.RenameFileKind"/>
				<haxe_doc>The resource operation kind.</haxe_doc>
			</kind>
			<annotationId>
				<x path="Null"><t path="languageServerProtocol.ChangeAnnotationIdentifier"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional annotation identifier describing the operation.

		@since 3.16.0</haxe_doc>
			</annotationId>
		</a>
		<haxe_doc>Rename file operation</haxe_doc>
	</typedef>
	<abstract path="languageServerProtocol.DeleteFileKind" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="languageServerProtocol._Types.DeleteFileKind_Impl_" params="" file="src/languageServerProtocol/Types.hx" private="1" module="languageServerProtocol.Types" extern="1" final="1">
	<Delete public="1" get="inline" set="null" expr="cast &quot;Delete&quot;" line="518" static="1">
		<x path="languageServerProtocol.DeleteFileKind"/>
		<meta>
			<m n=":value"><e>cast "Delete"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Delete>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="languageServerProtocol._Types.DeleteFileKind_Impl_" params="" file="src/languageServerProtocol/Types.hx" private="1" module="languageServerProtocol.Types" extern="1" final="1">
		<Delete public="1" get="inline" set="null" expr="cast &quot;Delete&quot;" line="518" static="1">
			<x path="languageServerProtocol.DeleteFileKind"/>
			<meta>
				<m n=":value"><e>cast "Delete"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Delete>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="languageServerProtocol.DeleteFileOptions" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<recursive>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Delete the content recursively if a folder is denoted.</haxe_doc>
			</recursive>
			<ignoreIfNotExists>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Ignore the operation if the file doesn't exist.</haxe_doc>
			</ignoreIfNotExists>
		</a>
		<haxe_doc>Delete file options</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.DeleteFile" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<uri>
				<x path="languageServerProtocol.textdocument.DocumentUri"/>
				<haxe_doc>The file to delete.</haxe_doc>
			</uri>
			<options>
				<x path="Null"><t path="languageServerProtocol.DeleteFileOptions"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Delete options.</haxe_doc>
			</options>
			<kind>
				<x path="languageServerProtocol.DeleteFileKind"/>
				<haxe_doc>The resource operation kind.</haxe_doc>
			</kind>
			<annotationId>
				<x path="Null"><t path="languageServerProtocol.ChangeAnnotationIdentifier"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional annotation identifier describing the operation.

		@since 3.16.0</haxe_doc>
			</annotationId>
		</a>
		<haxe_doc>Delete file operation</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.WorkspaceEdit" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<documentChanges>
				<x path="Null"><c path="Array"><x path="haxe.extern.EitherType">
	<t path="languageServerProtocol.TextDocumentEdit"/>
	<x path="haxe.extern.EitherType">
		<t path="languageServerProtocol.CreateFile"/>
		<x path="haxe.extern.EitherType">
			<t path="languageServerProtocol.RenameFile"/>
			<t path="languageServerProtocol.DeleteFile"/>
		</x>
	</x>
</x></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Depending on the client capability `workspace.workspaceEdit.resourceOperations` document changes
		are either an array of `TextDocumentEdit`s to express changes to n different text documents
		where each text document edit addresses a specific version of a text document. Or it can contain
		above `TextDocumentEdit`s mixed with create, rename and delete file / folder operations.

		Whether a client supports versioned document edits is expressed via
		`workspace.workspaceEdit.documentChanges` client capability.

		If a client neither supports `documentChanges` nor `workspace.workspaceEdit.resourceOperations` then
		only plain `TextEdit`s using the `changes` property are supported.</haxe_doc>
			</documentChanges>
			<changes>
				<x path="Null"><x path="haxe.DynamicAccess"><c path="Array"><t path="languageServerProtocol.textdocument.TextEdit"/></c></x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Holds changes to existing resources.</haxe_doc>
			</changes>
			<changeAnnotations>
				<x path="Null"><x path="haxe.DynamicAccess"><t path="languageServerProtocol.ChangeAnnotation"/></x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>A map of change annotations that can be referenced in `AnnotatedTextEdit`s or create, rename and
		delete file / folder operations.

		Whether clients honor this property depends on the client capability `workspace.changeAnnotationSupport`.

		@since 3.16.0</haxe_doc>
			</changeAnnotations>
		</a>
		<haxe_doc>A workspace edit represents changes to many resources managed in the workspace. The edit
	should either provide `changes` or `documentChanges`. If documentChanges are present
	they are preferred over `changes` if the client can handle versioned document edits.

	Since version 3.13.0 a workspace edit can contain resource operations as well. If resource
	operations are present clients need to execute the operations in the order in which they
	are provided. So a workspace edit for example can consist of the following two changes:
	(1) a create file a.txt and (2) a text document edit which insert text into file a.txt.

	An invalid sequence (e.g. (1) delete file a.txt and (2) insert text into file a.txt) will
	cause failure of the operation. How the client recovers from the failure is described by
	the client capability: `workspace.workspaceEdit.failureHandling`</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.TextEditChange" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types" extern="1" interface="1">
		<all public="1" set="method">
			<f a=""><c path="Array"><x path="haxe.extern.EitherType">
	<t path="languageServerProtocol.textdocument.TextEdit"/>
	<t path="languageServerProtocol.AnnotatedTextEdit"/>
</x></c></f>
			<haxe_doc>Gets all text edits for this change.

		@return An array of text edits.

		@since 3.16.0 - support for annotated text edits. This is usually
		guarded using a client capability.</haxe_doc>
		</all>
		<clear public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Clears the edits for this change.</haxe_doc>
		</clear>
		<add public="1" set="method">
			<f a="edit">
				<x path="haxe.extern.EitherType">
					<t path="languageServerProtocol.textdocument.TextEdit"/>
					<t path="languageServerProtocol.AnnotatedTextEdit"/>
				</x>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds a text edit.

		@param edit the text edit to add.

		@since 3.16.0 - support for annotated text edits. This is usually
		guarded using a client capability.</haxe_doc>
		</add>
		<insert public="1" set="method">
			<f a="position:newText">
				<t path="languageServerProtocol.textdocument.Position"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Insert the given text at the given position.

		@param position A position.
		@param newText A string.
		@param annotation An optional annotation.</haxe_doc>
			<overloads><insert public="1" set="method"><f a="position:newText:annotation">
	<t path="languageServerProtocol.textdocument.Position"/>
	<c path="String"/>
	<x path="haxe.extern.EitherType">
		<t path="languageServerProtocol.ChangeAnnotation"/>
		<t path="languageServerProtocol.ChangeAnnotationIdentifier"/>
	</x>
	<t path="languageServerProtocol.ChangeAnnotationIdentifier"/>
</f></insert></overloads>
		</insert>
		<replace public="1" set="method">
			<f a="range:newText">
				<t path="languageServerProtocol.textdocument.Range"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Replace the given range with given text for the given resource.

		@param range A range.
		@param newText A string.
		@param annotation An optional annotation.</haxe_doc>
			<overloads><replace public="1" set="method"><f a="range:newText:?annotation">
	<t path="languageServerProtocol.textdocument.Range"/>
	<c path="String"/>
	<x path="haxe.extern.EitherType">
		<t path="languageServerProtocol.ChangeAnnotation"/>
		<t path="languageServerProtocol.ChangeAnnotationIdentifier"/>
	</x>
	<t path="languageServerProtocol.ChangeAnnotationIdentifier"/>
</f></replace></overloads>
		</replace>
		<delete public="1" set="method">
			<f a="range">
				<t path="languageServerProtocol.textdocument.Range"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Delete the text at the given range.

		@param range A range.
		@param annotation An optional annotation.</haxe_doc>
			<overloads><delete public="1" set="method"><f a="range:?annotation">
	<t path="languageServerProtocol.textdocument.Range"/>
	<x path="haxe.extern.EitherType">
		<t path="languageServerProtocol.ChangeAnnotation"/>
		<t path="languageServerProtocol.ChangeAnnotationIdentifier"/>
	</x>
	<t path="languageServerProtocol.ChangeAnnotationIdentifier"/>
</f></delete></overloads>
		</delete>
		<haxe_doc>A change to capture text edits for existing resources.</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.TextDocumentIdentifier" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a><uri>
	<x path="languageServerProtocol.textdocument.DocumentUri"/>
	<haxe_doc>The text document's uri.</haxe_doc>
</uri></a>
		<haxe_doc>A literal to identify a text document in the client.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.VersionedTextDocumentIdentifier" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<version>
				<x path="Int"/>
				<haxe_doc>The version number of this document. If a versioned text document identifier
		is sent from the server to the client and the file is not open in the editor
		(the server has not received an open notification before) the server can send
		`null` to indicate that the version is known and the content on disk is the
		truth (as speced with document content ownership).</haxe_doc>
			</version>
			<uri>
				<x path="languageServerProtocol.textdocument.DocumentUri"/>
				<haxe_doc>The text document's uri.</haxe_doc>
			</uri>
		</a>
		<haxe_doc>An identifier to denote a specific version of a text document.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.OptionalVersionedTextDocumentIdentifier" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<version>
				<x path="Null"><x path="Int"/></x>
				<haxe_doc>The version number of this document. If a versioned text document identifier
		is sent from the server to the client and the file is not open in the editor
		(the server has not received an open notification before) the server can send
		`null` to indicate that the version is unknown and the content on disk is the
		truth (as specified with document content ownership).</haxe_doc>
			</version>
			<uri>
				<x path="languageServerProtocol.textdocument.DocumentUri"/>
				<haxe_doc>The text document's uri.</haxe_doc>
			</uri>
		</a>
		<haxe_doc>A text document identifier to optionally denote a specific version of a text document.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.TextDocumentItem" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<version>
				<x path="Int"/>
				<haxe_doc>The version number of this document (it will strictly increase after each change, including undo/redo).</haxe_doc>
			</version>
			<uri>
				<x path="languageServerProtocol.textdocument.DocumentUri"/>
				<haxe_doc>The text document's uri.</haxe_doc>
			</uri>
			<text>
				<c path="String"/>
				<haxe_doc>The content of the opened text document.</haxe_doc>
			</text>
			<languageId>
				<c path="String"/>
				<haxe_doc>The text document's language identifier.</haxe_doc>
			</languageId>
		</a>
		<haxe_doc>An item to transfer a text document from the client to the server.</haxe_doc>
	</typedef>
	<abstract path="languageServerProtocol.MarkupKind" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<this><c path="String"/></this>
		<haxe_doc>Describes the content type that a client supports in various
	result literals like `Hover`, `ParameterInfo` or `CompletionItem`.

	Please note that `MarkupKinds` must not start with a `$`. This kinds
	are reserved for internal usage.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="languageServerProtocol._Types.MarkupKind_Impl_" params="" file="src/languageServerProtocol/Types.hx" private="1" module="languageServerProtocol.Types" extern="1" final="1">
	<PlainText public="1" get="inline" set="null" expr="cast &quot;plaintext&quot;" line="734" static="1">
		<x path="languageServerProtocol.MarkupKind"/>
		<meta>
			<m n=":value"><e>cast "plaintext"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Plain text is supported as a content format</haxe_doc>
	</PlainText>
	<MarkDown public="1" get="inline" set="null" expr="cast &quot;markdown&quot;" line="739" static="1">
		<x path="languageServerProtocol.MarkupKind"/>
		<meta>
			<m n=":value"><e>cast "markdown"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Markdown is supported as a content format</haxe_doc>
	</MarkDown>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="languageServerProtocol._Types.MarkupKind_Impl_" params="" file="src/languageServerProtocol/Types.hx" private="1" module="languageServerProtocol.Types" extern="1" final="1">
		<PlainText public="1" get="inline" set="null" expr="cast &quot;plaintext&quot;" line="734" static="1">
			<x path="languageServerProtocol.MarkupKind"/>
			<meta>
				<m n=":value"><e>cast "plaintext"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Plain text is supported as a content format</haxe_doc>
		</PlainText>
		<MarkDown public="1" get="inline" set="null" expr="cast &quot;markdown&quot;" line="739" static="1">
			<x path="languageServerProtocol.MarkupKind"/>
			<meta>
				<m n=":value"><e>cast "markdown"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Markdown is supported as a content format</haxe_doc>
		</MarkDown>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="languageServerProtocol.MarkupContent" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<value>
				<c path="String"/>
				<haxe_doc>The content itself</haxe_doc>
			</value>
			<kind>
				<x path="languageServerProtocol.MarkupKind"/>
				<haxe_doc>The type of the Markup</haxe_doc>
			</kind>
		</a>
		<haxe_doc>A `MarkupContent` literal represents a string value which content is interpreted base on its
	kind flag. Currently the protocol supports `plaintext` and `markdown` as markup kinds.

	If the kind is `markdown` then the value can contain fenced code blocks like in GitHub issues.
	See https://help.github.com/articles/creating-and-highlighting-code-blocks/#syntax-highlighting

	Here is an example how such a string can be constructed using JavaScript / TypeScript:
	```ts
	let markdown: MarkdownContent = {
		kind: MarkupKind.Markdown,
		value: [
			'# Header',
			'Some text',
			'```typescript',
			'someCode();',
			'```'
		].join('\n')
	};
	```

	*Please Note* that clients might sanitize the return markdown. A client could decide to
	remove HTML from the markdown to avoid script execution.</haxe_doc>
	</typedef>
	<abstract path="languageServerProtocol.CompletionItemKind" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<haxe_doc>The kind of a completion entry.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="languageServerProtocol._Types.CompletionItemKind_Impl_" params="" file="src/languageServerProtocol/Types.hx" private="1" module="languageServerProtocol.Types" extern="1" final="1">
	<Text public="1" get="inline" set="null" expr="cast 1" line="782" static="1">
		<x path="languageServerProtocol.CompletionItemKind"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Text>
	<Method public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
		<x path="languageServerProtocol.CompletionItemKind"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Method>
	<Function public="1" get="inline" set="null" expr="cast 3" line="1" static="1">
		<x path="languageServerProtocol.CompletionItemKind"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Function>
	<Constructor public="1" get="inline" set="null" expr="cast 4" line="1" static="1">
		<x path="languageServerProtocol.CompletionItemKind"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Constructor>
	<Field public="1" get="inline" set="null" expr="cast 5" line="1" static="1">
		<x path="languageServerProtocol.CompletionItemKind"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Field>
	<Variable public="1" get="inline" set="null" expr="cast 6" line="1" static="1">
		<x path="languageServerProtocol.CompletionItemKind"/>
		<meta>
			<m n=":value"><e>cast 6</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Variable>
	<Class public="1" get="inline" set="null" expr="cast 7" line="1" static="1">
		<x path="languageServerProtocol.CompletionItemKind"/>
		<meta>
			<m n=":value"><e>cast 7</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Class>
	<Interface public="1" get="inline" set="null" expr="cast 8" line="1" static="1">
		<x path="languageServerProtocol.CompletionItemKind"/>
		<meta>
			<m n=":value"><e>cast 8</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Interface>
	<Module public="1" get="inline" set="null" expr="cast 9" line="1" static="1">
		<x path="languageServerProtocol.CompletionItemKind"/>
		<meta>
			<m n=":value"><e>cast 9</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Module>
	<Property public="1" get="inline" set="null" expr="cast 10" line="1" static="1">
		<x path="languageServerProtocol.CompletionItemKind"/>
		<meta>
			<m n=":value"><e>cast 10</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Property>
	<Unit public="1" get="inline" set="null" expr="cast 11" line="1" static="1">
		<x path="languageServerProtocol.CompletionItemKind"/>
		<meta>
			<m n=":value"><e>cast 11</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Unit>
	<Value public="1" get="inline" set="null" expr="cast 12" line="1" static="1">
		<x path="languageServerProtocol.CompletionItemKind"/>
		<meta>
			<m n=":value"><e>cast 12</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Value>
	<Enum public="1" get="inline" set="null" expr="cast 13" line="1" static="1">
		<x path="languageServerProtocol.CompletionItemKind"/>
		<meta>
			<m n=":value"><e>cast 13</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Enum>
	<Keyword public="1" get="inline" set="null" expr="cast 14" line="1" static="1">
		<x path="languageServerProtocol.CompletionItemKind"/>
		<meta>
			<m n=":value"><e>cast 14</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Keyword>
	<Snippet public="1" get="inline" set="null" expr="cast 15" line="1" static="1">
		<x path="languageServerProtocol.CompletionItemKind"/>
		<meta>
			<m n=":value"><e>cast 15</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Snippet>
	<Color public="1" get="inline" set="null" expr="cast 16" line="1" static="1">
		<x path="languageServerProtocol.CompletionItemKind"/>
		<meta>
			<m n=":value"><e>cast 16</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Color>
	<File public="1" get="inline" set="null" expr="cast 17" line="1" static="1">
		<x path="languageServerProtocol.CompletionItemKind"/>
		<meta>
			<m n=":value"><e>cast 17</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</File>
	<Reference public="1" get="inline" set="null" expr="cast 18" line="1" static="1">
		<x path="languageServerProtocol.CompletionItemKind"/>
		<meta>
			<m n=":value"><e>cast 18</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Reference>
	<Folder public="1" get="inline" set="null" expr="cast 19" line="1" static="1">
		<x path="languageServerProtocol.CompletionItemKind"/>
		<meta>
			<m n=":value"><e>cast 19</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Folder>
	<EnumMember public="1" get="inline" set="null" expr="cast 20" line="1" static="1">
		<x path="languageServerProtocol.CompletionItemKind"/>
		<meta>
			<m n=":value"><e>cast 20</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</EnumMember>
	<Constant public="1" get="inline" set="null" expr="cast 21" line="1" static="1">
		<x path="languageServerProtocol.CompletionItemKind"/>
		<meta>
			<m n=":value"><e>cast 21</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Constant>
	<Struct public="1" get="inline" set="null" expr="cast 22" line="1" static="1">
		<x path="languageServerProtocol.CompletionItemKind"/>
		<meta>
			<m n=":value"><e>cast 22</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Struct>
	<Event public="1" get="inline" set="null" expr="cast 23" line="1" static="1">
		<x path="languageServerProtocol.CompletionItemKind"/>
		<meta>
			<m n=":value"><e>cast 23</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Event>
	<Operator public="1" get="inline" set="null" expr="cast 24" line="1" static="1">
		<x path="languageServerProtocol.CompletionItemKind"/>
		<meta>
			<m n=":value"><e>cast 24</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Operator>
	<TypeParameter public="1" get="inline" set="null" expr="cast 25" line="1" static="1">
		<x path="languageServerProtocol.CompletionItemKind"/>
		<meta>
			<m n=":value"><e>cast 25</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</TypeParameter>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="languageServerProtocol._Types.CompletionItemKind_Impl_" params="" file="src/languageServerProtocol/Types.hx" private="1" module="languageServerProtocol.Types" extern="1" final="1">
		<Text public="1" get="inline" set="null" expr="cast 1" line="782" static="1">
			<x path="languageServerProtocol.CompletionItemKind"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Text>
		<Method public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
			<x path="languageServerProtocol.CompletionItemKind"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Method>
		<Function public="1" get="inline" set="null" expr="cast 3" line="1" static="1">
			<x path="languageServerProtocol.CompletionItemKind"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Function>
		<Constructor public="1" get="inline" set="null" expr="cast 4" line="1" static="1">
			<x path="languageServerProtocol.CompletionItemKind"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Constructor>
		<Field public="1" get="inline" set="null" expr="cast 5" line="1" static="1">
			<x path="languageServerProtocol.CompletionItemKind"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Field>
		<Variable public="1" get="inline" set="null" expr="cast 6" line="1" static="1">
			<x path="languageServerProtocol.CompletionItemKind"/>
			<meta>
				<m n=":value"><e>cast 6</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Variable>
		<Class public="1" get="inline" set="null" expr="cast 7" line="1" static="1">
			<x path="languageServerProtocol.CompletionItemKind"/>
			<meta>
				<m n=":value"><e>cast 7</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Class>
		<Interface public="1" get="inline" set="null" expr="cast 8" line="1" static="1">
			<x path="languageServerProtocol.CompletionItemKind"/>
			<meta>
				<m n=":value"><e>cast 8</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Interface>
		<Module public="1" get="inline" set="null" expr="cast 9" line="1" static="1">
			<x path="languageServerProtocol.CompletionItemKind"/>
			<meta>
				<m n=":value"><e>cast 9</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Module>
		<Property public="1" get="inline" set="null" expr="cast 10" line="1" static="1">
			<x path="languageServerProtocol.CompletionItemKind"/>
			<meta>
				<m n=":value"><e>cast 10</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Property>
		<Unit public="1" get="inline" set="null" expr="cast 11" line="1" static="1">
			<x path="languageServerProtocol.CompletionItemKind"/>
			<meta>
				<m n=":value"><e>cast 11</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Unit>
		<Value public="1" get="inline" set="null" expr="cast 12" line="1" static="1">
			<x path="languageServerProtocol.CompletionItemKind"/>
			<meta>
				<m n=":value"><e>cast 12</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Value>
		<Enum public="1" get="inline" set="null" expr="cast 13" line="1" static="1">
			<x path="languageServerProtocol.CompletionItemKind"/>
			<meta>
				<m n=":value"><e>cast 13</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Enum>
		<Keyword public="1" get="inline" set="null" expr="cast 14" line="1" static="1">
			<x path="languageServerProtocol.CompletionItemKind"/>
			<meta>
				<m n=":value"><e>cast 14</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Keyword>
		<Snippet public="1" get="inline" set="null" expr="cast 15" line="1" static="1">
			<x path="languageServerProtocol.CompletionItemKind"/>
			<meta>
				<m n=":value"><e>cast 15</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Snippet>
		<Color public="1" get="inline" set="null" expr="cast 16" line="1" static="1">
			<x path="languageServerProtocol.CompletionItemKind"/>
			<meta>
				<m n=":value"><e>cast 16</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Color>
		<File public="1" get="inline" set="null" expr="cast 17" line="1" static="1">
			<x path="languageServerProtocol.CompletionItemKind"/>
			<meta>
				<m n=":value"><e>cast 17</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</File>
		<Reference public="1" get="inline" set="null" expr="cast 18" line="1" static="1">
			<x path="languageServerProtocol.CompletionItemKind"/>
			<meta>
				<m n=":value"><e>cast 18</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Reference>
		<Folder public="1" get="inline" set="null" expr="cast 19" line="1" static="1">
			<x path="languageServerProtocol.CompletionItemKind"/>
			<meta>
				<m n=":value"><e>cast 19</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Folder>
		<EnumMember public="1" get="inline" set="null" expr="cast 20" line="1" static="1">
			<x path="languageServerProtocol.CompletionItemKind"/>
			<meta>
				<m n=":value"><e>cast 20</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</EnumMember>
		<Constant public="1" get="inline" set="null" expr="cast 21" line="1" static="1">
			<x path="languageServerProtocol.CompletionItemKind"/>
			<meta>
				<m n=":value"><e>cast 21</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Constant>
		<Struct public="1" get="inline" set="null" expr="cast 22" line="1" static="1">
			<x path="languageServerProtocol.CompletionItemKind"/>
			<meta>
				<m n=":value"><e>cast 22</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Struct>
		<Event public="1" get="inline" set="null" expr="cast 23" line="1" static="1">
			<x path="languageServerProtocol.CompletionItemKind"/>
			<meta>
				<m n=":value"><e>cast 23</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Event>
		<Operator public="1" get="inline" set="null" expr="cast 24" line="1" static="1">
			<x path="languageServerProtocol.CompletionItemKind"/>
			<meta>
				<m n=":value"><e>cast 24</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Operator>
		<TypeParameter public="1" get="inline" set="null" expr="cast 25" line="1" static="1">
			<x path="languageServerProtocol.CompletionItemKind"/>
			<meta>
				<m n=":value"><e>cast 25</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</TypeParameter>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="languageServerProtocol.InsertTextFormat" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<this><x path="Int"/></this>
		<haxe_doc>Defines whether the insert text in a completion item should be interpreted as
	plain text or a snippet.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="languageServerProtocol._Types.InsertTextFormat_Impl_" params="" file="src/languageServerProtocol/Types.hx" private="1" module="languageServerProtocol.Types" extern="1" final="1">
	<PlainText public="1" get="inline" set="null" expr="cast 1" line="817" static="1">
		<x path="languageServerProtocol.InsertTextFormat"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>The primary text to be inserted is treated as a plain string.</haxe_doc>
	</PlainText>
	<Snippet public="1" get="inline" set="null" expr="cast 2" line="829" static="1">
		<x path="languageServerProtocol.InsertTextFormat"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>The primary text to be inserted is treated as a snippet.

		A snippet can define tab stops and placeholders with `$1`, `$2`
		and `${3:foo}`. `$0` defines the final tab stop, it defaults to
		the end of the snippet. Placeholders with equal identifiers are linked,
		that is typing in one will update others too.

		See also: https://github.com/Microsoft/vscode/blob/master/src/vs/editor/contrib/snippet/common/snippet.md</haxe_doc>
	</Snippet>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="languageServerProtocol._Types.InsertTextFormat_Impl_" params="" file="src/languageServerProtocol/Types.hx" private="1" module="languageServerProtocol.Types" extern="1" final="1">
		<PlainText public="1" get="inline" set="null" expr="cast 1" line="817" static="1">
			<x path="languageServerProtocol.InsertTextFormat"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>The primary text to be inserted is treated as a plain string.</haxe_doc>
		</PlainText>
		<Snippet public="1" get="inline" set="null" expr="cast 2" line="829" static="1">
			<x path="languageServerProtocol.InsertTextFormat"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>The primary text to be inserted is treated as a snippet.

		A snippet can define tab stops and placeholders with `$1`, `$2`
		and `${3:foo}`. `$0` defines the final tab stop, it defaults to
		the end of the snippet. Placeholders with equal identifiers are linked,
		that is typing in one will update others too.

		See also: https://github.com/Microsoft/vscode/blob/master/src/vs/editor/contrib/snippet/common/snippet.md</haxe_doc>
		</Snippet>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="languageServerProtocol.CompletionItemTag" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<this><x path="Int"/></this>
		<haxe_doc>Completion item tags are extra annotations that tweak the rendering of a completion
	item.

	@since 3.15.0</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="languageServerProtocol._Types.CompletionItemTag_Impl_" params="" file="src/languageServerProtocol/Types.hx" private="1" module="languageServerProtocol.Types" extern="1" final="1">
	<Deprecated public="1" get="inline" set="null" expr="cast 1" line="842" static="1">
		<x path="languageServerProtocol.CompletionItemTag"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Render a completion as obsolete, usually using a strike-out.</haxe_doc>
	</Deprecated>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="languageServerProtocol._Types.CompletionItemTag_Impl_" params="" file="src/languageServerProtocol/Types.hx" private="1" module="languageServerProtocol.Types" extern="1" final="1">
		<Deprecated public="1" get="inline" set="null" expr="cast 1" line="842" static="1">
			<x path="languageServerProtocol.CompletionItemTag"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Render a completion as obsolete, usually using a strike-out.</haxe_doc>
		</Deprecated>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="languageServerProtocol.InsertReplaceEdit" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<replace>
				<t path="languageServerProtocol.textdocument.Range"/>
				<haxe_doc>The range if the replace is requested.</haxe_doc>
			</replace>
			<newText>
				<c path="String"/>
				<haxe_doc>The string to be inserted.</haxe_doc>
			</newText>
			<insert>
				<t path="languageServerProtocol.textdocument.Range"/>
				<haxe_doc>The range if the insert is requested</haxe_doc>
			</insert>
		</a>
		<haxe_doc>A special text edit to provide an insert and a replace operation.

	@since 3.16.0 - Proposed state</haxe_doc>
	</typedef>
	<abstract path="languageServerProtocol.InsertTextMode" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<this><x path="Int"/></this>
		<haxe_doc>How whitespace and indentation is handled during completion
	item insertion.

	@since 3.16.0</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="languageServerProtocol._Types.InsertTextMode_Impl_" params="" file="src/languageServerProtocol/Types.hx" private="1" module="languageServerProtocol.Types" extern="1" final="1">
	<asIs public="1" get="inline" set="null" expr="cast 1" line="881" static="1">
		<x path="languageServerProtocol.InsertTextMode"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>The insertion or replace strings is taken as it is. If the
		value is multi line the lines below the cursor will be
		inserted using the indentation defined in the string value.
		The client will not apply any kind of adjustments to the
		string.</haxe_doc>
	</asIs>
	<adjustIndentation public="1" get="inline" set="null" expr="cast 2" line="892" static="1">
		<x path="languageServerProtocol.InsertTextMode"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc><![CDATA[The editor adjusts leading whitespace of new lines so that
		they match the indentation up to the cursor of the line for
		which the item is accepted.

		Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a
		multi line completion item is indented using 2 tabs and all
		following lines inserted will be indented using 2 tabs as well.]]></haxe_doc>
	</adjustIndentation>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="languageServerProtocol._Types.InsertTextMode_Impl_" params="" file="src/languageServerProtocol/Types.hx" private="1" module="languageServerProtocol.Types" extern="1" final="1">
		<asIs public="1" get="inline" set="null" expr="cast 1" line="881" static="1">
			<x path="languageServerProtocol.InsertTextMode"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>The insertion or replace strings is taken as it is. If the
		value is multi line the lines below the cursor will be
		inserted using the indentation defined in the string value.
		The client will not apply any kind of adjustments to the
		string.</haxe_doc>
		</asIs>
		<adjustIndentation public="1" get="inline" set="null" expr="cast 2" line="892" static="1">
			<x path="languageServerProtocol.InsertTextMode"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc><![CDATA[The editor adjusts leading whitespace of new lines so that
		they match the indentation up to the cursor of the line for
		which the item is accepted.

		Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a
		multi line completion item is indented using 2 tabs and all
		following lines inserted will be indented using 2 tabs as well.]]></haxe_doc>
		</adjustIndentation>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="languageServerProtocol.CompletionItemLabelDetails" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<detail>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional string which is rendered less prominently directly after {@link CompletionItem.label label},
		without any spacing. Should be used for function signatures or type annotations.</haxe_doc>
			</detail>
			<description>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional string which is rendered less prominently after {@link CompletionItem.detail}. Should be used
		for fully qualified names or file path.</haxe_doc>
			</description>
		</a>
		<haxe_doc>Additional details for a completion item label.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.CompletionItem" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<textEditText>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The edit text used if the completion item is part of a CompletionList and
		CompletionList defines an item default for the text edit range.

		Clients will only honor this property if they opt into completion list
		item defaults using the capability `completionList.itemDefaults`.

		If not provided and a list's default range is provided the label
		property is used as a text.

		@since 3.17.0
		@proposed</haxe_doc>
			</textEditText>
			<textEdit>
				<x path="Null"><x path="haxe.extern.EitherType">
	<t path="languageServerProtocol.textdocument.TextEdit"/>
	<t path="languageServerProtocol.InsertReplaceEdit"/>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An [edit](#TextEdit) which is applied to a document when selecting
		this completion. When an edit is provided the value of
		[insertText](#CompletionItem.insertText) is ignored.

		Most editors support two different operation when accepting a completion
		item. One is to insert a completion text and the other is to replace an
		existing text with a completion text. Since this can usually not
		predetermined by a server it can report both ranges. Clients need to
		signal support for `InsertReplaceEdits` via the
		`textDocument.completion.insertReplaceSupport` client capability
		property.

		*Note 1:* The text edit's range as well as both ranges from a insert
		replace edit must be a [single line] and they must contain the position
		at which completion has been requested.
		*Note 2:* If an `InsertReplaceEdit` is returned the edit's insert range
		must be a prefix of the edit's replace range, that means it must be
		contained and starting at the same position.

		@since 3.16.0 additional type `InsertReplaceEdit` - Proposed state</haxe_doc>
			</textEdit>
			<tags>
				<x path="Null"><c path="Array"><x path="languageServerProtocol.CompletionItemTag"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Tags for this completion item.

		@since 3.15.0</haxe_doc>
			</tags>
			<sortText>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>A string that should be used when comparing this item with other items.
		When `falsy` the label is used.</haxe_doc>
			</sortText>
			<preselect>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Select this item when showing.

		*Note* that only one completion item can be selected and that the
		tool / client decides which item that is. The rule is that thefirst*
		item of those that match best is selected.</haxe_doc>
			</preselect>
			<labelDetails>
				<x path="Null"><t path="languageServerProtocol.CompletionItemLabelDetails"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Additional details for the label

		@since 3.17.0
		@proposed</haxe_doc>
			</labelDetails>
			<label>
				<c path="String"/>
				<haxe_doc>The label of this completion item.
		By default also the text that is inserted when selecting this completion.</haxe_doc>
			</label>
			<kind>
				<x path="Null"><x path="languageServerProtocol.CompletionItemKind"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The kind of this completion item.
		Based of the kind an icon is chosen by the editor.</haxe_doc>
			</kind>
			<insertTextMode>
				<x path="Null"><x path="languageServerProtocol.InsertTextMode"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>How whitespace and indentation is handled during completion
		item insertion. If ignored the clients default value depends on
		the `textDocument.completion.insertTextMode` client capability.

		@since 3.16.0</haxe_doc>
			</insertTextMode>
			<insertTextFormat>
				<x path="Null"><x path="languageServerProtocol.InsertTextFormat"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The format of the insert text. The format applies to both the
		`insertText` property and the `newText` property of a provided
		`textEdit`. If omitted defaults to `InsertTextFormat.PlainText`.

		Please note that the insertTextFormat doesn't apply to
		`additionalTextEdits`.</haxe_doc>
			</insertTextFormat>
			<insertText>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc><![CDATA[A string that should be inserted into a document when selecting
		this completion. When `falsy` the [label](#CompletionItem.label)
		is used.

		The `insertText` is subject to interpretation by the client side.
		Some tools might not take the string literally. For example
		VS Code when code complete is requested in this example
		`con<cursor position>` and a completion item with an `insertText` of
		`console` is provided it will only insert `sole`. Therefore it is
		recommended to use `textEdit` instead since it avoids additional client
		side interpretation.]]></haxe_doc>
			</insertText>
			<filterText>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>A string that should be used when filtering a set of completion items.
		When `falsy` the label is used.</haxe_doc>
			</filterText>
			<documentation>
				<x path="Null"><x path="haxe.extern.EitherType">
	<c path="String"/>
	<t path="languageServerProtocol.MarkupContent"/>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>A human-readable string that represents a doc-comment.</haxe_doc>
			</documentation>
			<detail>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>A human-readable string with additional information about this item, like type or symbol information.</haxe_doc>
			</detail>
			<deprecated>
				<x path="Null"><x path="Bool"/></x>
				<meta>
					<m n=":optional"/>
					<m n=":deprecated"><e>"Use `tags` instead."</e></m>
				</meta>
				<haxe_doc>Indicates if this item is deprecated.</haxe_doc>
			</deprecated>
			<data>
				<x path="Null"><t path="languageServerProtocol.LSPAny"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An data entry field that is preserved on a completion item between a completion and a completion resolve request.</haxe_doc>
			</data>
			<commitCharacters>
				<x path="Null"><c path="Array"><c path="String"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional set of characters that when pressed while this completion is active will accept it first and
		then type that character.Note* that all commit characters should have `length=1` and that superfluous
		characters will be ignored.</haxe_doc>
			</commitCharacters>
			<command>
				<x path="Null"><t path="languageServerProtocol.Command"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional command that is executedafter* inserting this completion.Note* that
		additional modifications to the current document should be described with the
		additionalTextEdits-property.</haxe_doc>
			</command>
			<additionalTextEdits>
				<x path="Null"><c path="Array"><t path="languageServerProtocol.textdocument.TextEdit"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional array of additional [text edits](#TextEdit) that are applied when
		selecting this completion. Edits must not overlap (including the same insert position)
		with the main [edit](#CompletionItem.textEdit) nor with themselves.

		Additional text edits should be used to change text unrelated to the current cursor position
		(for example adding an import statement at the top of the file if the completion item will
		insert an unqualified type).</haxe_doc>
			</additionalTextEdits>
		</a>
		<haxe_doc>A completion item represents a text snippet that is
	proposed to complete text that is being typed.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.CompletionList" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<items>
				<c path="Array"><t path="languageServerProtocol.CompletionItem"/></c>
				<haxe_doc>The completion items.</haxe_doc>
			</items>
			<itemDefaults>
				<x path="Null"><a>
	<insertTextMode>
		<x path="Null"><x path="languageServerProtocol.InsertTextMode"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>A default insert text mode.

			@since 3.17.0
			@proposed</haxe_doc>
	</insertTextMode>
	<insertTextFormat>
		<x path="Null"><x path="languageServerProtocol.InsertTextFormat"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>A default insert text format.

			@since 3.17.0
			@proposed</haxe_doc>
	</insertTextFormat>
	<editRange>
		<x path="Null"><x path="haxe.extern.EitherType">
	<t path="languageServerProtocol.textdocument.Range"/>
	<a>
		<replace><t path="languageServerProtocol.textdocument.Range"/></replace>
		<insert><t path="languageServerProtocol.textdocument.Range"/></insert>
	</a>
</x></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>A default edit range.

			@since 3.17.0
			@proposed</haxe_doc>
	</editRange>
	<data>
		<x path="Null"><t path="languageServerProtocol.LSPAny"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>A default data value.

			@since 3.17.0
			@proposed</haxe_doc>
	</data>
	<commitCharacters>
		<x path="Null"><c path="Array"><c path="String"/></c></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>A default commit character set.

			@since 3.17.0
			@proposed</haxe_doc>
	</commitCharacters>
</a></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>In many cases the items of an actual completion result share the same
		value for properties like `commitCharacters` or the range of a text
		edit. A completion list can therefore define item defaults which will
		be used if a completion item itself doesn't specify the value.

		If a completion list specifies a default value and a completion item
		also specifies a corresponding value the one from the item is used.

		Servers are only allowed to return default values if the client
		signals support for this via the `completionList.itemDefaults`
		capability.

		@since 3.17.0
		@proposed</haxe_doc>
			</itemDefaults>
			<isIncomplete>
				<x path="Bool"/>
				<haxe_doc>This list it not complete. Further typing should result in recomputing this list.</haxe_doc>
			</isIncomplete>
		</a>
		<haxe_doc>Represents a collection of completion items to be presented in the editor.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.MarkedString" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<x path="haxe.extern.EitherType">
			<c path="String"/>
			<a>
				<value><c path="String"/></value>
				<language><c path="String"/></language>
			</a>
		</x>
		<haxe_doc>MarkedString can be used to render human readable text. It is either a markdown string
	or a code-block that provides a language and a code snippet. The language identifier
	is semantically equal to the optional language identifier in fenced code blocks in GitHub
	issues. See https://help.github.com/articles/creating-and-highlighting-code-blocks/#syntax-highlighting

	The pair of a language and a value is an equivalent to markdown:
	```${language}
	${value}
	```

	Note that markdown strings will be sanitized - that means html will be escaped.</haxe_doc>
		<meta><m n=":deprecated"><e>"use MarkupContent instead"</e></m></meta>
	</typedef>
	<typedef path="languageServerProtocol.Hover" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<range>
				<x path="Null"><t path="languageServerProtocol.textdocument.Range"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional range.</haxe_doc>
			</range>
			<contents>
				<x path="haxe.extern.EitherType">
					<t path="languageServerProtocol.MarkupContent"/>
					<x path="haxe.extern.EitherType">
						<t path="languageServerProtocol.MarkedString"/>
						<c path="Array"><t path="languageServerProtocol.MarkedString"/></c>
					</x>
				</x>
				<haxe_doc>The hover's content.</haxe_doc>
			</contents>
		</a>
		<haxe_doc>The result of a hover request.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.ParameterInformation" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<label>
				<x path="haxe.extern.EitherType">
					<c path="String"/>
					<c path="Array"><x path="Int"/></c>
				</x>
				<haxe_doc>The label of this parameter information.

		Either a string or an inclusive start and exclusive end offsets within its containing
		signature label. (see SignatureInformation.label). The offsets are based on a UTF-16
		string representation as `Position` and `Range` does.

		*Note*: a label of type string should be a substring of its containing signature label.
		Its intended use case is to highlight the parameter label part in the `SignatureInformation.label`.</haxe_doc>
			</label>
			<documentation>
				<x path="Null"><x path="haxe.extern.EitherType">
	<c path="String"/>
	<t path="languageServerProtocol.MarkupContent"/>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The human-readable doc-comment of this signature.
		Will be shown in the UI but can be omitted.</haxe_doc>
			</documentation>
		</a>
		<haxe_doc>Represents a parameter of a callable-signature.
	A parameter can have a label and a doc-comment.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.SignatureInformation" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<parameters>
				<x path="Null"><c path="Array"><t path="languageServerProtocol.ParameterInformation"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The parameters of this signature.</haxe_doc>
			</parameters>
			<label>
				<c path="String"/>
				<haxe_doc>The label of this signature.
		Will be shown in the UI.</haxe_doc>
			</label>
			<documentation>
				<x path="Null"><x path="haxe.extern.EitherType">
	<c path="String"/>
	<t path="languageServerProtocol.MarkupContent"/>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The human-readable doc-comment of this signature.
		Will be shown in the UI but can be omitted.</haxe_doc>
			</documentation>
			<activeParameter>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The index of the active parameter.

		If provided, this is used in place of `SignatureHelp.activeParameter`.

		@since 3.16.0</haxe_doc>
			</activeParameter>
		</a>
		<haxe_doc>Represents the signature of something callable.
	A signature can have a label, like a function-name, a doc-comment, and a set of parameters.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.SignatureHelp" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<signatures>
				<c path="Array"><t path="languageServerProtocol.SignatureInformation"/></c>
				<haxe_doc>One or more signatures.</haxe_doc>
			</signatures>
			<activeSignature>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The active signature. Set to `null` if no
		signatures exist.</haxe_doc>
			</activeSignature>
			<activeParameter>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The active parameter of the active signature. Set to `null`
		if the active signature has no parameters.</haxe_doc>
			</activeParameter>
		</a>
		<haxe_doc>Signature help represents the signature of something callable.
	There can be multiple signature but only one active and only one active parameter.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.Definition" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<x path="haxe.extern.EitherType">
			<t path="languageServerProtocol.Location"/>
			<c path="Array"><t path="languageServerProtocol.Location"/></c>
		</x>
		<haxe_doc>The definition of a symbol represented as one or many [locations](#Location).
	For most programming languages there is only one location at which a symbol is
	defined.

	Servers should prefer returning `DefinitionLink` over `Definition` if supported
	by the client.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.DefinitionLink" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<t path="languageServerProtocol.LocationLink"/>
		<haxe_doc>Information about where a symbol is defined.

	Provides additional metadata over normal [location](#Location) definitions, including the range of
	the defining symbol</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.Declaration" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<x path="haxe.extern.EitherType">
			<t path="languageServerProtocol.Location"/>
			<c path="Array"><t path="languageServerProtocol.Location"/></c>
		</x>
		<haxe_doc>The declaration of a symbol representation as one or many [locations](#Location).</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.DeclarationLink" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<t path="languageServerProtocol.LocationLink"/>
		<haxe_doc>Information about where a symbol is declared.

	Provides additional metadata over normal [location](#Location) declarations, including the range of
	the declaring symbol.

	Servers should prefer returning `DeclarationLink` over `Declaration` if supported
	by the client.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.ReferenceContext" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a><includeDeclaration>
	<x path="Bool"/>
	<haxe_doc>Include the declaration of the current symbol.</haxe_doc>
</includeDeclaration></a>
		<haxe_doc>Value-object that contains additional information when
	requesting references.</haxe_doc>
	</typedef>
	<abstract path="languageServerProtocol.DocumentHighlightKind" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<haxe_doc>A document highlight kind.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="languageServerProtocol._Types.DocumentHighlightKind_Impl_" params="" file="src/languageServerProtocol/Types.hx" private="1" module="languageServerProtocol.Types" extern="1" final="1">
	<Text public="1" get="inline" set="null" expr="cast 1" line="1326" static="1">
		<x path="languageServerProtocol.DocumentHighlightKind"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>A textual occurrence.</haxe_doc>
	</Text>
	<Read public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
		<x path="languageServerProtocol.DocumentHighlightKind"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Read-access of a symbol, like reading a variable.</haxe_doc>
	</Read>
	<Write public="1" get="inline" set="null" expr="cast 3" line="1" static="1">
		<x path="languageServerProtocol.DocumentHighlightKind"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Write-access of a symbol, like writing to a variable.</haxe_doc>
	</Write>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="languageServerProtocol._Types.DocumentHighlightKind_Impl_" params="" file="src/languageServerProtocol/Types.hx" private="1" module="languageServerProtocol.Types" extern="1" final="1">
		<Text public="1" get="inline" set="null" expr="cast 1" line="1326" static="1">
			<x path="languageServerProtocol.DocumentHighlightKind"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>A textual occurrence.</haxe_doc>
		</Text>
		<Read public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
			<x path="languageServerProtocol.DocumentHighlightKind"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Read-access of a symbol, like reading a variable.</haxe_doc>
		</Read>
		<Write public="1" get="inline" set="null" expr="cast 3" line="1" static="1">
			<x path="languageServerProtocol.DocumentHighlightKind"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Write-access of a symbol, like writing to a variable.</haxe_doc>
		</Write>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="languageServerProtocol.DocumentHighlight" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<range>
				<t path="languageServerProtocol.textdocument.Range"/>
				<haxe_doc>The range this highlight applies to.</haxe_doc>
			</range>
			<kind>
				<x path="Null"><x path="languageServerProtocol.DocumentHighlightKind"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The highlight kind, default is `DocumentHighlightKind.Text`.</haxe_doc>
			</kind>
		</a>
		<haxe_doc>A document highlight is a range inside a text document which deserves special attention.
	Usually a document highlight is visualized by changing the background color of its range.</haxe_doc>
	</typedef>
	<abstract path="languageServerProtocol.SymbolKind" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<haxe_doc>A symbol kind.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="languageServerProtocol._Types.SymbolKind_Impl_" params="" file="src/languageServerProtocol/Types.hx" private="1" module="languageServerProtocol.Types" extern="1" final="1">
	<File public="1" get="inline" set="null" expr="cast 1" line="1359" static="1">
		<x path="languageServerProtocol.SymbolKind"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</File>
	<Module public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
		<x path="languageServerProtocol.SymbolKind"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Module>
	<Namespace public="1" get="inline" set="null" expr="cast 3" line="1" static="1">
		<x path="languageServerProtocol.SymbolKind"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Namespace>
	<Package public="1" get="inline" set="null" expr="cast 4" line="1" static="1">
		<x path="languageServerProtocol.SymbolKind"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Package>
	<Class public="1" get="inline" set="null" expr="cast 5" line="1" static="1">
		<x path="languageServerProtocol.SymbolKind"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Class>
	<Method public="1" get="inline" set="null" expr="cast 6" line="1" static="1">
		<x path="languageServerProtocol.SymbolKind"/>
		<meta>
			<m n=":value"><e>cast 6</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Method>
	<Property public="1" get="inline" set="null" expr="cast 7" line="1" static="1">
		<x path="languageServerProtocol.SymbolKind"/>
		<meta>
			<m n=":value"><e>cast 7</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Property>
	<Field public="1" get="inline" set="null" expr="cast 8" line="1" static="1">
		<x path="languageServerProtocol.SymbolKind"/>
		<meta>
			<m n=":value"><e>cast 8</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Field>
	<Constructor public="1" get="inline" set="null" expr="cast 9" line="1" static="1">
		<x path="languageServerProtocol.SymbolKind"/>
		<meta>
			<m n=":value"><e>cast 9</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Constructor>
	<Enum public="1" get="inline" set="null" expr="cast 10" line="1" static="1">
		<x path="languageServerProtocol.SymbolKind"/>
		<meta>
			<m n=":value"><e>cast 10</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Enum>
	<Interface public="1" get="inline" set="null" expr="cast 11" line="1" static="1">
		<x path="languageServerProtocol.SymbolKind"/>
		<meta>
			<m n=":value"><e>cast 11</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Interface>
	<Function public="1" get="inline" set="null" expr="cast 12" line="1" static="1">
		<x path="languageServerProtocol.SymbolKind"/>
		<meta>
			<m n=":value"><e>cast 12</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Function>
	<Variable public="1" get="inline" set="null" expr="cast 13" line="1" static="1">
		<x path="languageServerProtocol.SymbolKind"/>
		<meta>
			<m n=":value"><e>cast 13</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Variable>
	<Constant public="1" get="inline" set="null" expr="cast 14" line="1" static="1">
		<x path="languageServerProtocol.SymbolKind"/>
		<meta>
			<m n=":value"><e>cast 14</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Constant>
	<String public="1" get="inline" set="null" expr="cast 15" line="1" static="1">
		<x path="languageServerProtocol.SymbolKind"/>
		<meta>
			<m n=":value"><e>cast 15</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</String>
	<Number public="1" get="inline" set="null" expr="cast 16" line="1" static="1">
		<x path="languageServerProtocol.SymbolKind"/>
		<meta>
			<m n=":value"><e>cast 16</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Number>
	<Boolean public="1" get="inline" set="null" expr="cast 17" line="1" static="1">
		<x path="languageServerProtocol.SymbolKind"/>
		<meta>
			<m n=":value"><e>cast 17</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Boolean>
	<Array public="1" get="inline" set="null" expr="cast 18" line="1" static="1">
		<x path="languageServerProtocol.SymbolKind"/>
		<meta>
			<m n=":value"><e>cast 18</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Array>
	<Object public="1" get="inline" set="null" expr="cast 19" line="1" static="1">
		<x path="languageServerProtocol.SymbolKind"/>
		<meta>
			<m n=":value"><e>cast 19</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Object>
	<Key public="1" get="inline" set="null" expr="cast 20" line="1" static="1">
		<x path="languageServerProtocol.SymbolKind"/>
		<meta>
			<m n=":value"><e>cast 20</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Key>
	<Null public="1" get="inline" set="null" expr="cast 21" line="1" static="1">
		<x path="languageServerProtocol.SymbolKind"/>
		<meta>
			<m n=":value"><e>cast 21</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Null>
	<EnumMember public="1" get="inline" set="null" expr="cast 22" line="1" static="1">
		<x path="languageServerProtocol.SymbolKind"/>
		<meta>
			<m n=":value"><e>cast 22</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</EnumMember>
	<Struct public="1" get="inline" set="null" expr="cast 23" line="1" static="1">
		<x path="languageServerProtocol.SymbolKind"/>
		<meta>
			<m n=":value"><e>cast 23</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Struct>
	<Event public="1" get="inline" set="null" expr="cast 24" line="1" static="1">
		<x path="languageServerProtocol.SymbolKind"/>
		<meta>
			<m n=":value"><e>cast 24</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Event>
	<Operator public="1" get="inline" set="null" expr="cast 25" line="1" static="1">
		<x path="languageServerProtocol.SymbolKind"/>
		<meta>
			<m n=":value"><e>cast 25</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Operator>
	<TypeParameter public="1" get="inline" set="null" expr="cast 26" line="1" static="1">
		<x path="languageServerProtocol.SymbolKind"/>
		<meta>
			<m n=":value"><e>cast 26</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</TypeParameter>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="languageServerProtocol._Types.SymbolKind_Impl_" params="" file="src/languageServerProtocol/Types.hx" private="1" module="languageServerProtocol.Types" extern="1" final="1">
		<File public="1" get="inline" set="null" expr="cast 1" line="1359" static="1">
			<x path="languageServerProtocol.SymbolKind"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</File>
		<Module public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
			<x path="languageServerProtocol.SymbolKind"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Module>
		<Namespace public="1" get="inline" set="null" expr="cast 3" line="1" static="1">
			<x path="languageServerProtocol.SymbolKind"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Namespace>
		<Package public="1" get="inline" set="null" expr="cast 4" line="1" static="1">
			<x path="languageServerProtocol.SymbolKind"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Package>
		<Class public="1" get="inline" set="null" expr="cast 5" line="1" static="1">
			<x path="languageServerProtocol.SymbolKind"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Class>
		<Method public="1" get="inline" set="null" expr="cast 6" line="1" static="1">
			<x path="languageServerProtocol.SymbolKind"/>
			<meta>
				<m n=":value"><e>cast 6</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Method>
		<Property public="1" get="inline" set="null" expr="cast 7" line="1" static="1">
			<x path="languageServerProtocol.SymbolKind"/>
			<meta>
				<m n=":value"><e>cast 7</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Property>
		<Field public="1" get="inline" set="null" expr="cast 8" line="1" static="1">
			<x path="languageServerProtocol.SymbolKind"/>
			<meta>
				<m n=":value"><e>cast 8</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Field>
		<Constructor public="1" get="inline" set="null" expr="cast 9" line="1" static="1">
			<x path="languageServerProtocol.SymbolKind"/>
			<meta>
				<m n=":value"><e>cast 9</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Constructor>
		<Enum public="1" get="inline" set="null" expr="cast 10" line="1" static="1">
			<x path="languageServerProtocol.SymbolKind"/>
			<meta>
				<m n=":value"><e>cast 10</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Enum>
		<Interface public="1" get="inline" set="null" expr="cast 11" line="1" static="1">
			<x path="languageServerProtocol.SymbolKind"/>
			<meta>
				<m n=":value"><e>cast 11</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Interface>
		<Function public="1" get="inline" set="null" expr="cast 12" line="1" static="1">
			<x path="languageServerProtocol.SymbolKind"/>
			<meta>
				<m n=":value"><e>cast 12</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Function>
		<Variable public="1" get="inline" set="null" expr="cast 13" line="1" static="1">
			<x path="languageServerProtocol.SymbolKind"/>
			<meta>
				<m n=":value"><e>cast 13</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Variable>
		<Constant public="1" get="inline" set="null" expr="cast 14" line="1" static="1">
			<x path="languageServerProtocol.SymbolKind"/>
			<meta>
				<m n=":value"><e>cast 14</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Constant>
		<String public="1" get="inline" set="null" expr="cast 15" line="1" static="1">
			<x path="languageServerProtocol.SymbolKind"/>
			<meta>
				<m n=":value"><e>cast 15</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</String>
		<Number public="1" get="inline" set="null" expr="cast 16" line="1" static="1">
			<x path="languageServerProtocol.SymbolKind"/>
			<meta>
				<m n=":value"><e>cast 16</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Number>
		<Boolean public="1" get="inline" set="null" expr="cast 17" line="1" static="1">
			<x path="languageServerProtocol.SymbolKind"/>
			<meta>
				<m n=":value"><e>cast 17</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Boolean>
		<Array public="1" get="inline" set="null" expr="cast 18" line="1" static="1">
			<x path="languageServerProtocol.SymbolKind"/>
			<meta>
				<m n=":value"><e>cast 18</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Array>
		<Object public="1" get="inline" set="null" expr="cast 19" line="1" static="1">
			<x path="languageServerProtocol.SymbolKind"/>
			<meta>
				<m n=":value"><e>cast 19</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Object>
		<Key public="1" get="inline" set="null" expr="cast 20" line="1" static="1">
			<x path="languageServerProtocol.SymbolKind"/>
			<meta>
				<m n=":value"><e>cast 20</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Key>
		<Null public="1" get="inline" set="null" expr="cast 21" line="1" static="1">
			<x path="languageServerProtocol.SymbolKind"/>
			<meta>
				<m n=":value"><e>cast 21</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Null>
		<EnumMember public="1" get="inline" set="null" expr="cast 22" line="1" static="1">
			<x path="languageServerProtocol.SymbolKind"/>
			<meta>
				<m n=":value"><e>cast 22</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</EnumMember>
		<Struct public="1" get="inline" set="null" expr="cast 23" line="1" static="1">
			<x path="languageServerProtocol.SymbolKind"/>
			<meta>
				<m n=":value"><e>cast 23</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Struct>
		<Event public="1" get="inline" set="null" expr="cast 24" line="1" static="1">
			<x path="languageServerProtocol.SymbolKind"/>
			<meta>
				<m n=":value"><e>cast 24</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Event>
		<Operator public="1" get="inline" set="null" expr="cast 25" line="1" static="1">
			<x path="languageServerProtocol.SymbolKind"/>
			<meta>
				<m n=":value"><e>cast 25</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Operator>
		<TypeParameter public="1" get="inline" set="null" expr="cast 26" line="1" static="1">
			<x path="languageServerProtocol.SymbolKind"/>
			<meta>
				<m n=":value"><e>cast 26</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</TypeParameter>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="languageServerProtocol.SymbolTag" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<this><x path="Int"/></this>
		<haxe_doc>Symbol tags are extra annotations that tweak the rendering of a symbol.
	@since 3.15</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="languageServerProtocol._Types.SymbolTag_Impl_" params="" file="src/languageServerProtocol/Types.hx" private="1" module="languageServerProtocol.Types" extern="1" final="1">
	<Deprecated public="1" get="inline" set="null" expr="cast 1" line="1395" static="1">
		<x path="languageServerProtocol.SymbolTag"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Render a symbol as obsolete, usually using a strike-out.</haxe_doc>
	</Deprecated>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="languageServerProtocol._Types.SymbolTag_Impl_" params="" file="src/languageServerProtocol/Types.hx" private="1" module="languageServerProtocol.Types" extern="1" final="1">
		<Deprecated public="1" get="inline" set="null" expr="cast 1" line="1395" static="1">
			<x path="languageServerProtocol.SymbolTag"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Render a symbol as obsolete, usually using a strike-out.</haxe_doc>
		</Deprecated>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="languageServerProtocol.BaseSymbolInformation" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<tags>
				<x path="Null"><c path="Array"><x path="languageServerProtocol.SymbolTag"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Tags for this completion item.

		@since 3.16.0</haxe_doc>
			</tags>
			<name>
				<c path="String"/>
				<haxe_doc>The name of this symbol.</haxe_doc>
			</name>
			<kind>
				<x path="languageServerProtocol.SymbolKind"/>
				<haxe_doc>The kind of this symbol.</haxe_doc>
			</kind>
			<containerName>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The name of the symbol containing this symbol. This information is for
		user interface purposes (e.g. to render a qualifier in the user interface
		if necessary). It can't be used to re-infer a hierarchy for the document
		symbols.</haxe_doc>
			</containerName>
		</a>
		<haxe_doc>A base for all symbol information.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.SymbolInformation" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<tags>
				<x path="Null"><c path="Array"><x path="languageServerProtocol.SymbolTag"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Tags for this completion item.

		@since 3.16.0</haxe_doc>
			</tags>
			<name>
				<c path="String"/>
				<haxe_doc>The name of this symbol.</haxe_doc>
			</name>
			<location>
				<t path="languageServerProtocol.Location"/>
				<haxe_doc>The location of this symbol. The location's range is used by a tool
		to reveal the location in the editor. If the symbol is selected in the
		tool the range's start information is used to position the cursor. So
		the range usually spans more than the actual symbol's name and does
		normally include thinks like visibility modifiers.

		The range doesn't have to denote a node range in the sense of a abstract
		syntax tree. It can therefore not be used to re-construct a hierarchy of
		the symbols.</haxe_doc>
			</location>
			<kind>
				<x path="languageServerProtocol.SymbolKind"/>
				<haxe_doc>The kind of this symbol.</haxe_doc>
			</kind>
			<deprecated>
				<x path="Null"><x path="Bool"/></x>
				<meta>
					<m n=":optional"/>
					<m n=":deprecated"><e>"Use tags instead"</e></m>
				</meta>
				<haxe_doc>Indicates if this symbol is deprecated.</haxe_doc>
			</deprecated>
			<containerName>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The name of the symbol containing this symbol. This information is for
		user interface purposes (e.g. to render a qualifier in the user interface
		if necessary). It can't be used to re-infer a hierarchy for the document
		symbols.</haxe_doc>
			</containerName>
		</a>
		<haxe_doc>Represents information about programming constructs like variables, classes, interfaces etc.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.WorkspaceSymbol" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<tags>
				<x path="Null"><c path="Array"><x path="languageServerProtocol.SymbolTag"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Tags for this completion item.

		@since 3.16.0</haxe_doc>
			</tags>
			<name>
				<c path="String"/>
				<haxe_doc>The name of this symbol.</haxe_doc>
			</name>
			<location>
				<x path="haxe.extern.EitherType">
					<t path="languageServerProtocol.Location"/>
					<a><uri><x path="languageServerProtocol.textdocument.DocumentUri"/></uri></a>
				</x>
				<haxe_doc>The location of the symbol. Whether a server is allowed to
		return a location without a range depends on the client
		capability `workspace.symbol.resolveSupport`.

		See SymbolInformation#location for more details.</haxe_doc>
			</location>
			<kind>
				<x path="languageServerProtocol.SymbolKind"/>
				<haxe_doc>The kind of this symbol.</haxe_doc>
			</kind>
			<data>
				<x path="Null"><t path="languageServerProtocol.LSPAny"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>A data entry field that is preserved on a workspace symbol between a
		workspace symbol request and a workspace symbol resolve request.</haxe_doc>
			</data>
			<containerName>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The name of the symbol containing this symbol. This information is for
		user interface purposes (e.g. to render a qualifier in the user interface
		if necessary). It can't be used to re-infer a hierarchy for the document
		symbols.</haxe_doc>
			</containerName>
		</a>
		<haxe_doc>A special workspace symbol that supports locations without a range.

	See also SymbolInformation.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.DocumentSymbol" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<tags>
				<x path="Null"><c path="Array"><x path="languageServerProtocol.SymbolTag"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Tags for this completion item.

		@since 3.16.0 - Proposed state</haxe_doc>
			</tags>
			<selectionRange>
				<t path="languageServerProtocol.textdocument.Range"/>
				<haxe_doc>The range that should be selected and reveal when this symbol is being picked, e.g the name of a function.
		Must be contained by the the `range`.</haxe_doc>
			</selectionRange>
			<range>
				<t path="languageServerProtocol.textdocument.Range"/>
				<haxe_doc>The range enclosing this symbol not including leading/trailing whitespace but everything else
		like comments. This information is typically used to determine if the the clients cursor is
		inside the symbol to reveal in the symbol in the UI.</haxe_doc>
			</range>
			<name>
				<c path="String"/>
				<haxe_doc>The name of this symbol. Will be displayed in the user interface and therefore must not be
		an empty string or a string only consisting of white spaces.</haxe_doc>
			</name>
			<kind>
				<x path="languageServerProtocol.SymbolKind"/>
				<haxe_doc>The kind of this symbol.</haxe_doc>
			</kind>
			<detail>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>More detail for this symbol, e.g the signature of a function.</haxe_doc>
			</detail>
			<deprecated>
				<x path="Null"><x path="Bool"/></x>
				<meta>
					<m n=":optional"/>
					<m n=":deprecated"><e>"Use tags instead"</e></m>
				</meta>
				<haxe_doc>Indicates if this symbol is deprecated.</haxe_doc>
			</deprecated>
			<children>
				<x path="Null"><c path="Array"><t path="languageServerProtocol.DocumentSymbol"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Children of this symbol, e.g. properties of a class.</haxe_doc>
			</children>
		</a>
		<haxe_doc>Represents programming constructs like variables, classes, interfaces etc.
	that appear in a document. Document symbols can be hierarchical and they
	have two ranges: one that encloses its definition and one that points to
	its most interesting range, e.g. the range of an identifier.</haxe_doc>
	</typedef>
	<abstract path="languageServerProtocol.CodeActionKind" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<haxe_doc>The kind of a code action.

	Kinds are a hierarchical list of identifiers separated by `.`, e.g. `"refactor.extract.function"`.

	The set of kinds is open and client needs to announce the kinds it supports to the server during
	initialization.

	This enum has a set of predefined code action kinds.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="languageServerProtocol._Types.CodeActionKind_Impl_" params="" file="src/languageServerProtocol/Types.hx" private="1" module="languageServerProtocol.Types" extern="1" final="1">
	<Empty public="1" get="inline" set="null" expr="cast &quot;&quot;" line="1548" static="1">
		<x path="languageServerProtocol.CodeActionKind"/>
		<meta>
			<m n=":value"><e>cast ""</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Empty kind.</haxe_doc>
	</Empty>
	<QuickFix public="1" get="inline" set="null" expr="cast &quot;quickfix&quot;" line="1553" static="1">
		<x path="languageServerProtocol.CodeActionKind"/>
		<meta>
			<m n=":value"><e>cast "quickfix"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Base kind for quickfix actions: 'quickfix'</haxe_doc>
	</QuickFix>
	<Refactor public="1" get="inline" set="null" expr="cast &quot;refactor&quot;" line="1558" static="1">
		<x path="languageServerProtocol.CodeActionKind"/>
		<meta>
			<m n=":value"><e>cast "refactor"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Base kind for refactoring actions: 'refactor'</haxe_doc>
	</Refactor>
	<RefactorExtract public="1" get="inline" set="null" expr="cast &quot;refactor.extract&quot;" line="1571" static="1">
		<x path="languageServerProtocol.CodeActionKind"/>
		<meta>
			<m n=":value"><e>cast "refactor.extract"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Base kind for refactoring extraction actions: 'refactor.extract'

		Example extract actions:

		- Extract method
		- Extract function
		- Extract variable
		- Extract interface from class
		- ...</haxe_doc>
	</RefactorExtract>
	<RefactorInline public="1" get="inline" set="null" expr="cast &quot;refactor.inline&quot;" line="1583" static="1">
		<x path="languageServerProtocol.CodeActionKind"/>
		<meta>
			<m n=":value"><e>cast "refactor.inline"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Base kind for refactoring inline actions: 'refactor.inline'

		Example inline actions:

		- Inline function
		- Inline variable
		- Inline constant
		- ...</haxe_doc>
	</RefactorInline>
	<RefactorRewrite public="1" get="inline" set="null" expr="cast &quot;refactor.rewrite&quot;" line="1597" static="1">
		<x path="languageServerProtocol.CodeActionKind"/>
		<meta>
			<m n=":value"><e>cast "refactor.rewrite"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Base kind for refactoring rewrite actions: 'refactor.rewrite'

		Example rewrite actions:

		- Convert JavaScript function to class
		- Add or remove parameter
		- Encapsulate field
		- Make method static
		- Move method to base class
		- ...</haxe_doc>
	</RefactorRewrite>
	<Source public="1" get="inline" set="null" expr="cast &quot;source&quot;" line="1604" static="1">
		<x path="languageServerProtocol.CodeActionKind"/>
		<meta>
			<m n=":value"><e>cast "source"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Base kind for source actions: `source`

		Source code actions apply to the entire file.</haxe_doc>
	</Source>
	<SourceOrganizeImports public="1" get="inline" set="null" expr="cast &quot;source.organizeImports&quot;" line="1609" static="1">
		<x path="languageServerProtocol.CodeActionKind"/>
		<meta>
			<m n=":value"><e>cast "source.organizeImports"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Base kind for an organize imports source action: `source.organizeImports`</haxe_doc>
	</SourceOrganizeImports>
	<SourceFixAll public="1" get="inline" set="null" expr="cast &quot;source.fixAll&quot;" line="1619" static="1">
		<x path="languageServerProtocol.CodeActionKind"/>
		<meta>
			<m n=":value"><e>cast "source.fixAll"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Base kind for auto-fix source actions: `source.fixAll`.

		Fix all actions automatically fix errors that have a clear fix that do not require user input.
		They should not suppress errors or perform unsafe fixes such as generating new types or classes.

		@since 3.15.0</haxe_doc>
	</SourceFixAll>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="languageServerProtocol._Types.CodeActionKind_Impl_" params="" file="src/languageServerProtocol/Types.hx" private="1" module="languageServerProtocol.Types" extern="1" final="1">
		<Empty public="1" get="inline" set="null" expr="cast &quot;&quot;" line="1548" static="1">
			<x path="languageServerProtocol.CodeActionKind"/>
			<meta>
				<m n=":value"><e>cast ""</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Empty kind.</haxe_doc>
		</Empty>
		<QuickFix public="1" get="inline" set="null" expr="cast &quot;quickfix&quot;" line="1553" static="1">
			<x path="languageServerProtocol.CodeActionKind"/>
			<meta>
				<m n=":value"><e>cast "quickfix"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Base kind for quickfix actions: 'quickfix'</haxe_doc>
		</QuickFix>
		<Refactor public="1" get="inline" set="null" expr="cast &quot;refactor&quot;" line="1558" static="1">
			<x path="languageServerProtocol.CodeActionKind"/>
			<meta>
				<m n=":value"><e>cast "refactor"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Base kind for refactoring actions: 'refactor'</haxe_doc>
		</Refactor>
		<RefactorExtract public="1" get="inline" set="null" expr="cast &quot;refactor.extract&quot;" line="1571" static="1">
			<x path="languageServerProtocol.CodeActionKind"/>
			<meta>
				<m n=":value"><e>cast "refactor.extract"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Base kind for refactoring extraction actions: 'refactor.extract'

		Example extract actions:

		- Extract method
		- Extract function
		- Extract variable
		- Extract interface from class
		- ...</haxe_doc>
		</RefactorExtract>
		<RefactorInline public="1" get="inline" set="null" expr="cast &quot;refactor.inline&quot;" line="1583" static="1">
			<x path="languageServerProtocol.CodeActionKind"/>
			<meta>
				<m n=":value"><e>cast "refactor.inline"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Base kind for refactoring inline actions: 'refactor.inline'

		Example inline actions:

		- Inline function
		- Inline variable
		- Inline constant
		- ...</haxe_doc>
		</RefactorInline>
		<RefactorRewrite public="1" get="inline" set="null" expr="cast &quot;refactor.rewrite&quot;" line="1597" static="1">
			<x path="languageServerProtocol.CodeActionKind"/>
			<meta>
				<m n=":value"><e>cast "refactor.rewrite"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Base kind for refactoring rewrite actions: 'refactor.rewrite'

		Example rewrite actions:

		- Convert JavaScript function to class
		- Add or remove parameter
		- Encapsulate field
		- Make method static
		- Move method to base class
		- ...</haxe_doc>
		</RefactorRewrite>
		<Source public="1" get="inline" set="null" expr="cast &quot;source&quot;" line="1604" static="1">
			<x path="languageServerProtocol.CodeActionKind"/>
			<meta>
				<m n=":value"><e>cast "source"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Base kind for source actions: `source`

		Source code actions apply to the entire file.</haxe_doc>
		</Source>
		<SourceOrganizeImports public="1" get="inline" set="null" expr="cast &quot;source.organizeImports&quot;" line="1609" static="1">
			<x path="languageServerProtocol.CodeActionKind"/>
			<meta>
				<m n=":value"><e>cast "source.organizeImports"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Base kind for an organize imports source action: `source.organizeImports`</haxe_doc>
		</SourceOrganizeImports>
		<SourceFixAll public="1" get="inline" set="null" expr="cast &quot;source.fixAll&quot;" line="1619" static="1">
			<x path="languageServerProtocol.CodeActionKind"/>
			<meta>
				<m n=":value"><e>cast "source.fixAll"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Base kind for auto-fix source actions: `source.fixAll`.

		Fix all actions automatically fix errors that have a clear fix that do not require user input.
		They should not suppress errors or perform unsafe fixes such as generating new types or classes.

		@since 3.15.0</haxe_doc>
		</SourceFixAll>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="languageServerProtocol.CodeActionTriggerKind" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<this><x path="Int"/></this>
		<haxe_doc>The reason why code actions were requested.

	@since 3.17.0
	@proposed</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="languageServerProtocol._Types.CodeActionTriggerKind_Impl_" params="" file="src/languageServerProtocol/Types.hx" private="1" module="languageServerProtocol.Types" extern="1" final="1">
	<Invoked public="1" get="inline" set="null" expr="cast 1" line="1632" static="1">
		<x path="languageServerProtocol.CodeActionTriggerKind"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Code actions were explicitly requested by the user or by an extension.</haxe_doc>
	</Invoked>
	<Automatic public="1" get="inline" set="null" expr="cast 2" line="1640" static="1">
		<x path="languageServerProtocol.CodeActionTriggerKind"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Code actions were requested automatically.

		This typically happens when current selection in a file changes, but can
		also be triggered when file content changes.</haxe_doc>
	</Automatic>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="languageServerProtocol._Types.CodeActionTriggerKind_Impl_" params="" file="src/languageServerProtocol/Types.hx" private="1" module="languageServerProtocol.Types" extern="1" final="1">
		<Invoked public="1" get="inline" set="null" expr="cast 1" line="1632" static="1">
			<x path="languageServerProtocol.CodeActionTriggerKind"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Code actions were explicitly requested by the user or by an extension.</haxe_doc>
		</Invoked>
		<Automatic public="1" get="inline" set="null" expr="cast 2" line="1640" static="1">
			<x path="languageServerProtocol.CodeActionTriggerKind"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Code actions were requested automatically.

		This typically happens when current selection in a file changes, but can
		also be triggered when file content changes.</haxe_doc>
		</Automatic>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="languageServerProtocol.CodeActionContext" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<triggerKind>
				<x path="Null"><x path="languageServerProtocol.CodeActionTriggerKind"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The reason why code actions were requested.

		@since 3.17.0</haxe_doc>
			</triggerKind>
			<only>
				<x path="Null"><c path="Array"><x path="languageServerProtocol.CodeActionKind"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Requested kind of actions to return.

		Actions not of this kind are filtered out by the client before being shown. So servers
		can omit computing them.</haxe_doc>
			</only>
			<diagnostics>
				<c path="Array"><t path="languageServerProtocol.Diagnostic"/></c>
				<haxe_doc>An array of diagnostics known on the client side overlapping the range provided to the
		`textDocument/codeAction` request. They are provied so that the server knows which
		errors are currently presented to the user for the given range. There is no guarantee
		that these accurately reflect the error state of the resource. The primary parameter
		to compute code actions is the provided range.</haxe_doc>
			</diagnostics>
		</a>
		<haxe_doc>Contains additional diagnostic information about the context in which a code action is run.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.CodeAction" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<title>
				<c path="String"/>
				<haxe_doc>A short, human-readable, title for this code action.</haxe_doc>
			</title>
			<kind>
				<x path="Null"><x path="languageServerProtocol.CodeActionKind"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The kind of the code action.

		Used to filter code actions.</haxe_doc>
			</kind>
			<isPreferred>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Marks this as a preferred action. Preferred actions are used by the `auto fix` command and can be targeted
		by keybindings.

		A quick fix should be marked preferred if it properly addresses the underlying error.
		A refactoring should be marked preferred if it is the most reasonable choice of actions to take.

		@since 3.15.0</haxe_doc>
			</isPreferred>
			<edit>
				<x path="Null"><t path="languageServerProtocol.WorkspaceEdit"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The workspace edit this code action performs.</haxe_doc>
			</edit>
			<disabled>
				<x path="Null"><a><reason>
	<c path="String"/>
	<haxe_doc>Human readable description of why the code action is currently disabled.

			This is displayed in the code actions UI.</haxe_doc>
</reason></a></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Marks that the code action cannot currently be applied.

		Clients should follow the following guidelines regarding disabled code actions:

		  - Disabled code actions are not shown in automatic [lightbulb](https://code.visualstudio.com/docs/editor/editingevolved#_code-action)
			code action menu.

		  - Disabled actions are shown as faded out in the code action menu when the user request a more specific type
			of code action, such as refactorings.

		  - If the user has a [keybinding](https://code.visualstudio.com/docs/editor/refactoring#_keybindings-for-code-actions)
			that auto applies a code action and only a disabled code actions are returned, the client should show the user an
			error message with `reason` in the editor.

		@since 3.16.0</haxe_doc>
			</disabled>
			<diagnostics>
				<x path="Null"><c path="Array"><t path="languageServerProtocol.Diagnostic"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The diagnostics that this code action resolves.</haxe_doc>
			</diagnostics>
			<data>
				<x path="Null"><t path="languageServerProtocol.LSPAny"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>A data entry field that is preserved on a code action between
		a `textDocument/codeAction` and a `codeAction/resolve` request.

		@since 3.16.0</haxe_doc>
			</data>
			<command>
				<x path="Null"><t path="languageServerProtocol.Command"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>A command this code action executes. If a code action
		provides a edit and a command, first the edit is
		executed and then the command.</haxe_doc>
			</command>
		</a>
		<haxe_doc>A code action represents a change that can be performed in code, e.g. to fix a problem or
	to refactor code.

	A CodeAction must set either `edit` and/or a `command`. If both are supplied, the `edit` is applied first, then the `command` is executed.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.CodeLens" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<range>
				<t path="languageServerProtocol.textdocument.Range"/>
				<haxe_doc>The range in which this code lens is valid.
		Should only span a single line.</haxe_doc>
			</range>
			<data>
				<x path="Null"><t path="languageServerProtocol.LSPAny"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An data entry field that is preserved on a code lens item between a code lens and a code lens resolve request.</haxe_doc>
			</data>
			<command>
				<x path="Null"><t path="languageServerProtocol.Command"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The command this code lens represents.</haxe_doc>
			</command>
		</a>
		<haxe_doc>A code lens represents a command that should be shown along with source text,
	like the number of references, a way to run tests, etc.

	A code lens is _unresolved_ when no command is associated to it.
	For performance reasons the creation of a code lens and resolving should be done to two stages.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.FormattingOptions" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<trimTrailingWhitespace>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Trim trailing whitespaces on a line.

		@since 3.15.0</haxe_doc>
			</trimTrailingWhitespace>
			<trimFinalNewlines>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Trim all newlines after the final newline at the end of the file.

		@since 3.15.0</haxe_doc>
			</trimFinalNewlines>
			<tabSize>
				<x path="Int"/>
				<haxe_doc>Size of a tab in spaces.</haxe_doc>
			</tabSize>
			<insertSpaces>
				<x path="Bool"/>
				<haxe_doc>Prefer spaces over tabs.</haxe_doc>
			</insertSpaces>
			<insertFinalNewline>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Insert a newline character at the end of the file if one does not exist.

		@since 3.15.0</haxe_doc>
			</insertFinalNewline>
		</a>
		<haxe_doc>Value-object describing what options formatting should use.
	This object can contain additional fields of type Bool/Int/Float/String.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.DocumentLink" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<tooltip>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The tooltip text when you hover over this link.

		If a tooltip is provided, is will be displayed in a string that includes instructions on how to
		trigger the link, such as `{0} (ctrl + click)`. The specific instructions vary depending on OS,
		user settings, and localization.

		@since 3.15.0</haxe_doc>
			</tooltip>
			<target>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The uri this link points to. If missing a resolve request is sent later.</haxe_doc>
			</target>
			<range>
				<t path="languageServerProtocol.textdocument.Range"/>
				<haxe_doc>The range this link applies to.</haxe_doc>
			</range>
			<data>
				<x path="Null"><t path="languageServerProtocol.LSPAny"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>A data entry field that is preserved on a document link between a
		DocumentLinkRequest and a DocumentLinkResolveRequest.</haxe_doc>
			</data>
		</a>
		<haxe_doc>A document link is a range in a text document that links to an internal or external resource, like another
	text document or a web site.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.SelectionRange" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<range>
				<t path="languageServerProtocol.textdocument.Range"/>
				<haxe_doc>The [range](#Range) of this selection range.</haxe_doc>
			</range>
			<parent>
				<x path="Null"><t path="languageServerProtocol.SelectionRange"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The parent selection range containing this range. Therefore `parent.range` must contain `this.range`.</haxe_doc>
			</parent>
		</a>
		<haxe_doc>A selection range represents a part of a selection hierarchy. A selection range
	may have a parent selection range that contains it.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.CallHierarchyItem" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<uri>
				<x path="Null"><x path="languageServerProtocol.textdocument.DocumentUri"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The resource identifier of this item.</haxe_doc>
			</uri>
			<tags>
				<x path="Null"><c path="Array"><x path="languageServerProtocol.SymbolTag"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Tags for this item.</haxe_doc>
			</tags>
			<selectionRange>
				<x path="Null"><t path="languageServerProtocol.textdocument.Range"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The range that should be selected and revealed when this symbol is being picked, e.g. the name of a function.
		Must be contained by the [`range`](#CallHierarchyItem.range).</haxe_doc>
			</selectionRange>
			<range>
				<x path="Null"><t path="languageServerProtocol.textdocument.Range"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The range enclosing this symbol not including leading/trailing whitespace but everything else, e.g. comments and code.</haxe_doc>
			</range>
			<name>
				<c path="String"/>
				<haxe_doc>The name of this item.</haxe_doc>
			</name>
			<kind>
				<x path="languageServerProtocol.SymbolKind"/>
				<haxe_doc>The kind of this item.</haxe_doc>
			</kind>
			<etail>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>More detail for this item, e.g. the signature of a function.</haxe_doc>
			</etail>
			<data>
				<x path="Null"><t path="languageServerProtocol.LSPAny"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>A data entry field that is preserved between a call hierarchy prepare and
		incoming calls or outgoing calls requests.</haxe_doc>
			</data>
		</a>
		<haxe_doc>Represents programming constructs like functions or constructors in the context
	of call hierarchy.

	@since 3.16.0</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.CallHierarchyIncomingCall" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<fromRanges>
				<c path="Array"><t path="languageServerProtocol.textdocument.Range"/></c>
				<haxe_doc>The ranges at which the calls appear. This is relative to the caller
		denoted by [`this.from`](#CallHierarchyIncomingCall.from).</haxe_doc>
			</fromRanges>
			<from>
				<t path="languageServerProtocol.CallHierarchyItem"/>
				<haxe_doc>The item that makes the call.</haxe_doc>
			</from>
		</a>
		<haxe_doc>Represents an incoming call, e.g. a caller of a method or constructor.

	@since 3.16.0</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.CallHierarchyOutgoingCall" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<to>
				<t path="languageServerProtocol.CallHierarchyItem"/>
				<haxe_doc>The item that is called.</haxe_doc>
			</to>
			<fromRanges>
				<c path="Array"><t path="languageServerProtocol.textdocument.Range"/></c>
				<haxe_doc>The range at which this item is called. This is the range relative to the caller, e.g the item
		passed to [`provideCallHierarchyOutgoingCalls`](#CallHierarchyItemProvider.provideCallHierarchyOutgoingCalls)
		and not [`this.to`](#CallHierarchyOutgoingCall.to).</haxe_doc>
			</fromRanges>
		</a>
		<haxe_doc>Represents an outgoing call, e.g. calling a getter from a method or a method from a constructor etc.

	@since 3.16.0</haxe_doc>
	</typedef>
	<abstract path="languageServerProtocol.SemanticTokenTypes" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<this><c path="String"/></this>
		<haxe_doc>A set of predefined token types. This set is not fixed
	an clients can specify additional token types via the
	corresponding client capabilities.

	@since 3.16.0</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="languageServerProtocol._Types.SemanticTokenTypes_Impl_" params="" file="src/languageServerProtocol/Types.hx" private="1" module="languageServerProtocol.Types" extern="1" final="1">
	<namespace public="1" get="inline" set="null" expr="cast &quot;namespace&quot;" line="1960" static="1">
		<x path="languageServerProtocol.SemanticTokenTypes"/>
		<meta>
			<m n=":value"><e>cast "namespace"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</namespace>
	<Type public="1" get="inline" set="null" expr="cast &quot;type&quot;" line="1966" static="1">
		<x path="languageServerProtocol.SemanticTokenTypes"/>
		<meta>
			<m n=":value"><e>cast "type"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Represents a generic type. Acts as a fallback for types which can't be mapped to
		a specific type like class or enum.</haxe_doc>
	</Type>
	<Class public="1" get="inline" set="null" expr="cast &quot;class&quot;" line="1968" static="1">
		<x path="languageServerProtocol.SemanticTokenTypes"/>
		<meta>
			<m n=":value"><e>cast "class"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Class>
	<Enum public="1" get="inline" set="null" expr="cast &quot;enum&quot;" line="1969" static="1">
		<x path="languageServerProtocol.SemanticTokenTypes"/>
		<meta>
			<m n=":value"><e>cast "enum"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Enum>
	<Interface public="1" get="inline" set="null" expr="cast &quot;interface&quot;" line="1970" static="1">
		<x path="languageServerProtocol.SemanticTokenTypes"/>
		<meta>
			<m n=":value"><e>cast "interface"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Interface>
	<Struct public="1" get="inline" set="null" expr="cast &quot;struct&quot;" line="1971" static="1">
		<x path="languageServerProtocol.SemanticTokenTypes"/>
		<meta>
			<m n=":value"><e>cast "struct"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Struct>
	<TypeParameter public="1" get="inline" set="null" expr="cast &quot;typeParameter&quot;" line="1972" static="1">
		<x path="languageServerProtocol.SemanticTokenTypes"/>
		<meta>
			<m n=":value"><e>cast "typeParameter"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</TypeParameter>
	<Parameter public="1" get="inline" set="null" expr="cast &quot;parameter&quot;" line="1973" static="1">
		<x path="languageServerProtocol.SemanticTokenTypes"/>
		<meta>
			<m n=":value"><e>cast "parameter"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Parameter>
	<Variable public="1" get="inline" set="null" expr="cast &quot;variable&quot;" line="1974" static="1">
		<x path="languageServerProtocol.SemanticTokenTypes"/>
		<meta>
			<m n=":value"><e>cast "variable"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Variable>
	<Property public="1" get="inline" set="null" expr="cast &quot;property&quot;" line="1975" static="1">
		<x path="languageServerProtocol.SemanticTokenTypes"/>
		<meta>
			<m n=":value"><e>cast "property"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Property>
	<EnumMember public="1" get="inline" set="null" expr="cast &quot;enumMember&quot;" line="1976" static="1">
		<x path="languageServerProtocol.SemanticTokenTypes"/>
		<meta>
			<m n=":value"><e>cast "enumMember"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</EnumMember>
	<Event public="1" get="inline" set="null" expr="cast &quot;event&quot;" line="1977" static="1">
		<x path="languageServerProtocol.SemanticTokenTypes"/>
		<meta>
			<m n=":value"><e>cast "event"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Event>
	<Function public="1" get="inline" set="null" expr="cast &quot;function&quot;" line="1978" static="1">
		<x path="languageServerProtocol.SemanticTokenTypes"/>
		<meta>
			<m n=":value"><e>cast "function"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Function>
	<Method public="1" get="inline" set="null" expr="cast &quot;method&quot;" line="1979" static="1">
		<x path="languageServerProtocol.SemanticTokenTypes"/>
		<meta>
			<m n=":value"><e>cast "method"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Method>
	<Macro public="1" get="inline" set="null" expr="cast &quot;macro&quot;" line="1980" static="1">
		<x path="languageServerProtocol.SemanticTokenTypes"/>
		<meta>
			<m n=":value"><e>cast "macro"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Macro>
	<Keyword public="1" get="inline" set="null" expr="cast &quot;keyword&quot;" line="1981" static="1">
		<x path="languageServerProtocol.SemanticTokenTypes"/>
		<meta>
			<m n=":value"><e>cast "keyword"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Keyword>
	<Modifier public="1" get="inline" set="null" expr="cast &quot;modifier&quot;" line="1982" static="1">
		<x path="languageServerProtocol.SemanticTokenTypes"/>
		<meta>
			<m n=":value"><e>cast "modifier"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Modifier>
	<Comment public="1" get="inline" set="null" expr="cast &quot;comment&quot;" line="1983" static="1">
		<x path="languageServerProtocol.SemanticTokenTypes"/>
		<meta>
			<m n=":value"><e>cast "comment"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Comment>
	<StringToken public="1" get="inline" set="null" expr="cast &quot;string&quot;" line="1984" static="1">
		<x path="languageServerProtocol.SemanticTokenTypes"/>
		<meta>
			<m n=":value"><e>cast "string"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</StringToken>
	<Number public="1" get="inline" set="null" expr="cast &quot;number&quot;" line="1985" static="1">
		<x path="languageServerProtocol.SemanticTokenTypes"/>
		<meta>
			<m n=":value"><e>cast "number"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Number>
	<Regexp public="1" get="inline" set="null" expr="cast &quot;regexp&quot;" line="1986" static="1">
		<x path="languageServerProtocol.SemanticTokenTypes"/>
		<meta>
			<m n=":value"><e>cast "regexp"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Regexp>
	<Operator public="1" get="inline" set="null" expr="cast &quot;operator&quot;" line="1987" static="1">
		<x path="languageServerProtocol.SemanticTokenTypes"/>
		<meta>
			<m n=":value"><e>cast "operator"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Operator>
	<Decorator public="1" get="inline" set="null" expr="cast &quot;decorator&quot;" line="1992" static="1">
		<x path="languageServerProtocol.SemanticTokenTypes"/>
		<meta>
			<m n=":value"><e>cast "decorator"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>@since 3.17.0</haxe_doc>
	</Decorator>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="languageServerProtocol._Types.SemanticTokenTypes_Impl_" params="" file="src/languageServerProtocol/Types.hx" private="1" module="languageServerProtocol.Types" extern="1" final="1">
		<namespace public="1" get="inline" set="null" expr="cast &quot;namespace&quot;" line="1960" static="1">
			<x path="languageServerProtocol.SemanticTokenTypes"/>
			<meta>
				<m n=":value"><e>cast "namespace"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</namespace>
		<Type public="1" get="inline" set="null" expr="cast &quot;type&quot;" line="1966" static="1">
			<x path="languageServerProtocol.SemanticTokenTypes"/>
			<meta>
				<m n=":value"><e>cast "type"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Represents a generic type. Acts as a fallback for types which can't be mapped to
		a specific type like class or enum.</haxe_doc>
		</Type>
		<Class public="1" get="inline" set="null" expr="cast &quot;class&quot;" line="1968" static="1">
			<x path="languageServerProtocol.SemanticTokenTypes"/>
			<meta>
				<m n=":value"><e>cast "class"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Class>
		<Enum public="1" get="inline" set="null" expr="cast &quot;enum&quot;" line="1969" static="1">
			<x path="languageServerProtocol.SemanticTokenTypes"/>
			<meta>
				<m n=":value"><e>cast "enum"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Enum>
		<Interface public="1" get="inline" set="null" expr="cast &quot;interface&quot;" line="1970" static="1">
			<x path="languageServerProtocol.SemanticTokenTypes"/>
			<meta>
				<m n=":value"><e>cast "interface"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Interface>
		<Struct public="1" get="inline" set="null" expr="cast &quot;struct&quot;" line="1971" static="1">
			<x path="languageServerProtocol.SemanticTokenTypes"/>
			<meta>
				<m n=":value"><e>cast "struct"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Struct>
		<TypeParameter public="1" get="inline" set="null" expr="cast &quot;typeParameter&quot;" line="1972" static="1">
			<x path="languageServerProtocol.SemanticTokenTypes"/>
			<meta>
				<m n=":value"><e>cast "typeParameter"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</TypeParameter>
		<Parameter public="1" get="inline" set="null" expr="cast &quot;parameter&quot;" line="1973" static="1">
			<x path="languageServerProtocol.SemanticTokenTypes"/>
			<meta>
				<m n=":value"><e>cast "parameter"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Parameter>
		<Variable public="1" get="inline" set="null" expr="cast &quot;variable&quot;" line="1974" static="1">
			<x path="languageServerProtocol.SemanticTokenTypes"/>
			<meta>
				<m n=":value"><e>cast "variable"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Variable>
		<Property public="1" get="inline" set="null" expr="cast &quot;property&quot;" line="1975" static="1">
			<x path="languageServerProtocol.SemanticTokenTypes"/>
			<meta>
				<m n=":value"><e>cast "property"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Property>
		<EnumMember public="1" get="inline" set="null" expr="cast &quot;enumMember&quot;" line="1976" static="1">
			<x path="languageServerProtocol.SemanticTokenTypes"/>
			<meta>
				<m n=":value"><e>cast "enumMember"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</EnumMember>
		<Event public="1" get="inline" set="null" expr="cast &quot;event&quot;" line="1977" static="1">
			<x path="languageServerProtocol.SemanticTokenTypes"/>
			<meta>
				<m n=":value"><e>cast "event"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Event>
		<Function public="1" get="inline" set="null" expr="cast &quot;function&quot;" line="1978" static="1">
			<x path="languageServerProtocol.SemanticTokenTypes"/>
			<meta>
				<m n=":value"><e>cast "function"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Function>
		<Method public="1" get="inline" set="null" expr="cast &quot;method&quot;" line="1979" static="1">
			<x path="languageServerProtocol.SemanticTokenTypes"/>
			<meta>
				<m n=":value"><e>cast "method"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Method>
		<Macro public="1" get="inline" set="null" expr="cast &quot;macro&quot;" line="1980" static="1">
			<x path="languageServerProtocol.SemanticTokenTypes"/>
			<meta>
				<m n=":value"><e>cast "macro"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Macro>
		<Keyword public="1" get="inline" set="null" expr="cast &quot;keyword&quot;" line="1981" static="1">
			<x path="languageServerProtocol.SemanticTokenTypes"/>
			<meta>
				<m n=":value"><e>cast "keyword"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Keyword>
		<Modifier public="1" get="inline" set="null" expr="cast &quot;modifier&quot;" line="1982" static="1">
			<x path="languageServerProtocol.SemanticTokenTypes"/>
			<meta>
				<m n=":value"><e>cast "modifier"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Modifier>
		<Comment public="1" get="inline" set="null" expr="cast &quot;comment&quot;" line="1983" static="1">
			<x path="languageServerProtocol.SemanticTokenTypes"/>
			<meta>
				<m n=":value"><e>cast "comment"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Comment>
		<StringToken public="1" get="inline" set="null" expr="cast &quot;string&quot;" line="1984" static="1">
			<x path="languageServerProtocol.SemanticTokenTypes"/>
			<meta>
				<m n=":value"><e>cast "string"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</StringToken>
		<Number public="1" get="inline" set="null" expr="cast &quot;number&quot;" line="1985" static="1">
			<x path="languageServerProtocol.SemanticTokenTypes"/>
			<meta>
				<m n=":value"><e>cast "number"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Number>
		<Regexp public="1" get="inline" set="null" expr="cast &quot;regexp&quot;" line="1986" static="1">
			<x path="languageServerProtocol.SemanticTokenTypes"/>
			<meta>
				<m n=":value"><e>cast "regexp"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Regexp>
		<Operator public="1" get="inline" set="null" expr="cast &quot;operator&quot;" line="1987" static="1">
			<x path="languageServerProtocol.SemanticTokenTypes"/>
			<meta>
				<m n=":value"><e>cast "operator"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Operator>
		<Decorator public="1" get="inline" set="null" expr="cast &quot;decorator&quot;" line="1992" static="1">
			<x path="languageServerProtocol.SemanticTokenTypes"/>
			<meta>
				<m n=":value"><e>cast "decorator"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>@since 3.17.0</haxe_doc>
		</Decorator>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="languageServerProtocol.SemanticTokenModifiers" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<this><c path="String"/></this>
		<haxe_doc>A set of predefined token modifiers. This set is not fixed
	an clients can specify additional token types via the
	corresponding client capabilities.

	@since 3.16.0</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="languageServerProtocol._Types.SemanticTokenModifiers_Impl_" params="" file="src/languageServerProtocol/Types.hx" private="1" module="languageServerProtocol.Types" extern="1" final="1">
	<Declaration public="1" get="inline" set="null" expr="cast &quot;declaration&quot;" line="2003" static="1">
		<x path="languageServerProtocol.SemanticTokenModifiers"/>
		<meta>
			<m n=":value"><e>cast "declaration"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Declaration>
	<Definition public="1" get="inline" set="null" expr="cast &quot;definition&quot;" line="2004" static="1">
		<x path="languageServerProtocol.SemanticTokenModifiers"/>
		<meta>
			<m n=":value"><e>cast "definition"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Definition>
	<Readonly public="1" get="inline" set="null" expr="cast &quot;readonly&quot;" line="2005" static="1">
		<x path="languageServerProtocol.SemanticTokenModifiers"/>
		<meta>
			<m n=":value"><e>cast "readonly"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Readonly>
	<Static public="1" get="inline" set="null" expr="cast &quot;static&quot;" line="2006" static="1">
		<x path="languageServerProtocol.SemanticTokenModifiers"/>
		<meta>
			<m n=":value"><e>cast "static"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Static>
	<Deprecated public="1" get="inline" set="null" expr="cast &quot;deprecated&quot;" line="2007" static="1">
		<x path="languageServerProtocol.SemanticTokenModifiers"/>
		<meta>
			<m n=":value"><e>cast "deprecated"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Deprecated>
	<Abstract public="1" get="inline" set="null" expr="cast &quot;abstract&quot;" line="2008" static="1">
		<x path="languageServerProtocol.SemanticTokenModifiers"/>
		<meta>
			<m n=":value"><e>cast "abstract"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Abstract>
	<Async public="1" get="inline" set="null" expr="cast &quot;async&quot;" line="2009" static="1">
		<x path="languageServerProtocol.SemanticTokenModifiers"/>
		<meta>
			<m n=":value"><e>cast "async"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Async>
	<Modification public="1" get="inline" set="null" expr="cast &quot;modification&quot;" line="2010" static="1">
		<x path="languageServerProtocol.SemanticTokenModifiers"/>
		<meta>
			<m n=":value"><e>cast "modification"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Modification>
	<Documentation public="1" get="inline" set="null" expr="cast &quot;documentation&quot;" line="2011" static="1">
		<x path="languageServerProtocol.SemanticTokenModifiers"/>
		<meta>
			<m n=":value"><e>cast "documentation"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Documentation>
	<DefaultLibrary public="1" get="inline" set="null" expr="cast &quot;defaultLibrary&quot;" line="2012" static="1">
		<x path="languageServerProtocol.SemanticTokenModifiers"/>
		<meta>
			<m n=":value"><e>cast "defaultLibrary"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DefaultLibrary>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="languageServerProtocol._Types.SemanticTokenModifiers_Impl_" params="" file="src/languageServerProtocol/Types.hx" private="1" module="languageServerProtocol.Types" extern="1" final="1">
		<Declaration public="1" get="inline" set="null" expr="cast &quot;declaration&quot;" line="2003" static="1">
			<x path="languageServerProtocol.SemanticTokenModifiers"/>
			<meta>
				<m n=":value"><e>cast "declaration"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Declaration>
		<Definition public="1" get="inline" set="null" expr="cast &quot;definition&quot;" line="2004" static="1">
			<x path="languageServerProtocol.SemanticTokenModifiers"/>
			<meta>
				<m n=":value"><e>cast "definition"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Definition>
		<Readonly public="1" get="inline" set="null" expr="cast &quot;readonly&quot;" line="2005" static="1">
			<x path="languageServerProtocol.SemanticTokenModifiers"/>
			<meta>
				<m n=":value"><e>cast "readonly"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Readonly>
		<Static public="1" get="inline" set="null" expr="cast &quot;static&quot;" line="2006" static="1">
			<x path="languageServerProtocol.SemanticTokenModifiers"/>
			<meta>
				<m n=":value"><e>cast "static"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Static>
		<Deprecated public="1" get="inline" set="null" expr="cast &quot;deprecated&quot;" line="2007" static="1">
			<x path="languageServerProtocol.SemanticTokenModifiers"/>
			<meta>
				<m n=":value"><e>cast "deprecated"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Deprecated>
		<Abstract public="1" get="inline" set="null" expr="cast &quot;abstract&quot;" line="2008" static="1">
			<x path="languageServerProtocol.SemanticTokenModifiers"/>
			<meta>
				<m n=":value"><e>cast "abstract"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Abstract>
		<Async public="1" get="inline" set="null" expr="cast &quot;async&quot;" line="2009" static="1">
			<x path="languageServerProtocol.SemanticTokenModifiers"/>
			<meta>
				<m n=":value"><e>cast "async"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Async>
		<Modification public="1" get="inline" set="null" expr="cast &quot;modification&quot;" line="2010" static="1">
			<x path="languageServerProtocol.SemanticTokenModifiers"/>
			<meta>
				<m n=":value"><e>cast "modification"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Modification>
		<Documentation public="1" get="inline" set="null" expr="cast &quot;documentation&quot;" line="2011" static="1">
			<x path="languageServerProtocol.SemanticTokenModifiers"/>
			<meta>
				<m n=":value"><e>cast "documentation"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Documentation>
		<DefaultLibrary public="1" get="inline" set="null" expr="cast &quot;defaultLibrary&quot;" line="2012" static="1">
			<x path="languageServerProtocol.SemanticTokenModifiers"/>
			<meta>
				<m n=":value"><e>cast "defaultLibrary"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DefaultLibrary>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="languageServerProtocol.SemanticTokensLegend" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<tokenTypes>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The token types a server uses.</haxe_doc>
			</tokenTypes>
			<tokenModifiers>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The token modifiers a server uses.</haxe_doc>
			</tokenModifiers>
		</a>
		<haxe_doc>@since 3.16.0</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.SemanticTokens" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<resultId>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional result id. If provided and clients support delta updating
		the client will include the result id in the next semantic token request.
		A server can then instead of computing all semantic tokens again simply
		send a delta.</haxe_doc>
			</resultId>
			<data>
				<c path="Array"><x path="Int"/></c>
				<haxe_doc>The actual tokens.</haxe_doc>
			</data>
		</a>
		<haxe_doc>@since 3.16.0</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.SemanticTokensEdit" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<start>
				<x path="Int"/>
				<haxe_doc>The start offset of the edit.</haxe_doc>
			</start>
			<deleteCount>
				<x path="Int"/>
				<haxe_doc>The count of elements to remove.</haxe_doc>
			</deleteCount>
			<data>
				<x path="Null"><c path="Array"><x path="Int"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The elements to insert.</haxe_doc>
			</data>
		</a>
		<haxe_doc>@since 3.16.0</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.SemanticTokensDelta" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<resultId>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
			</resultId>
			<edits>
				<x path="Null"><c path="Array"><t path="languageServerProtocol.SemanticTokensEdit"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The semantic token edits to transform a previous result into a new result.</haxe_doc>
			</edits>
		</a>
		<haxe_doc>@since 3.16.0</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.TypeHierarchyItem" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<uri>
				<x path="languageServerProtocol.textdocument.DocumentUri"/>
				<haxe_doc>The resource identifier of this item.</haxe_doc>
			</uri>
			<tags>
				<x path="Null"><c path="Array"><x path="languageServerProtocol.SymbolTag"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Tags for this item.</haxe_doc>
			</tags>
			<selectionRange>
				<t path="languageServerProtocol.textdocument.Range"/>
				<haxe_doc>The range that should be selected and revealed when this symbol is being
		picked, e.g. the name of a function. Must be contained by the
		[`range`](#TypeHierarchyItem.range).</haxe_doc>
			</selectionRange>
			<range>
				<t path="languageServerProtocol.textdocument.Range"/>
				<haxe_doc>The range enclosing this symbol not including leading/trailing whitespace
		but everything else, e.g. comments and code.</haxe_doc>
			</range>
			<name>
				<c path="String"/>
				<haxe_doc>The name of this item.</haxe_doc>
			</name>
			<kind>
				<x path="languageServerProtocol.SymbolKind"/>
				<haxe_doc>The kind of this item.</haxe_doc>
			</kind>
			<detail>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>More detail for this item, e.g. the signature of a function.</haxe_doc>
			</detail>
			<data>
				<x path="Null"><t path="languageServerProtocol.LSPAny"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>A data entry field that is preserved between a type hierarchy prepare and
		supertypes or subtypes requests. It could also be used to identify the
		type hierarchy in the server, helping improve the performance on
		resolving supertypes and subtypes.</haxe_doc>
			</data>
		</a>
		<haxe_doc>@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.InlineValueText" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<text>
				<c path="String"/>
				<haxe_doc>The text of the inline value.</haxe_doc>
			</text>
			<range>
				<t path="languageServerProtocol.textdocument.Range"/>
				<haxe_doc>The document range for which the inline value applies.</haxe_doc>
			</range>
		</a>
		<haxe_doc>Provide inline value as text.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.InlineValueVariableLookup" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<variableName>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>If specified the name of the variable to look up.</haxe_doc>
			</variableName>
			<range>
				<t path="languageServerProtocol.textdocument.Range"/>
				<haxe_doc>The document range for which the inline value applies.
		The range is used to extract the variable name from the underlying document.</haxe_doc>
			</range>
			<caseSensitiveLookup>
				<x path="Bool"/>
				<haxe_doc>How to perform the lookup.</haxe_doc>
			</caseSensitiveLookup>
		</a>
		<haxe_doc>Provide inline value through a variable lookup.
	If only a range is specified, the variable name will be extracted from the underlying document.
	An optional variable name can be used to override the extracted name.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.InlineValueEvaluatableExpression" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<range>
				<t path="languageServerProtocol.textdocument.Range"/>
				<haxe_doc>The document range for which the inline value applies.
		The range is used to extract the evaluatable expression from the underlying document.</haxe_doc>
			</range>
			<expression>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>If specified the expression overrides the extracted expression.</haxe_doc>
			</expression>
		</a>
		<haxe_doc>Provide an inline value through an expression evaluation.
	If only a range is specified, the expression will be extracted from the underlying document.
	An optional expression can be used to override the extracted expression.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.InlineValue" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<x path="haxe.extern.EitherType">
			<t path="languageServerProtocol.InlineValueText"/>
			<x path="haxe.extern.EitherType">
				<t path="languageServerProtocol.InlineValueVariableLookup"/>
				<t path="languageServerProtocol.InlineValueEvaluatableExpression"/>
			</x>
		</x>
		<haxe_doc>Inline value information can be provided by different means:
	- directly as a text value (class InlineValueText).
	- as a name to use for a variable lookup (class InlineValueVariableLookup)
	- as an evaluatable expression (class InlineValueEvaluatableExpression)
	The InlineValue types combines all inline value types into one type.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.InlineValueContext" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<stoppedLocation>
				<t path="languageServerProtocol.textdocument.Range"/>
				<haxe_doc>The document range where execution has stopped.
		Typically the end position of the range denotes the line where the inline values are shown.</haxe_doc>
			</stoppedLocation>
			<frameId>
				<x path="Float"/>
				<haxe_doc>The stack frame (as a DAP Id) where the execution has stopped.</haxe_doc>
			</frameId>
		</a>
		<haxe_doc>@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<abstract path="languageServerProtocol.InlayHintKind" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<this><x path="Int"/></this>
		<haxe_doc>Inlay hint kinds.

	@since 3.17.0
	@proposed</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="languageServerProtocol._Types.InlayHintKind_Impl_" params="" file="src/languageServerProtocol/Types.hx" private="1" module="languageServerProtocol.Types" extern="1" final="1">
	<Type public="1" get="inline" set="null" expr="cast 1" line="2236" static="1">
		<x path="languageServerProtocol.InlayHintKind"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>An inlay hint that for a type annotation.</haxe_doc>
	</Type>
	<Parameter public="1" get="inline" set="null" expr="cast 2" line="2241" static="1">
		<x path="languageServerProtocol.InlayHintKind"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>An inlay hint that is for a parameter.</haxe_doc>
	</Parameter>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="languageServerProtocol._Types.InlayHintKind_Impl_" params="" file="src/languageServerProtocol/Types.hx" private="1" module="languageServerProtocol.Types" extern="1" final="1">
		<Type public="1" get="inline" set="null" expr="cast 1" line="2236" static="1">
			<x path="languageServerProtocol.InlayHintKind"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>An inlay hint that for a type annotation.</haxe_doc>
		</Type>
		<Parameter public="1" get="inline" set="null" expr="cast 2" line="2241" static="1">
			<x path="languageServerProtocol.InlayHintKind"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>An inlay hint that is for a parameter.</haxe_doc>
		</Parameter>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="languageServerProtocol.InlayHintLabelPart" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<value>
				<c path="String"/>
				<haxe_doc>The value of this label part.</haxe_doc>
			</value>
			<tooltip>
				<x path="Null"><x path="haxe.extern.EitherType">
	<c path="String"/>
	<t path="languageServerProtocol.MarkupContent"/>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The tooltip text when you hover over this label part. Depending on
		the client capability `inlayHint.resolveSupport` clients might resolve
		this property late using the resolve request.</haxe_doc>
			</tooltip>
			<location>
				<x path="Null"><t path="languageServerProtocol.Location"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional source code location that represents this
		label part.

		The editor will use this location for the hover and for code navigation
		features: This part will become a clickable link that resolves to the
		definition of the symbol at the given location (not necessarily the
		location itself), it shows the hover that shows at the given location,
		and it shows a context menu with further code navigation commands.

		Depending on the client capability `inlayHint.resolveSupport` clients
		might resolve this property late using the resolve request.</haxe_doc>
			</location>
			<command>
				<x path="Null"><t path="languageServerProtocol.Command"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional command for this label part.

		Depending on the client capability `inlayHint.resolveSupport` clients
		might resolve this property late using the resolve request.</haxe_doc>
			</command>
		</a>
		<haxe_doc>An inlay hint label part allows for interactive and composite labels
	of inlay hints.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.InlayHint" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<tooltip>
				<x path="Null"><x path="haxe.extern.EitherType">
	<c path="String"/>
	<t path="languageServerProtocol.MarkupContent"/>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The tooltip text when you hover over this item.</haxe_doc>
			</tooltip>
			<textEdits>
				<x path="Null"><c path="Array"><t path="languageServerProtocol.textdocument.TextEdit"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Optional text edits that are performed when accepting this inlay hint.

		*Note* that edits are expected to change the document so that the inlay
		hint (or its nearest variant) is now part of the document and the inlay
		hint itself is now obsolete.</haxe_doc>
			</textEdits>
			<position>
				<t path="languageServerProtocol.textdocument.Position"/>
				<haxe_doc>The position of this hint.</haxe_doc>
			</position>
			<paddingRight>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Render padding after the hint.

		Note: Padding should use the editor's background color, not the
		background color of the hint itself. That means padding can be used
		to visually align/separate an inlay hint.</haxe_doc>
			</paddingRight>
			<paddingLeft>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Render padding before the hint.

		Note: Padding should use the editor's background color, not the
		background color of the hint itself. That means padding can be used
		to visually align/separate an inlay hint.</haxe_doc>
			</paddingLeft>
			<label>
				<x path="haxe.extern.EitherType">
					<c path="String"/>
					<c path="Array"><t path="languageServerProtocol.InlayHintLabelPart"/></c>
				</x>
				<haxe_doc>The label of this hint. A human readable string or an array of
		InlayHintLabelPart label parts.

		*Note* that neither the string nor the label part can be empty.</haxe_doc>
			</label>
			<kind>
				<x path="Null"><x path="languageServerProtocol.InlayHintKind"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The kind of this hint. Can be omitted in which case the client
		should fall back to a reasonable default.</haxe_doc>
			</kind>
			<data>
				<x path="Null"><t path="languageServerProtocol.LSPAny"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>A data entry field that is preserved on a inlay hint between
		a `textDocument/inlayHint` and a `inlayHint/resolve` request.</haxe_doc>
			</data>
		</a>
		<haxe_doc>Inlay hint information.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.WorkspaceFolder" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types">
		<a>
			<uri>
				<x path="languageServerProtocol.textdocument.DocumentUri"/>
				<haxe_doc>The associated URI for this workspace folder.</haxe_doc>
			</uri>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the workspace folder. Used to refer to this
		workspace folder in thge user interface.</haxe_doc>
			</name>
		</a>
		<haxe_doc>A workspace folder inside a client.</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.TextDocument" params="" file="src/languageServerProtocol/Types.hx" module="languageServerProtocol.Types" extern="1">
		<uri public="1">
			<x path="languageServerProtocol.textdocument.DocumentUri"/>
			<haxe_doc>The associated URI for this document. Most documents have the __file__-scheme, indicating that they
		represent files on disk. However, some documents may have other schemes indicating that they are not
		available on disk.

		@readonly</haxe_doc>
		</uri>
		<languageId public="1">
			<c path="String"/>
			<haxe_doc>The identifier of the language associated with this document.

		@readonly</haxe_doc>
		</languageId>
		<version public="1">
			<x path="Int"/>
			<haxe_doc>The version number of this document (it will increase after each
		change, including undo/redo).

		@readonly</haxe_doc>
		</version>
		<getText public="1" set="method">
			<f a="?range">
				<x path="Null"><t path="languageServerProtocol.textdocument.Range"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Get the text of this document. A substring can be retrieved by
		providing a range.

		@param range (optional) An range within the document to return.
		If no range is passed, the full content is returned.
		Invalid range positions are adjusted as described in [Position.line](#Position.line)
		and [Position.character](#Position.character).
		If the start range position is greater than the end range position,
		then the effect of getText is as if the two positions were swapped.
		@return The text of this document or a substring of the text if a
				range is provided.</haxe_doc>
		</getText>
		<positionAt public="1" set="method">
			<f a="offset">
				<x path="Int"/>
				<t path="languageServerProtocol.textdocument.Position"/>
			</f>
			<haxe_doc>Converts a zero-based offset to a position.

		@param offset A zero-based offset.
		@return A valid [position](#Position).</haxe_doc>
		</positionAt>
		<offsetAt public="1" set="method">
			<f a="position">
				<t path="languageServerProtocol.textdocument.Position"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Converts the position to a zero-based offset.
		Invalid positions are adjusted as described in [Position.line](#Position.line)
		and [Position.character](#Position.character).

		@param position A position.
		@return A valid zero-based offset.</haxe_doc>
		</offsetAt>
		<lineCount public="1">
			<x path="Int"/>
			<haxe_doc>The number of lines in this document.

		@readonly</haxe_doc>
		</lineCount>
		<haxe_doc>A simple text document. Not to be implemented. The document keeps the content
	as string.</haxe_doc>
		<meta><m n=":deprecated"><e>"Use the text document from the new vscode-languageserver-textdocument package."</e></m></meta>
	</class>
	<typedef path="languageServerProtocol.protocol.CallHierarchyClientCapabilities" params="" file="src/languageServerProtocol/protocol/CallHierarchy.hx" module="languageServerProtocol.protocol.CallHierarchy">
		<a><dynamicRegistration>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc><![CDATA[Whether implementation supports dynamic registration. If this is set to `true`
		the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
		return value for the corresponding server capability as well.]]></haxe_doc>
</dynamicRegistration></a>
		<haxe_doc>@since 3.16.0</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.CallHierarchyOptions" params="" file="src/languageServerProtocol/protocol/CallHierarchy.hx" module="languageServerProtocol.protocol.CallHierarchy">
		<t path="languageServerProtocol.protocol.WorkDoneProgressOptions"/>
		<haxe_doc>Call hierarchy options used during static registration.

	@since 3.16.0</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.CallHierarchyRegistrationOptions" params="" file="src/languageServerProtocol/protocol/CallHierarchy.hx" module="languageServerProtocol.protocol.CallHierarchy">
		<a>
			<workDoneProgress>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
			</workDoneProgress>
			<id>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The id used to register the request. The id can be used to deregister
		the request again. See also Registration#id.</haxe_doc>
			</id>
			<documentSelector>
				<x path="Null"><t path="languageServerProtocol.protocol.DocumentSelector"/></x>
				<haxe_doc>A document selector to identify the scope of the registration. If set to null
		the document selector provided on the client side will be used.</haxe_doc>
			</documentSelector>
		</a>
		<haxe_doc>Call hierarchy options used during static or dynamic registration.

	@since 3.16.0</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.CallHierarchyPrepareParams" params="" file="src/languageServerProtocol/protocol/CallHierarchy.hx" module="languageServerProtocol.protocol.CallHierarchy">
		<a>
			<workDoneToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report work done progress.</haxe_doc>
			</workDoneToken>
			<textDocument>
				<t path="languageServerProtocol.TextDocumentIdentifier"/>
				<haxe_doc>The text document.</haxe_doc>
			</textDocument>
			<position>
				<t path="languageServerProtocol.textdocument.Position"/>
				<haxe_doc>The position inside the text document.</haxe_doc>
			</position>
		</a>
		<haxe_doc>The parameter of a `textDocument/prepareCallHierarchy` request.

	@since 3.16.0</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.CallHierarchyPrepareRequest" params="" file="src/languageServerProtocol/protocol/CallHierarchy.hx" module="languageServerProtocol.protocol.CallHierarchy">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;CallHierarchyPrepareParams,Null&lt;Array&lt;CallHierarchyItem&gt;&gt;,Never,NoData,CallHierarchyRegistrationOptions&gt;(&quot;textDocument/prepareCallHierarchy&quot;)" line="46" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.CallHierarchyPrepareParams"/>
				<x path="Null"><c path="Array"><t path="languageServerProtocol.CallHierarchyItem"/></c></x>
				<e path="languageServerProtocol.protocol.Never"/>
				<e path="jsonrpc.NoData"/>
				<t path="languageServerProtocol.protocol.CallHierarchyRegistrationOptions"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<CallHierarchyPrepareParams,Null<Array<CallHierarchyItem>>,Never,NoData,CallHierarchyRegistrationOptions>("textDocument/prepareCallHierarchy")]]></e></m></meta>
		</type>
		<haxe_doc>A request to result a `CallHierarchyItem` in a document at a given position.
	Can be used as an input to a incoming or outgoing call hierarchy.

	@since 3.16.0</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.CallHierarchyIncomingCallsParams" params="" file="src/languageServerProtocol/protocol/CallHierarchy.hx" module="languageServerProtocol.protocol.CallHierarchy">
		<a>
			<workDoneToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report work done progress.</haxe_doc>
			</workDoneToken>
			<partialResultToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report partial results (e.g. streaming) to
		the client.</haxe_doc>
			</partialResultToken>
			<item><t path="languageServerProtocol.CallHierarchyItem"/></item>
		</a>
		<haxe_doc>The parameter of a `callHierarchy/incomingCalls` request.

	@since 3.16.0</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.CallHierarchyIncomingCallsRequest" params="" file="src/languageServerProtocol/protocol/CallHierarchy.hx" module="languageServerProtocol.protocol.CallHierarchy">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;CallHierarchyIncomingCallsParams,Null&lt;Array&lt;CallHierarchyIncomingCall&gt;&gt;,Array&lt;CallHierarchyIncomingCall&gt;,NoData,NoData&gt;(&quot;callHierarchy/incomingCalls&quot;)" line="66" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.CallHierarchyIncomingCallsParams"/>
				<x path="Null"><c path="Array"><t path="languageServerProtocol.CallHierarchyIncomingCall"/></c></x>
				<c path="Array"><t path="languageServerProtocol.CallHierarchyIncomingCall"/></c>
				<e path="jsonrpc.NoData"/>
				<e path="jsonrpc.NoData"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<CallHierarchyIncomingCallsParams,Null<Array<CallHierarchyIncomingCall>>,Array<CallHierarchyIncomingCall>,NoData,NoData>("callHierarchy/incomingCalls")]]></e></m></meta>
		</type>
		<haxe_doc>A request to resolve the incoming calls for a given `CallHierarchyItem`.

	@since 3.16.0</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.CallHierarchyOutgoingCallsParams" params="" file="src/languageServerProtocol/protocol/CallHierarchy.hx" module="languageServerProtocol.protocol.CallHierarchy">
		<a>
			<workDoneToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report work done progress.</haxe_doc>
			</workDoneToken>
			<partialResultToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report partial results (e.g. streaming) to
		the client.</haxe_doc>
			</partialResultToken>
			<item><t path="languageServerProtocol.CallHierarchyItem"/></item>
		</a>
		<haxe_doc>The parameter of a `callHierarchy/outgoingCalls` request.

	@since 3.16.0</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.CallHierarchyOutgoingCallsRequest" params="" file="src/languageServerProtocol/protocol/CallHierarchy.hx" module="languageServerProtocol.protocol.CallHierarchy">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;CallHierarchyOutgoingCallsParams,Null&lt;Array&lt;CallHierarchyOutgoingCall&gt;&gt;,Array&lt;CallHierarchyOutgoingCall&gt;,NoData,NoData&gt;(&quot;callHierarchy/outgoingCalls&quot;)" line="86" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.CallHierarchyOutgoingCallsParams"/>
				<x path="Null"><c path="Array"><t path="languageServerProtocol.CallHierarchyOutgoingCall"/></c></x>
				<c path="Array"><t path="languageServerProtocol.CallHierarchyOutgoingCall"/></c>
				<e path="jsonrpc.NoData"/>
				<e path="jsonrpc.NoData"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<CallHierarchyOutgoingCallsParams,Null<Array<CallHierarchyOutgoingCall>>,Array<CallHierarchyOutgoingCall>,NoData,NoData>("callHierarchy/outgoingCalls")]]></e></m></meta>
		</type>
		<haxe_doc>A request to resolve the outgoing calls for a given `CallHierarchyItem`.

	@since 3.16.0</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.DocumentColorClientCapabilities" params="" file="src/languageServerProtocol/protocol/ColorProvider.hx" module="languageServerProtocol.protocol.ColorProvider"><a><dynamicRegistration>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>Whether implementation supports dynamic registration. If this is set to `true`
		the client supports the new `DocumentColorRegistrationOptions` return value
		for the corresponding server capability as well.</haxe_doc>
</dynamicRegistration></a></typedef>
	<typedef path="languageServerProtocol.protocol.DocumentColorOptions" params="" file="src/languageServerProtocol/protocol/ColorProvider.hx" module="languageServerProtocol.protocol.ColorProvider"><t path="languageServerProtocol.protocol.WorkDoneProgressOptions"/></typedef>
	<typedef path="languageServerProtocol.protocol.DocumentColorRegistrationOptions" params="" file="src/languageServerProtocol/protocol/ColorProvider.hx" module="languageServerProtocol.protocol.ColorProvider"><a>
	<workDoneProgress>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</workDoneProgress>
	<id>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The id used to register the request. The id can be used to deregister
		the request again. See also Registration#id.</haxe_doc>
	</id>
	<documentSelector>
		<x path="Null"><t path="languageServerProtocol.protocol.DocumentSelector"/></x>
		<haxe_doc>A document selector to identify the scope of the registration. If set to null
		the document selector provided on the client side will be used.</haxe_doc>
	</documentSelector>
</a></typedef>
	<typedef path="languageServerProtocol.protocol.DocumentColorParams" params="" file="src/languageServerProtocol/protocol/ColorProvider.hx" module="languageServerProtocol.protocol.ColorProvider">
		<a>
			<workDoneToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report work done progress.</haxe_doc>
			</workDoneToken>
			<textDocument>
				<t path="languageServerProtocol.TextDocumentIdentifier"/>
				<haxe_doc>The text document.</haxe_doc>
			</textDocument>
			<partialResultToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report partial results (e.g. streaming) to
		the client.</haxe_doc>
			</partialResultToken>
		</a>
		<haxe_doc>Parameters for a `DocumentColor` request.</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.DocumentColorRequest" params="" file="src/languageServerProtocol/protocol/ColorProvider.hx" module="languageServerProtocol.protocol.ColorProvider">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;DocumentColorParams,Array&lt;ColorInformation&gt;,Array&lt;ColorInformation&gt;,NoData,DocumentColorRegistrationOptions&gt;(&quot;textDocument/documentColor&quot;)" line="40" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.DocumentColorParams"/>
				<c path="Array"><t path="languageServerProtocol.ColorInformation"/></c>
				<c path="Array"><t path="languageServerProtocol.ColorInformation"/></c>
				<e path="jsonrpc.NoData"/>
				<t path="languageServerProtocol.protocol.DocumentColorRegistrationOptions"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<DocumentColorParams,Array<ColorInformation>,Array<ColorInformation>,NoData,DocumentColorRegistrationOptions>("textDocument/documentColor")]]></e></m></meta>
		</type>
		<haxe_doc>A request to list all color symbols found in a given text document. The request's
	parameter is of type [DocumentColorParams](#DocumentColorParams) the
	response is of type [ColorInformation[]](#ColorInformation) or a Thenable
	that resolves to such.</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.ColorPresentationParams" params="" file="src/languageServerProtocol/protocol/ColorProvider.hx" module="languageServerProtocol.protocol.ColorProvider">
		<a>
			<workDoneToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report work done progress.</haxe_doc>
			</workDoneToken>
			<textDocument>
				<t path="languageServerProtocol.TextDocumentIdentifier"/>
				<haxe_doc>The text document.</haxe_doc>
			</textDocument>
			<range>
				<t path="languageServerProtocol.textdocument.Range"/>
				<haxe_doc>The range where the color would be inserted. Serves as a context.</haxe_doc>
			</range>
			<partialResultToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report partial results (e.g. streaming) to
		the client.</haxe_doc>
			</partialResultToken>
			<color>
				<t path="languageServerProtocol.Color"/>
				<haxe_doc>The color to request presentations for.</haxe_doc>
			</color>
		</a>
		<haxe_doc>Parameters for a `ColorPresentation` request.</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.ColorPresentationRequest" params="" file="src/languageServerProtocol/protocol/ColorProvider.hx" module="languageServerProtocol.protocol.ColorProvider">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;ColorPresentationParams,Array&lt;ColorPresentation&gt;,Array&lt;ColorPresentation&gt;,NoData,WorkDoneProgressOptions&amp;TextDocumentRegistrationOptions&gt;(&quot;textDocument/colorPresentation&quot;)" line="72" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.ColorPresentationParams"/>
				<c path="Array"><t path="languageServerProtocol.ColorPresentation"/></c>
				<c path="Array"><t path="languageServerProtocol.ColorPresentation"/></c>
				<e path="jsonrpc.NoData"/>
				<a>
					<workDoneProgress>
						<x path="Null"><x path="Bool"/></x>
						<meta><m n=":optional"/></meta>
					</workDoneProgress>
					<documentSelector>
						<x path="Null"><t path="languageServerProtocol.protocol.DocumentSelector"/></x>
						<haxe_doc>A document selector to identify the scope of the registration. If set to null
		the document selector provided on the client side will be used.</haxe_doc>
					</documentSelector>
				</a>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<ColorPresentationParams,Array<ColorPresentation>,Array<ColorPresentation>,NoData,WorkDoneProgressOptions&TextDocumentRegistrationOptions>("textDocument/colorPresentation")]]></e></m></meta>
		</type>
		<haxe_doc>A request to list all presentation for a color. The request's
	parameter is of type [ColorPresentationParams](#ColorPresentationParams) the
	response is of type [ColorInformation[]](#ColorInformation) or a Thenable
	that resolves to such.</haxe_doc>
	</class>
	<class path="languageServerProtocol.protocol.ConfigurationRequest" params="" file="src/languageServerProtocol/protocol/Configuration.hx" module="languageServerProtocol.protocol.Configuration">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;ConfigurationParams&amp;PartialResultParams,Array&lt;LSPAny&gt;,Never,NoData,NoData&gt;(&quot;workspace/configuration&quot;)" line="18" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<a>
					<partialResultToken>
						<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
						<meta><m n=":optional"/></meta>
						<haxe_doc>An optional token that a server can use to report partial results (e.g. streaming) to
		the client.</haxe_doc>
					</partialResultToken>
					<items><c path="Array"><t path="languageServerProtocol.protocol.ConfigurationItem"/></c></items>
				</a>
				<c path="Array"><t path="languageServerProtocol.LSPAny"/></c>
				<e path="languageServerProtocol.protocol.Never"/>
				<e path="jsonrpc.NoData"/>
				<e path="jsonrpc.NoData"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<ConfigurationParams&PartialResultParams,Array<LSPAny>,Never,NoData,NoData>("workspace/configuration")]]></e></m></meta>
		</type>
		<haxe_doc>The 'workspace/configuration' request is sent from the server to the client to fetch a certain
	configuration setting.

	This pull model replaces the old push model were the client signaled configuration change via an
	event. If the server still needs to react to configuration changes (since the server caches the
	result of `workspace/configuration` requests) the server should register for an empty configuration
	change event and empty the cache if such an event is received.</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.ConfigurationItem" params="" file="src/languageServerProtocol/protocol/Configuration.hx" module="languageServerProtocol.protocol.Configuration"><a>
	<section>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The configuration section asked for.</haxe_doc>
	</section>
	<scopeUri>
		<x path="Null"><x path="languageServerProtocol.textdocument.DocumentUri"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The scope to get the configuration section for.</haxe_doc>
	</scopeUri>
</a></typedef>
	<typedef path="languageServerProtocol.protocol.ConfigurationParams" params="" file="src/languageServerProtocol/protocol/Configuration.hx" module="languageServerProtocol.protocol.Configuration">
		<a><items><c path="Array"><t path="languageServerProtocol.protocol.ConfigurationItem"/></c></items></a>
		<haxe_doc>The parameters of a configuration request.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.DeclarationClientCapabilities" params="" file="src/languageServerProtocol/protocol/Declaration.hx" module="languageServerProtocol.protocol.Declaration">
		<a>
			<linkSupport>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The client supports additional metadata in the form of declaration links.</haxe_doc>
			</linkSupport>
			<dynamicRegistration>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether declaration supports dynamic registration. If this is set to `true`
		the client supports the new `DeclarationRegistrationOptions` return value
		for the corresponding server capability as well.</haxe_doc>
			</dynamicRegistration>
		</a>
		<haxe_doc>Since 3.14.0</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.DeclarationOptions" params="" file="src/languageServerProtocol/protocol/Declaration.hx" module="languageServerProtocol.protocol.Declaration"><a><workDoneProgress>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
</workDoneProgress></a></typedef>
	<typedef path="languageServerProtocol.protocol.DeclarationRegistrationOptions" params="" file="src/languageServerProtocol/protocol/Declaration.hx" module="languageServerProtocol.protocol.Declaration"><a>
	<workDoneProgress>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</workDoneProgress>
	<id>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The id used to register the request. The id can be used to deregister
		the request again. See also Registration#id.</haxe_doc>
	</id>
	<documentSelector>
		<x path="Null"><t path="languageServerProtocol.protocol.DocumentSelector"/></x>
		<haxe_doc>A document selector to identify the scope of the registration. If set to null
		the document selector provided on the client side will be used.</haxe_doc>
	</documentSelector>
</a></typedef>
	<typedef path="languageServerProtocol.protocol.DeclarationParams" params="" file="src/languageServerProtocol/protocol/Declaration.hx" module="languageServerProtocol.protocol.Declaration"><a>
	<workDoneToken>
		<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>An optional token that a server can use to report work done progress.</haxe_doc>
	</workDoneToken>
	<textDocument>
		<t path="languageServerProtocol.TextDocumentIdentifier"/>
		<haxe_doc>The text document.</haxe_doc>
	</textDocument>
	<position>
		<t path="languageServerProtocol.textdocument.Position"/>
		<haxe_doc>The position inside the text document.</haxe_doc>
	</position>
	<partialResultToken>
		<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>An optional token that a server can use to report partial results (e.g. streaming) to
		the client.</haxe_doc>
	</partialResultToken>
</a></typedef>
	<class path="languageServerProtocol.protocol.DeclarationRequest" params="" file="src/languageServerProtocol/protocol/Declaration.hx" module="languageServerProtocol.protocol.Declaration">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;DeclarationParams,Null&lt;EitherType&lt;Declaration,Array&lt;DeclarationLink&gt;&gt;&gt;,EitherType&lt;Array&lt;Location&gt;,Array&lt;DeclarationLink&gt;&gt;,NoData,DeclarationRegistrationOptions&gt;(&quot;textDocument/declaration&quot;)" line="35" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.DeclarationParams"/>
				<x path="Null"><x path="haxe.extern.EitherType">
	<t path="languageServerProtocol.Declaration"/>
	<c path="Array"><t path="languageServerProtocol.DeclarationLink"/></c>
</x></x>
				<x path="haxe.extern.EitherType">
					<c path="Array"><t path="languageServerProtocol.Location"/></c>
					<c path="Array"><t path="languageServerProtocol.DeclarationLink"/></c>
				</x>
				<e path="jsonrpc.NoData"/>
				<t path="languageServerProtocol.protocol.DeclarationRegistrationOptions"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<DeclarationParams,Null<EitherType<Declaration,Array<DeclarationLink>>>,EitherType<Array<Location>,Array<DeclarationLink>>,NoData,DeclarationRegistrationOptions>("textDocument/declaration")]]></e></m></meta>
		</type>
		<haxe_doc>A request to resolve the type definition locations of a symbol at a given text
	document position. The request's parameter is of type [TextDocumentPositioParams]
	(#TextDocumentPositionParams) the response is of type [Declaration](#Declaration)
	or a typed array of [DeclarationLink](#DeclarationLink) or a Thenable that resolves
	to such.</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.FileOperationOptions" params="" file="src/languageServerProtocol/protocol/FileOperations.hx" module="languageServerProtocol.protocol.FileOperations">
		<a>
			<willRename>
				<x path="Null"><t path="languageServerProtocol.protocol.FileOperationRegistrationOptions"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The server is interested in willRenameFiles requests.</haxe_doc>
			</willRename>
			<willDelete>
				<x path="Null"><t path="languageServerProtocol.protocol.FileOperationRegistrationOptions"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The server is interested in willDeleteFiles file requests.</haxe_doc>
			</willDelete>
			<willCreate>
				<x path="Null"><t path="languageServerProtocol.protocol.FileOperationRegistrationOptions"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The server is interested in willCreateFiles requests.</haxe_doc>
			</willCreate>
			<didRename>
				<x path="Null"><t path="languageServerProtocol.protocol.FileOperationRegistrationOptions"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The server is interested in didRenameFiles notifications.</haxe_doc>
			</didRename>
			<didDelete>
				<x path="Null"><t path="languageServerProtocol.protocol.FileOperationRegistrationOptions"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The server is interested in didDeleteFiles file notifications.</haxe_doc>
			</didDelete>
			<didCreate>
				<x path="Null"><t path="languageServerProtocol.protocol.FileOperationRegistrationOptions"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The server is interested in didCreateFiles notifications.</haxe_doc>
			</didCreate>
		</a>
		<haxe_doc>Options for notifications/requests for user operations on files.

	@since 3.16.0</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.FileOperationRegistrationOptions" params="" file="src/languageServerProtocol/protocol/FileOperations.hx" module="languageServerProtocol.protocol.FileOperations">
		<a><filters>
	<c path="Array"><t path="languageServerProtocol.protocol.FileOperationFilter"/></c>
	<haxe_doc>The actual filters.</haxe_doc>
</filters></a>
		<haxe_doc>The options to register for file operations.

	@since 3.16.0</haxe_doc>
	</typedef>
	<abstract path="languageServerProtocol.protocol.FileOperationPatternKind" params="" file="src/languageServerProtocol/protocol/FileOperations.hx" module="languageServerProtocol.protocol.FileOperations">
		<this><c path="String"/></this>
		<haxe_doc>A pattern kind describing if a glob pattern matches a file a folder or
	both.

	@since 3.16.0</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="languageServerProtocol.protocol._FileOperations.FileOperationPatternKind_Impl_" params="" file="src/languageServerProtocol/protocol/FileOperations.hx" private="1" module="languageServerProtocol.protocol.FileOperations" extern="1" final="1">
	<file public="1" get="inline" set="null" expr="cast &quot;file&quot;" line="64" static="1">
		<x path="languageServerProtocol.protocol.FileOperationPatternKind"/>
		<meta>
			<m n=":value"><e>cast "file"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>The pattern matches a file only.</haxe_doc>
	</file>
	<folder public="1" get="inline" set="null" expr="cast &quot;folder&quot;" line="69" static="1">
		<x path="languageServerProtocol.protocol.FileOperationPatternKind"/>
		<meta>
			<m n=":value"><e>cast "folder"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>The pattern matches a folder only.</haxe_doc>
	</folder>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="languageServerProtocol.protocol._FileOperations.FileOperationPatternKind_Impl_" params="" file="src/languageServerProtocol/protocol/FileOperations.hx" private="1" module="languageServerProtocol.protocol.FileOperations" extern="1" final="1">
		<file public="1" get="inline" set="null" expr="cast &quot;file&quot;" line="64" static="1">
			<x path="languageServerProtocol.protocol.FileOperationPatternKind"/>
			<meta>
				<m n=":value"><e>cast "file"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>The pattern matches a file only.</haxe_doc>
		</file>
		<folder public="1" get="inline" set="null" expr="cast &quot;folder&quot;" line="69" static="1">
			<x path="languageServerProtocol.protocol.FileOperationPatternKind"/>
			<meta>
				<m n=":value"><e>cast "folder"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>The pattern matches a folder only.</haxe_doc>
		</folder>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="languageServerProtocol.protocol.FileOperationPatternOptions" params="" file="src/languageServerProtocol/protocol/FileOperations.hx" module="languageServerProtocol.protocol.FileOperations">
		<a><ignoreCase>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>The pattern should be matched ignoring casing.</haxe_doc>
</ignoreCase></a>
		<haxe_doc>Matching options for the file operation pattern.

	@since 3.16.0</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.FileOperationPattern" params="" file="src/languageServerProtocol/protocol/FileOperations.hx" module="languageServerProtocol.protocol.FileOperations">
		<a>
			<options>
				<x path="Null"><t path="languageServerProtocol.protocol.FileOperationPatternOptions"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Additional options used during matching.</haxe_doc>
			</options>
			<matches>
				<x path="Null"><x path="languageServerProtocol.protocol.FileOperationPatternKind"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether to match files or folders with this pattern.

		Matches both if undefined.</haxe_doc>
			</matches>
			<glob>
				<c path="String"/>
				<haxe_doc>The glob pattern to match. Glob patterns can have the following syntax:
		- `*` to match one or more characters in a path segment
		- `?` to match on one character in a path segment
		- `**` to match any number of path segments, including none
		- `{}` to group sub patterns into an OR expression. (e.g. `**​/*.{ts,js}` matches all TypeScript and JavaScript files)
		- `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, …)
		- `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)</haxe_doc>
			</glob>
		</a>
		<haxe_doc>A pattern to describe in which file operation requests or notifications
	the server is interested in.

	@since 3.16.0</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.FileOperationFilter" params="" file="src/languageServerProtocol/protocol/FileOperations.hx" module="languageServerProtocol.protocol.FileOperations">
		<a>
			<scheme>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>A Uri like `file` or `untitled`.</haxe_doc>
			</scheme>
			<pattern>
				<t path="languageServerProtocol.protocol.FileOperationPattern"/>
				<haxe_doc>The actual file operation pattern.</haxe_doc>
			</pattern>
		</a>
		<haxe_doc>A filter to describe in which file operation requests or notifications
	the server is interested in.

	@since 3.16.0</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.FileOperationClientCapabilities" params="" file="src/languageServerProtocol/protocol/FileOperations.hx" module="languageServerProtocol.protocol.FileOperations">
		<a>
			<willRename>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The client has support for willRenameFiles requests.</haxe_doc>
			</willRename>
			<willDelete>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The client has support for willDeleteFiles requests.</haxe_doc>
			</willDelete>
			<willCreate>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The client has support for willCreateFiles requests.</haxe_doc>
			</willCreate>
			<dynamicRegistration>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether the client supports dynamic registration for file requests/notifications.</haxe_doc>
			</dynamicRegistration>
			<didRename>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The client has support for sending didRenameFiles notifications.</haxe_doc>
			</didRename>
			<didDelete>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The client has support for sending didDeleteFiles notifications.</haxe_doc>
			</didDelete>
			<didCreate>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The client has support for sending didCreateFiles notifications.</haxe_doc>
			</didCreate>
		</a>
		<haxe_doc>Capabilities relating to events from file operations by the user in the client.

	These events do not come from the file system, they come from user operations
	like renaming a file in the UI.

	@since 3.16.0</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.CreateFilesParams" params="" file="src/languageServerProtocol/protocol/FileOperations.hx" module="languageServerProtocol.protocol.FileOperations">
		<a><files>
	<c path="Array"><t path="languageServerProtocol.protocol.FileCreate"/></c>
	<haxe_doc>An array of all files/folders created in this operation.</haxe_doc>
</files></a>
		<haxe_doc>The parameters sent in file create requests/notifications.

	@since 3.16.0</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.FileCreate" params="" file="src/languageServerProtocol/protocol/FileOperations.hx" module="languageServerProtocol.protocol.FileOperations">
		<a><uri>
	<c path="String"/>
	<haxe_doc>A file:// URI for the location of the file/folder being created.</haxe_doc>
</uri></a>
		<haxe_doc>Represents information on a file/folder create.

	@since 3.16.0</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.RenameFilesParams" params="" file="src/languageServerProtocol/protocol/FileOperations.hx" module="languageServerProtocol.protocol.FileOperations">
		<a><files>
	<c path="Array"><t path="languageServerProtocol.protocol.FileRename"/></c>
	<haxe_doc>An array of all files/folders renamed in this operation. When a folder is renamed, only
		the folder will be included, and not its children.</haxe_doc>
</files></a>
		<haxe_doc>The parameters sent in file rename requests/notifications.

	@since 3.16.0</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.FileRename" params="" file="src/languageServerProtocol/protocol/FileOperations.hx" module="languageServerProtocol.protocol.FileOperations">
		<a>
			<oldUri>
				<c path="String"/>
				<haxe_doc>A file:// URI for the original location of the file/folder being renamed.</haxe_doc>
			</oldUri>
			<newUri>
				<c path="String"/>
				<haxe_doc>A file:// URI for the new location of the file/folder being renamed.</haxe_doc>
			</newUri>
		</a>
		<haxe_doc>Represents information on a file/folder rename.

	@since 3.16.0</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.DeleteFilesParams" params="" file="src/languageServerProtocol/protocol/FileOperations.hx" module="languageServerProtocol.protocol.FileOperations">
		<a><files>
	<c path="Array"><t path="languageServerProtocol.protocol.FileDelete"/></c>
	<haxe_doc>An array of all files/folders deleted in this operation.</haxe_doc>
</files></a>
		<haxe_doc>The parameters sent in file delete requests/notifications.

	@since 3.16.0</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.FileDelete" params="" file="src/languageServerProtocol/protocol/FileOperations.hx" module="languageServerProtocol.protocol.FileOperations">
		<a><uri>
	<c path="String"/>
	<haxe_doc>A file:// URI for the location of the file/folder being deleted.</haxe_doc>
</uri></a>
		<haxe_doc>Represents information on a file/folder delete.

	@since 3.16.0</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.WillCreateFilesRequest" params="" file="src/languageServerProtocol/protocol/FileOperations.hx" module="languageServerProtocol.protocol.FileOperations">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;CreateFilesParams,Null&lt;WorkspaceEdit&gt;,Never,NoData,FileOperationRegistrationOptions&gt;(&quot;workspace/willCreateFiles&quot;)" line="263" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.CreateFilesParams"/>
				<x path="Null"><t path="languageServerProtocol.WorkspaceEdit"/></x>
				<e path="languageServerProtocol.protocol.Never"/>
				<e path="jsonrpc.NoData"/>
				<t path="languageServerProtocol.protocol.FileOperationRegistrationOptions"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<CreateFilesParams,Null<WorkspaceEdit>,Never,NoData,FileOperationRegistrationOptions>("workspace/willCreateFiles")]]></e></m></meta>
		</type>
		<haxe_doc>The will create files request is sent from the client to the server before files are actually
	created as long as the creation is triggered from within the client.

	@since 3.16.0</haxe_doc>
	</class>
	<class path="languageServerProtocol.protocol.DidCreateFilesNotification" params="" file="src/languageServerProtocol/protocol/FileOperations.hx" module="languageServerProtocol.protocol.FileOperations">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolNotificationType&lt;CreateFilesParams,FileOperationRegistrationOptions&gt;(&quot;workspace/didCreateFiles&quot;)" line="274" static="1">
			<x path="languageServerProtocol.protocol.ProtocolNotificationType">
				<t path="languageServerProtocol.protocol.CreateFilesParams"/>
				<t path="languageServerProtocol.protocol.FileOperationRegistrationOptions"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolNotificationType<CreateFilesParams,FileOperationRegistrationOptions>("workspace/didCreateFiles")]]></e></m></meta>
		</type>
		<haxe_doc>The did create files notification is sent from the client to the server when
	files were created from within the client.

	@since 3.16.0</haxe_doc>
	</class>
	<class path="languageServerProtocol.protocol.WillRenameFilesRequest" params="" file="src/languageServerProtocol/protocol/FileOperations.hx" module="languageServerProtocol.protocol.FileOperations">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;RenameFilesParams,Null&lt;WorkspaceEdit&gt;,Never,NoData,FileOperationRegistrationOptions&gt;(&quot;workspace/willRenameFiles&quot;)" line="284" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.RenameFilesParams"/>
				<x path="Null"><t path="languageServerProtocol.WorkspaceEdit"/></x>
				<e path="languageServerProtocol.protocol.Never"/>
				<e path="jsonrpc.NoData"/>
				<t path="languageServerProtocol.protocol.FileOperationRegistrationOptions"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<RenameFilesParams,Null<WorkspaceEdit>,Never,NoData,FileOperationRegistrationOptions>("workspace/willRenameFiles")]]></e></m></meta>
		</type>
		<haxe_doc>The will rename files request is sent from the client to the server before files are actually
	renamed as long as the rename is triggered from within the client.

	@since 3.16.0</haxe_doc>
	</class>
	<class path="languageServerProtocol.protocol.DidRenameFilesNotification" params="" file="src/languageServerProtocol/protocol/FileOperations.hx" module="languageServerProtocol.protocol.FileOperations">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolNotificationType&lt;RenameFilesParams,FileOperationRegistrationOptions&gt;(&quot;workspace/didRenameFiles&quot;)" line="295" static="1">
			<x path="languageServerProtocol.protocol.ProtocolNotificationType">
				<t path="languageServerProtocol.protocol.RenameFilesParams"/>
				<t path="languageServerProtocol.protocol.FileOperationRegistrationOptions"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolNotificationType<RenameFilesParams,FileOperationRegistrationOptions>("workspace/didRenameFiles")]]></e></m></meta>
		</type>
		<haxe_doc>The did rename files notification is sent from the client to the server when
	files were renamed from within the client.

	@since 3.16.0</haxe_doc>
	</class>
	<class path="languageServerProtocol.protocol.DidDeleteFilesNotification" params="" file="src/languageServerProtocol/protocol/FileOperations.hx" module="languageServerProtocol.protocol.FileOperations">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolNotificationType&lt;DeleteFilesParams,FileOperationRegistrationOptions&gt;(&quot;workspace/didDeleteFiles&quot;)" line="305" static="1">
			<x path="languageServerProtocol.protocol.ProtocolNotificationType">
				<t path="languageServerProtocol.protocol.DeleteFilesParams"/>
				<t path="languageServerProtocol.protocol.FileOperationRegistrationOptions"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolNotificationType<DeleteFilesParams,FileOperationRegistrationOptions>("workspace/didDeleteFiles")]]></e></m></meta>
		</type>
		<haxe_doc>The will delete files request is sent from the client to the server before files are actually
	deleted as long as the deletion is triggered from within the client.

	@since 3.16.0</haxe_doc>
	</class>
	<class path="languageServerProtocol.protocol.WillDeleteFilesRequest" params="" file="src/languageServerProtocol/protocol/FileOperations.hx" module="languageServerProtocol.protocol.FileOperations">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;DeleteFilesParams,Null&lt;WorkspaceEdit&gt;,Never,NoData,FileOperationRegistrationOptions&gt;(&quot;workspace/willDeleteFiles&quot;)" line="315" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.DeleteFilesParams"/>
				<x path="Null"><t path="languageServerProtocol.WorkspaceEdit"/></x>
				<e path="languageServerProtocol.protocol.Never"/>
				<e path="jsonrpc.NoData"/>
				<t path="languageServerProtocol.protocol.FileOperationRegistrationOptions"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<DeleteFilesParams,Null<WorkspaceEdit>,Never,NoData,FileOperationRegistrationOptions>("workspace/willDeleteFiles")]]></e></m></meta>
		</type>
		<haxe_doc>The did delete files notification is sent from the client to the server when
	files were deleted from within the client.

	@since 3.16.0</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.FoldingRangeClientCapabilities" params="" file="src/languageServerProtocol/protocol/FoldingRange.hx" module="languageServerProtocol.protocol.FoldingRange"><a>
	<rangeLimit>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The maximum number of folding ranges that the client prefers to receive per document. The value serves as a
		hint, servers are free to follow the limit.</haxe_doc>
	</rangeLimit>
	<lineFoldingOnly>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>If set, the client signals that it only supports folding complete lines. If set, client will
		ignore specified `startCharacter` and `endCharacter` properties in a FoldingRange.</haxe_doc>
	</lineFoldingOnly>
	<foldingRangeKind>
		<x path="Null"><a><valueSet>
	<x path="Null"><c path="Array"><x path="languageServerProtocol.FoldingRangeKind"/></c></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>The folding range kind values the client supports. When this
			property exists the client also guarantees that it will
			handle values outside its set gracefully and falls back
			to a default value when unknown.</haxe_doc>
</valueSet></a></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Specific options for the folding range kind.

		@since 3.17.0
		@proposed</haxe_doc>
	</foldingRangeKind>
	<foldingRange>
		<x path="Null"><a><collapsedText>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>If set, the client signals that it supports setting collapsedText on
			folding ranges to display custom labels instead of the default text.

			@since 3.17.0
			@proposed</haxe_doc>
</collapsedText></a></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Specific options for the folding range.
		@since 3.17.0
		@proposed</haxe_doc>
	</foldingRange>
	<dynamicRegistration>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Whether implementation supports dynamic registration for folding range providers. If this is set to `true`
		the client supports the new `FoldingRangeRegistrationOptions` return value for the corresponding server
		capability as well.</haxe_doc>
	</dynamicRegistration>
</a></typedef>
	<typedef path="languageServerProtocol.protocol.FoldingRangeOptions" params="" file="src/languageServerProtocol/protocol/FoldingRange.hx" module="languageServerProtocol.protocol.FoldingRange"><a><workDoneProgress>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
</workDoneProgress></a></typedef>
	<typedef path="languageServerProtocol.protocol.FoldingRangeRegistrationOptions" params="" file="src/languageServerProtocol/protocol/FoldingRange.hx" module="languageServerProtocol.protocol.FoldingRange"><a>
	<workDoneProgress>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</workDoneProgress>
	<id>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The id used to register the request. The id can be used to deregister
		the request again. See also Registration#id.</haxe_doc>
	</id>
	<documentSelector>
		<x path="Null"><t path="languageServerProtocol.protocol.DocumentSelector"/></x>
		<haxe_doc>A document selector to identify the scope of the registration. If set to null
		the document selector provided on the client side will be used.</haxe_doc>
	</documentSelector>
</a></typedef>
	<typedef path="languageServerProtocol.protocol.FoldingRangeParams" params="" file="src/languageServerProtocol/protocol/FoldingRange.hx" module="languageServerProtocol.protocol.FoldingRange">
		<a>
			<workDoneToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report work done progress.</haxe_doc>
			</workDoneToken>
			<textDocument>
				<t path="languageServerProtocol.TextDocumentIdentifier"/>
				<haxe_doc>The text document.</haxe_doc>
			</textDocument>
			<partialResultToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report partial results (e.g. streaming) to
		the client.</haxe_doc>
			</partialResultToken>
		</a>
		<haxe_doc>Parameters for a [FoldingRangeRequest](#FoldingRangeRequest).</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.FoldingRangeRequest" params="" file="src/languageServerProtocol/protocol/FoldingRange.hx" module="languageServerProtocol.protocol.FoldingRange">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;FoldingRangeParams,Null&lt;Array&lt;FoldingRange&gt;&gt;,Array&lt;FoldingRange&gt;,NoData,FoldingRangeRegistrationOptions&gt;(&quot;textDocument/foldingRange&quot;)" line="82" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.FoldingRangeParams"/>
				<x path="Null"><c path="Array"><t path="languageServerProtocol.FoldingRange"/></c></x>
				<c path="Array"><t path="languageServerProtocol.FoldingRange"/></c>
				<e path="jsonrpc.NoData"/>
				<t path="languageServerProtocol.protocol.FoldingRangeRegistrationOptions"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<FoldingRangeParams,Null<Array<FoldingRange>>,Array<FoldingRange>,NoData,FoldingRangeRegistrationOptions>("textDocument/foldingRange")]]></e></m></meta>
		</type>
		<haxe_doc>A request to provide folding ranges in a document. The request's
	parameter is of type [FoldingRangeParams](#FoldingRangeParams), the
	response is of type [FoldingRangeList](#FoldingRangeList) or a Thenable
	that resolves to such.</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.ImplementationClientCapabilities" params="" file="src/languageServerProtocol/protocol/Implementation.hx" module="languageServerProtocol.protocol.Implementation">
		<a>
			<linkSupport>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The client supports additional metadata in the form of definition links.

		Since 3.14.0</haxe_doc>
			</linkSupport>
			<dynamicRegistration>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether implementation supports dynamic registration. If this is set to `true`
		the client supports the new `ImplementationRegistrationOptions` return value
		for the corresponding server capability as well.</haxe_doc>
			</dynamicRegistration>
		</a>
		<haxe_doc>Since 3.6.0</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.ImplementationOptions" params="" file="src/languageServerProtocol/protocol/Implementation.hx" module="languageServerProtocol.protocol.Implementation"><a><workDoneProgress>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
</workDoneProgress></a></typedef>
	<typedef path="languageServerProtocol.protocol.ImplementationRegistrationOptions" params="" file="src/languageServerProtocol/protocol/Implementation.hx" module="languageServerProtocol.protocol.Implementation"><a>
	<workDoneProgress>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</workDoneProgress>
	<id>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The id used to register the request. The id can be used to deregister
		the request again. See also Registration#id.</haxe_doc>
	</id>
	<documentSelector>
		<x path="Null"><t path="languageServerProtocol.protocol.DocumentSelector"/></x>
		<haxe_doc>A document selector to identify the scope of the registration. If set to null
		the document selector provided on the client side will be used.</haxe_doc>
	</documentSelector>
</a></typedef>
	<typedef path="languageServerProtocol.protocol.ImplementationParams" params="" file="src/languageServerProtocol/protocol/Implementation.hx" module="languageServerProtocol.protocol.Implementation"><a>
	<workDoneToken>
		<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>An optional token that a server can use to report work done progress.</haxe_doc>
	</workDoneToken>
	<textDocument>
		<t path="languageServerProtocol.TextDocumentIdentifier"/>
		<haxe_doc>The text document.</haxe_doc>
	</textDocument>
	<position>
		<t path="languageServerProtocol.textdocument.Position"/>
		<haxe_doc>The position inside the text document.</haxe_doc>
	</position>
	<partialResultToken>
		<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>An optional token that a server can use to report partial results (e.g. streaming) to
		the client.</haxe_doc>
	</partialResultToken>
</a></typedef>
	<class path="languageServerProtocol.protocol.ImplementationRequest" params="" file="src/languageServerProtocol/protocol/Implementation.hx" module="languageServerProtocol.protocol.Implementation">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;ImplementationParams,Null&lt;EitherType&lt;Definition,Array&lt;DefinitionLink&gt;&gt;&gt;,EitherType&lt;Array&lt;Location&gt;,Array&lt;DefinitionLink&gt;&gt;,NoData,TextDocumentRegistrationOptions&gt;(&quot;textDocument/implementation&quot;)" line="36" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.ImplementationParams"/>
				<x path="Null"><x path="haxe.extern.EitherType">
	<t path="languageServerProtocol.Definition"/>
	<c path="Array"><t path="languageServerProtocol.DefinitionLink"/></c>
</x></x>
				<x path="haxe.extern.EitherType">
					<c path="Array"><t path="languageServerProtocol.Location"/></c>
					<c path="Array"><t path="languageServerProtocol.DefinitionLink"/></c>
				</x>
				<e path="jsonrpc.NoData"/>
				<t path="languageServerProtocol.protocol.TextDocumentRegistrationOptions"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<ImplementationParams,Null<EitherType<Definition,Array<DefinitionLink>>>,EitherType<Array<Location>,Array<DefinitionLink>>,NoData,TextDocumentRegistrationOptions>("textDocument/implementation")]]></e></m></meta>
		</type>
		<haxe_doc>A request to resolve the implementation locations of a symbol at a given text
	document position. The request's parameter is of type [TextDocumentPositioParams]
	(#TextDocumentPositionParams) the response is of type [Definition](#Definition) or a
	Thenable that resolves to such.</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.LinkedEditingRangeClientCapabilities" params="" file="src/languageServerProtocol/protocol/LinkedEditingRange.hx" module="languageServerProtocol.protocol.LinkedEditingRange">
		<a><dynamicRegistration>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc><![CDATA[Whether implementation supports dynamic registration. If this is set to `true`
		the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
		return value for the corresponding server capability as well.]]></haxe_doc>
</dynamicRegistration></a>
		<haxe_doc>Client capabilities for the linked editing range request.

	@since 3.16.0</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.LinkedEditingRangeParams" params="" file="src/languageServerProtocol/protocol/LinkedEditingRange.hx" module="languageServerProtocol.protocol.LinkedEditingRange"><a>
	<workDoneToken>
		<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>An optional token that a server can use to report work done progress.</haxe_doc>
	</workDoneToken>
	<textDocument>
		<t path="languageServerProtocol.TextDocumentIdentifier"/>
		<haxe_doc>The text document.</haxe_doc>
	</textDocument>
	<position>
		<t path="languageServerProtocol.textdocument.Position"/>
		<haxe_doc>The position inside the text document.</haxe_doc>
	</position>
</a></typedef>
	<typedef path="languageServerProtocol.protocol.LinkedEditingRangeOptions" params="" file="src/languageServerProtocol/protocol/LinkedEditingRange.hx" module="languageServerProtocol.protocol.LinkedEditingRange"><t path="languageServerProtocol.protocol.WorkDoneProgressOptions"/></typedef>
	<typedef path="languageServerProtocol.protocol.LinkedEditingRangeRegistrationOptions" params="" file="src/languageServerProtocol/protocol/LinkedEditingRange.hx" module="languageServerProtocol.protocol.LinkedEditingRange"><a>
	<workDoneProgress>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</workDoneProgress>
	<id>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The id used to register the request. The id can be used to deregister
		the request again. See also Registration#id.</haxe_doc>
	</id>
	<documentSelector>
		<x path="Null"><t path="languageServerProtocol.protocol.DocumentSelector"/></x>
		<haxe_doc>A document selector to identify the scope of the registration. If set to null
		the document selector provided on the client side will be used.</haxe_doc>
	</documentSelector>
</a></typedef>
	<typedef path="languageServerProtocol.protocol.LinkedEditingRanges" params="" file="src/languageServerProtocol/protocol/LinkedEditingRange.hx" module="languageServerProtocol.protocol.LinkedEditingRange">
		<a>
			<wordPattern>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional word pattern (regular expression) that describes valid contents for
		the given ranges. If no pattern is provided, the client configuration's word
		pattern will be used.</haxe_doc>
			</wordPattern>
			<ranges>
				<c path="Array"><t path="languageServerProtocol.textdocument.Range"/></c>
				<haxe_doc>A list of ranges that can be edited together. The ranges must have
		identical length and contain identical text content. The ranges cannot overlap.</haxe_doc>
			</ranges>
		</a>
		<haxe_doc>The result of a linked editing range request.

	@since 3.16.0</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.LinkedEditingRangeRequest" params="" file="src/languageServerProtocol/protocol/LinkedEditingRange.hx" module="languageServerProtocol.protocol.LinkedEditingRange">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;LinkedEditingRangeParams,Null&lt;LinkedEditingRanges&gt;,NoData,NoData,LinkedEditingRangeRegistrationOptions&gt;(&quot;textDocument/linkedEditingRange&quot;)" line="50" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.LinkedEditingRangeParams"/>
				<x path="Null"><t path="languageServerProtocol.protocol.LinkedEditingRanges"/></x>
				<e path="jsonrpc.NoData"/>
				<e path="jsonrpc.NoData"/>
				<t path="languageServerProtocol.protocol.LinkedEditingRangeRegistrationOptions"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<LinkedEditingRangeParams,Null<LinkedEditingRanges>,NoData,NoData,LinkedEditingRangeRegistrationOptions>("textDocument/linkedEditingRange")]]></e></m></meta>
		</type>
		<haxe_doc>A request to provide ranges that can be edited together.

	@since 3.16.0</haxe_doc>
	</class>
	<abstract path="languageServerProtocol.protocol.RegistrationType" params="RO" file="src/languageServerProtocol/protocol/Messages.hx" module="languageServerProtocol.protocol.Messages">
		<this><c path="String"/></this>
		<impl><class path="languageServerProtocol.protocol._Messages.RegistrationType_Impl_" params="" file="src/languageServerProtocol/protocol/Messages.hx" private="1" module="languageServerProtocol.protocol.Messages" final="1"><_new public="1" get="inline" set="null" line="8" static="1">
	<f a="method">
		<c path="String"/>
		<x path="languageServerProtocol.protocol.RegistrationType"><c path="languageServerProtocol.protocol.RegistrationType.RO"/></x>
	</f>
	<meta><m n=":noCompletion"/></meta>
</_new></class></impl>
	</abstract>
	<class path="languageServerProtocol.protocol._Messages.RegistrationType_Impl_" params="" file="src/languageServerProtocol/protocol/Messages.hx" private="1" module="languageServerProtocol.protocol.Messages" final="1"><_new public="1" get="inline" set="null" line="8" static="1">
	<f a="method">
		<c path="String"/>
		<x path="languageServerProtocol.protocol.RegistrationType"><c path="languageServerProtocol.protocol.RegistrationType.RO"/></x>
	</f>
	<meta><m n=":noCompletion"/></meta>
</_new></class>
	<abstract path="languageServerProtocol.protocol.ProtocolRequestType" params="P:R:PR:E:RO" file="src/languageServerProtocol/protocol/Messages.hx" module="languageServerProtocol.protocol.Messages">
		<this><c path="String"/></this>
		<to>
			<icast><c path="String"/></icast>
			<icast field="toRequestType"><x path="jsonrpc.RequestType">
	<c path="languageServerProtocol.protocol.ProtocolRequestType.P"/>
	<c path="languageServerProtocol.protocol.ProtocolRequestType.R"/>
	<c path="languageServerProtocol.protocol.ProtocolRequestType.E"/>
</x></icast>
			<icast field="toProgressType"><c path="jsonrpc.ProgressType"><c path="languageServerProtocol.protocol.ProtocolRequestType.PR"/></c></icast>
		</to>
		<impl><class path="languageServerProtocol.protocol._Messages.ProtocolRequestType_Impl_" params="" file="src/languageServerProtocol/protocol/Messages.hx" private="1" module="languageServerProtocol.protocol.Messages" final="1">
	<_new public="1" get="inline" set="null" line="14" static="1">
		<f a="method">
			<c path="String"/>
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<c path="languageServerProtocol.protocol.ProtocolRequestType.P"/>
				<c path="languageServerProtocol.protocol.ProtocolRequestType.R"/>
				<c path="languageServerProtocol.protocol.ProtocolRequestType.PR"/>
				<c path="languageServerProtocol.protocol.ProtocolRequestType.E"/>
				<c path="languageServerProtocol.protocol.ProtocolRequestType.RO"/>
			</x>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</_new>
	<toRequestType get="inline" set="null" line="18" static="1">
		<f a="this">
			<c path="String"/>
			<x path="jsonrpc.RequestType">
				<c path="languageServerProtocol.protocol.ProtocolRequestType.P"/>
				<c path="languageServerProtocol.protocol.ProtocolRequestType.R"/>
				<c path="languageServerProtocol.protocol.ProtocolRequestType.E"/>
			</x>
		</f>
		<meta><m n=":to"/></meta>
	</toRequestType>
	<toProgressType get="inline" set="null" line="22" static="1">
		<f a="this">
			<c path="String"/>
			<c path="jsonrpc.ProgressType"><c path="languageServerProtocol.protocol.ProtocolRequestType.PR"/></c>
		</f>
		<meta><m n=":to"/></meta>
	</toProgressType>
</class></impl>
	</abstract>
	<class path="languageServerProtocol.protocol._Messages.ProtocolRequestType_Impl_" params="" file="src/languageServerProtocol/protocol/Messages.hx" private="1" module="languageServerProtocol.protocol.Messages" final="1">
		<_new public="1" get="inline" set="null" line="14" static="1">
			<f a="method">
				<c path="String"/>
				<x path="languageServerProtocol.protocol.ProtocolRequestType">
					<c path="languageServerProtocol.protocol.ProtocolRequestType.P"/>
					<c path="languageServerProtocol.protocol.ProtocolRequestType.R"/>
					<c path="languageServerProtocol.protocol.ProtocolRequestType.PR"/>
					<c path="languageServerProtocol.protocol.ProtocolRequestType.E"/>
					<c path="languageServerProtocol.protocol.ProtocolRequestType.RO"/>
				</x>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_new>
		<toRequestType get="inline" set="null" line="18" static="1">
			<f a="this">
				<c path="String"/>
				<x path="jsonrpc.RequestType">
					<c path="languageServerProtocol.protocol.ProtocolRequestType.P"/>
					<c path="languageServerProtocol.protocol.ProtocolRequestType.R"/>
					<c path="languageServerProtocol.protocol.ProtocolRequestType.E"/>
				</x>
			</f>
			<meta><m n=":to"/></meta>
		</toRequestType>
		<toProgressType get="inline" set="null" line="22" static="1">
			<f a="this">
				<c path="String"/>
				<c path="jsonrpc.ProgressType"><c path="languageServerProtocol.protocol.ProtocolRequestType.PR"/></c>
			</f>
			<meta><m n=":to"/></meta>
		</toProgressType>
	</class>
	<abstract path="languageServerProtocol.protocol.ProtocolNotificationType" params="P:RO" file="src/languageServerProtocol/protocol/Messages.hx" module="languageServerProtocol.protocol.Messages">
		<this><c path="String"/></this>
		<to>
			<icast><c path="String"/></icast>
			<icast field="toNotificationType"><x path="jsonrpc.NotificationType"><c path="languageServerProtocol.protocol.ProtocolNotificationType.P"/></x></icast>
		</to>
		<impl><class path="languageServerProtocol.protocol._Messages.ProtocolNotificationType_Impl_" params="" file="src/languageServerProtocol/protocol/Messages.hx" private="1" module="languageServerProtocol.protocol.Messages" final="1">
	<_new public="1" get="inline" set="null" line="28" static="1">
		<f a="method">
			<c path="String"/>
			<x path="languageServerProtocol.protocol.ProtocolNotificationType">
				<c path="languageServerProtocol.protocol.ProtocolNotificationType.P"/>
				<c path="languageServerProtocol.protocol.ProtocolNotificationType.RO"/>
			</x>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</_new>
	<toNotificationType get="inline" set="null" line="32" static="1">
		<f a="this">
			<c path="String"/>
			<x path="jsonrpc.NotificationType"><c path="languageServerProtocol.protocol.ProtocolNotificationType.P"/></x>
		</f>
		<meta><m n=":to"/></meta>
	</toNotificationType>
</class></impl>
	</abstract>
	<class path="languageServerProtocol.protocol._Messages.ProtocolNotificationType_Impl_" params="" file="src/languageServerProtocol/protocol/Messages.hx" private="1" module="languageServerProtocol.protocol.Messages" final="1">
		<_new public="1" get="inline" set="null" line="28" static="1">
			<f a="method">
				<c path="String"/>
				<x path="languageServerProtocol.protocol.ProtocolNotificationType">
					<c path="languageServerProtocol.protocol.ProtocolNotificationType.P"/>
					<c path="languageServerProtocol.protocol.ProtocolNotificationType.RO"/>
				</x>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_new>
		<toNotificationType get="inline" set="null" line="32" static="1">
			<f a="this">
				<c path="String"/>
				<x path="jsonrpc.NotificationType"><c path="languageServerProtocol.protocol.ProtocolNotificationType.P"/></x>
			</f>
			<meta><m n=":to"/></meta>
		</toNotificationType>
	</class>
	<enum path="languageServerProtocol.protocol.Never" params="" file="src/languageServerProtocol/protocol/Messages.hx" module="languageServerProtocol.protocol.Messages"><meta><m n=":flatEnum"/></meta></enum>
	<abstract path="languageServerProtocol.protocol.UniquenessLevel" params="" file="src/languageServerProtocol/protocol/Moniker.hx" module="languageServerProtocol.protocol.Moniker">
		<this><c path="String"/></this>
		<haxe_doc>Moniker uniqueness level to define scope of the moniker.

	@since 3.16.0</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="languageServerProtocol.protocol._Moniker.UniquenessLevel_Impl_" params="" file="src/languageServerProtocol/protocol/Moniker.hx" private="1" module="languageServerProtocol.protocol.Moniker" extern="1" final="1">
	<Document public="1" get="inline" set="null" expr="cast &quot;document&quot;" line="14" static="1">
		<x path="languageServerProtocol.protocol.UniquenessLevel"/>
		<meta>
			<m n=":value"><e>cast "document"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>The moniker is only unique inside a document</haxe_doc>
	</Document>
	<Project public="1" get="inline" set="null" expr="cast &quot;project&quot;" line="19" static="1">
		<x path="languageServerProtocol.protocol.UniquenessLevel"/>
		<meta>
			<m n=":value"><e>cast "project"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>The moniker is unique inside a project for which a dump got created</haxe_doc>
	</Project>
	<Group public="1" get="inline" set="null" expr="cast &quot;group&quot;" line="24" static="1">
		<x path="languageServerProtocol.protocol.UniquenessLevel"/>
		<meta>
			<m n=":value"><e>cast "group"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>The moniker is unique inside the group to which a project belongs</haxe_doc>
	</Group>
	<Scheme public="1" get="inline" set="null" expr="cast &quot;scheme&quot;" line="29" static="1">
		<x path="languageServerProtocol.protocol.UniquenessLevel"/>
		<meta>
			<m n=":value"><e>cast "scheme"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>The moniker is unique inside the moniker scheme.</haxe_doc>
	</Scheme>
	<Global public="1" get="inline" set="null" expr="cast &quot;global&quot;" line="34" static="1">
		<x path="languageServerProtocol.protocol.UniquenessLevel"/>
		<meta>
			<m n=":value"><e>cast "global"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>The moniker is globally unique</haxe_doc>
	</Global>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="languageServerProtocol.protocol._Moniker.UniquenessLevel_Impl_" params="" file="src/languageServerProtocol/protocol/Moniker.hx" private="1" module="languageServerProtocol.protocol.Moniker" extern="1" final="1">
		<Document public="1" get="inline" set="null" expr="cast &quot;document&quot;" line="14" static="1">
			<x path="languageServerProtocol.protocol.UniquenessLevel"/>
			<meta>
				<m n=":value"><e>cast "document"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>The moniker is only unique inside a document</haxe_doc>
		</Document>
		<Project public="1" get="inline" set="null" expr="cast &quot;project&quot;" line="19" static="1">
			<x path="languageServerProtocol.protocol.UniquenessLevel"/>
			<meta>
				<m n=":value"><e>cast "project"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>The moniker is unique inside a project for which a dump got created</haxe_doc>
		</Project>
		<Group public="1" get="inline" set="null" expr="cast &quot;group&quot;" line="24" static="1">
			<x path="languageServerProtocol.protocol.UniquenessLevel"/>
			<meta>
				<m n=":value"><e>cast "group"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>The moniker is unique inside the group to which a project belongs</haxe_doc>
		</Group>
		<Scheme public="1" get="inline" set="null" expr="cast &quot;scheme&quot;" line="29" static="1">
			<x path="languageServerProtocol.protocol.UniquenessLevel"/>
			<meta>
				<m n=":value"><e>cast "scheme"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>The moniker is unique inside the moniker scheme.</haxe_doc>
		</Scheme>
		<Global public="1" get="inline" set="null" expr="cast &quot;global&quot;" line="34" static="1">
			<x path="languageServerProtocol.protocol.UniquenessLevel"/>
			<meta>
				<m n=":value"><e>cast "global"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>The moniker is globally unique</haxe_doc>
		</Global>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="languageServerProtocol.protocol.MonikerKind" params="" file="src/languageServerProtocol/protocol/Moniker.hx" module="languageServerProtocol.protocol.Moniker">
		<this><c path="String"/></this>
		<haxe_doc>The moniker kind.

	@since 3.16.0</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="languageServerProtocol.protocol._Moniker.MonikerKind_Impl_" params="" file="src/languageServerProtocol/protocol/Moniker.hx" private="1" module="languageServerProtocol.protocol.Moniker" extern="1" final="1">
	<Import public="1" get="inline" set="null" expr="cast &quot;import&quot;" line="46" static="1">
		<x path="languageServerProtocol.protocol.MonikerKind"/>
		<meta>
			<m n=":value"><e>cast "import"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>The moniker represent a symbol that is imported into a project</haxe_doc>
	</Import>
	<Export public="1" get="inline" set="null" expr="cast &quot;export&quot;" line="51" static="1">
		<x path="languageServerProtocol.protocol.MonikerKind"/>
		<meta>
			<m n=":value"><e>cast "export"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>The moniker represents a symbol that is exported from a project</haxe_doc>
	</Export>
	<Local public="1" get="inline" set="null" expr="cast &quot;local&quot;" line="57" static="1">
		<x path="languageServerProtocol.protocol.MonikerKind"/>
		<meta>
			<m n=":value"><e>cast "local"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>The moniker represents a symbol that is local to a project (e.g. a local
		variable of a function, a class not visible outside the project, ...)</haxe_doc>
	</Local>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="languageServerProtocol.protocol._Moniker.MonikerKind_Impl_" params="" file="src/languageServerProtocol/protocol/Moniker.hx" private="1" module="languageServerProtocol.protocol.Moniker" extern="1" final="1">
		<Import public="1" get="inline" set="null" expr="cast &quot;import&quot;" line="46" static="1">
			<x path="languageServerProtocol.protocol.MonikerKind"/>
			<meta>
				<m n=":value"><e>cast "import"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>The moniker represent a symbol that is imported into a project</haxe_doc>
		</Import>
		<Export public="1" get="inline" set="null" expr="cast &quot;export&quot;" line="51" static="1">
			<x path="languageServerProtocol.protocol.MonikerKind"/>
			<meta>
				<m n=":value"><e>cast "export"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>The moniker represents a symbol that is exported from a project</haxe_doc>
		</Export>
		<Local public="1" get="inline" set="null" expr="cast &quot;local&quot;" line="57" static="1">
			<x path="languageServerProtocol.protocol.MonikerKind"/>
			<meta>
				<m n=":value"><e>cast "local"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>The moniker represents a symbol that is local to a project (e.g. a local
		variable of a function, a class not visible outside the project, ...)</haxe_doc>
		</Local>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="languageServerProtocol.protocol.Moniker" params="" file="src/languageServerProtocol/protocol/Moniker.hx">
		<a>
			<unique>
				<x path="languageServerProtocol.protocol.UniquenessLevel"/>
				<haxe_doc>The scope in which the moniker is unique</haxe_doc>
			</unique>
			<scheme>
				<c path="String"/>
				<haxe_doc>The scheme of the moniker. For example tsc or .Net</haxe_doc>
			</scheme>
			<kind>
				<x path="Null"><x path="languageServerProtocol.protocol.MonikerKind"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The moniker kind if known.</haxe_doc>
			</kind>
			<identifier>
				<c path="String"/>
				<haxe_doc>The identifier of the moniker. The value is opaque in LSIF however
		schema owners are allowed to define the structure if they want.</haxe_doc>
			</identifier>
		</a>
		<haxe_doc>Moniker definition to match LSIF 0.5 moniker definition.

	@since 3.16.0</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.MonikerClientCapabilities" params="" file="src/languageServerProtocol/protocol/Moniker.hx" module="languageServerProtocol.protocol.Moniker">
		<a><dynamicRegistration>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>Whether moniker supports dynamic registration. If this is set to `true`
		the client supports the new `MonikerRegistrationOptions` return value
		for the corresponding server capability as well.</haxe_doc>
</dynamicRegistration></a>
		<haxe_doc>Client capabilities specific to the moniker request.

	@since 3.16.0</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.MonikerServerCapabilities" params="" file="src/languageServerProtocol/protocol/Moniker.hx" module="languageServerProtocol.protocol.Moniker"><a/></typedef>
	<typedef path="languageServerProtocol.protocol.MonikerOptions" params="" file="src/languageServerProtocol/protocol/Moniker.hx" module="languageServerProtocol.protocol.Moniker"><t path="languageServerProtocol.protocol.WorkDoneProgressOptions"/></typedef>
	<typedef path="languageServerProtocol.protocol.MonikerRegistrationOptions" params="" file="src/languageServerProtocol/protocol/Moniker.hx" module="languageServerProtocol.protocol.Moniker"><a>
	<workDoneProgress>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</workDoneProgress>
	<documentSelector>
		<x path="Null"><t path="languageServerProtocol.protocol.DocumentSelector"/></x>
		<haxe_doc>A document selector to identify the scope of the registration. If set to null
		the document selector provided on the client side will be used.</haxe_doc>
	</documentSelector>
</a></typedef>
	<typedef path="languageServerProtocol.protocol.MonikerParams" params="" file="src/languageServerProtocol/protocol/Moniker.hx" module="languageServerProtocol.protocol.Moniker"><a>
	<workDoneToken>
		<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>An optional token that a server can use to report work done progress.</haxe_doc>
	</workDoneToken>
	<textDocument>
		<t path="languageServerProtocol.TextDocumentIdentifier"/>
		<haxe_doc>The text document.</haxe_doc>
	</textDocument>
	<position>
		<t path="languageServerProtocol.textdocument.Position"/>
		<haxe_doc>The position inside the text document.</haxe_doc>
	</position>
	<partialResultToken>
		<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>An optional token that a server can use to report partial results (e.g. streaming) to
		the client.</haxe_doc>
	</partialResultToken>
</a></typedef>
	<class path="languageServerProtocol.protocol.MonikerRequest" params="" file="src/languageServerProtocol/protocol/Moniker.hx" module="languageServerProtocol.protocol.Moniker">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;MonikerParams,Null&lt;Array&lt;Moniker&gt;&gt;,Array&lt;Moniker&gt;,NoData,MonikerRegistrationOptions&gt;(&quot;textDocument/moniker&quot;)" line="113" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.MonikerParams"/>
				<x path="Null"><c path="Array"><t path="languageServerProtocol.protocol.Moniker"/></c></x>
				<c path="Array"><t path="languageServerProtocol.protocol.Moniker"/></c>
				<e path="jsonrpc.NoData"/>
				<t path="languageServerProtocol.protocol.MonikerRegistrationOptions"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<MonikerParams,Null<Array<Moniker>>,Array<Moniker>,NoData,MonikerRegistrationOptions>("textDocument/moniker")]]></e></m></meta>
		</type>
		<haxe_doc>A request to get the moniker of a symbol at a given text document position.
	The request parameter is of type [TextDocumentPositionParams](#TextDocumentPositionParams).
	The response is of type [Moniker[]](#Moniker[]) or `null`.</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.WorkDoneProgressClientCapabilities" params="" file="src/languageServerProtocol/protocol/Progress.hx" module="languageServerProtocol.protocol.Progress"><a><workDoneProgress>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>Whether client supports handling progress notifications. If set servers are allowed to
		report in `workDoneProgress` property in the request specific server capabilities.

		Since 3.15.0</haxe_doc>
</workDoneProgress></a></typedef>
	<abstract path="languageServerProtocol.protocol.WorkDoneProgressBeginKind" params="" file="src/languageServerProtocol/protocol/Progress.hx" module="languageServerProtocol.protocol.Progress">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="languageServerProtocol.protocol._Progress.WorkDoneProgressBeginKind_Impl_" params="" file="src/languageServerProtocol/protocol/Progress.hx" private="1" module="languageServerProtocol.protocol.Progress" extern="1" final="1">
	<Begin public="1" get="inline" set="null" expr="cast &quot;begin&quot;" line="16" static="1">
		<x path="languageServerProtocol.protocol.WorkDoneProgressBeginKind"/>
		<meta>
			<m n=":value"><e>cast "begin"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Begin>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="languageServerProtocol.protocol._Progress.WorkDoneProgressBeginKind_Impl_" params="" file="src/languageServerProtocol/protocol/Progress.hx" private="1" module="languageServerProtocol.protocol.Progress" extern="1" final="1">
		<Begin public="1" get="inline" set="null" expr="cast &quot;begin&quot;" line="16" static="1">
			<x path="languageServerProtocol.protocol.WorkDoneProgressBeginKind"/>
			<meta>
				<m n=":value"><e>cast "begin"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Begin>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="languageServerProtocol.protocol.WorkDoneProgressBegin" params="" file="src/languageServerProtocol/protocol/Progress.hx" module="languageServerProtocol.protocol.Progress"><a>
	<title>
		<c path="String"/>
		<haxe_doc>Mandatory title of the progress operation. Used to briefly inform about
		the kind of operation being performed.

		Examples: "Indexing" or "Linking dependencies".</haxe_doc>
	</title>
	<percentage>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Optional progress percentage to display (value 100 is considered 100%).
		If not provided infinite progress is assumed and clients are allowed
		to ignore the `percentage` value in subsequent in report notifications.

		The value should be steadily rising. Clients are free to ignore values
		that are not following this rule.</haxe_doc>
	</percentage>
	<message>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Optional, more detailed associated progress message. Contains
		complementary information to the `title`.

		Examples: "3/25 files", "project/src/module2", "node_modules/some_dep".
		If unset, the previous progress message (if any) is still valid.</haxe_doc>
	</message>
	<kind><x path="languageServerProtocol.protocol.WorkDoneProgressBeginKind"/></kind>
	<cancellable>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Controls if a cancel button should show to allow the user to cancel the
		long running operation. Clients that don't support cancellation are allowed
		to ignore the setting.</haxe_doc>
	</cancellable>
</a></typedef>
	<abstract path="languageServerProtocol.protocol.WorkDoneProgressReportKind" params="" file="src/languageServerProtocol/protocol/Progress.hx" module="languageServerProtocol.protocol.Progress">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="languageServerProtocol.protocol._Progress.WorkDoneProgressReportKind_Impl_" params="" file="src/languageServerProtocol/protocol/Progress.hx" private="1" module="languageServerProtocol.protocol.Progress" extern="1" final="1">
	<Report public="1" get="inline" set="null" expr="cast &quot;report&quot;" line="58" static="1">
		<x path="languageServerProtocol.protocol.WorkDoneProgressReportKind"/>
		<meta>
			<m n=":value"><e>cast "report"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Report>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="languageServerProtocol.protocol._Progress.WorkDoneProgressReportKind_Impl_" params="" file="src/languageServerProtocol/protocol/Progress.hx" private="1" module="languageServerProtocol.protocol.Progress" extern="1" final="1">
		<Report public="1" get="inline" set="null" expr="cast &quot;report&quot;" line="58" static="1">
			<x path="languageServerProtocol.protocol.WorkDoneProgressReportKind"/>
			<meta>
				<m n=":value"><e>cast "report"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Report>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="languageServerProtocol.protocol.WorkDoneProgressReport" params="" file="src/languageServerProtocol/protocol/Progress.hx" module="languageServerProtocol.protocol.Progress"><a>
	<percentage>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Optional progress percentage to display (value 100 is considered 100%).
		If not provided infinite progress is assumed and clients are allowed
		to ignore the `percentage` value in subsequent in report notifications.

		The value should be steadily rising. Clients are free to ignore values
		that are not following this rule.</haxe_doc>
	</percentage>
	<message>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Optional, more detailed associated progress message. Contains
		complementary information to the `title`.

		Examples: "3/25 files", "project/src/module2", "node_modules/some_dep".
		If unset, the previous progress message (if any) is still valid.</haxe_doc>
	</message>
	<kind><x path="languageServerProtocol.protocol.WorkDoneProgressReportKind"/></kind>
	<cancellable>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Controls enablement state of a cancel button.

		Clients that don't support cancellation or don't support controlling the button's
		enablement state are allowed to ignore the property.</haxe_doc>
	</cancellable>
</a></typedef>
	<abstract path="languageServerProtocol.protocol.WorkDoneProgressEndKind" params="" file="src/languageServerProtocol/protocol/Progress.hx" module="languageServerProtocol.protocol.Progress">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="languageServerProtocol.protocol._Progress.WorkDoneProgressEndKind_Impl_" params="" file="src/languageServerProtocol/protocol/Progress.hx" private="1" module="languageServerProtocol.protocol.Progress" extern="1" final="1">
	<End public="1" get="inline" set="null" expr="cast &quot;end&quot;" line="93" static="1">
		<x path="languageServerProtocol.protocol.WorkDoneProgressEndKind"/>
		<meta>
			<m n=":value"><e>cast "end"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</End>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="languageServerProtocol.protocol._Progress.WorkDoneProgressEndKind_Impl_" params="" file="src/languageServerProtocol/protocol/Progress.hx" private="1" module="languageServerProtocol.protocol.Progress" extern="1" final="1">
		<End public="1" get="inline" set="null" expr="cast &quot;end&quot;" line="93" static="1">
			<x path="languageServerProtocol.protocol.WorkDoneProgressEndKind"/>
			<meta>
				<m n=":value"><e>cast "end"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</End>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="languageServerProtocol.protocol.WorkDoneProgressEnd" params="" file="src/languageServerProtocol/protocol/Progress.hx" module="languageServerProtocol.protocol.Progress"><a>
	<message>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Optional, a final message indicating to for example indicate the outcome
		of the operation.</haxe_doc>
	</message>
	<kind><x path="languageServerProtocol.protocol.WorkDoneProgressEndKind"/></kind>
</a></typedef>
	<class path="languageServerProtocol.protocol.WorkDoneProgress" params="" file="src/languageServerProtocol/protocol/Progress.hx" module="languageServerProtocol.protocol.Progress"><type final="1" public="1" set="null" expr="new ProgressType&lt;EitherType&lt;WorkDoneProgressBegin,EitherType&lt;WorkDoneProgressReport,WorkDoneProgressEnd&gt;&gt;&gt;()" line="107" static="1">
	<c path="jsonrpc.ProgressType"><x path="haxe.extern.EitherType">
	<t path="languageServerProtocol.protocol.WorkDoneProgressBegin"/>
	<x path="haxe.extern.EitherType">
		<t path="languageServerProtocol.protocol.WorkDoneProgressReport"/>
		<t path="languageServerProtocol.protocol.WorkDoneProgressEnd"/>
	</x>
</x></c>
	<meta><m n=":value"><e><![CDATA[new ProgressType<EitherType<WorkDoneProgressBegin,EitherType<WorkDoneProgressReport,WorkDoneProgressEnd>>>()]]></e></m></meta>
</type></class>
	<typedef path="languageServerProtocol.protocol.WorkDoneProgressCreateParams" params="" file="src/languageServerProtocol/protocol/Progress.hx" module="languageServerProtocol.protocol.Progress"><a><token>
	<t path="jsonrpc.ProgressToken"/>
	<haxe_doc>The token to be used to report progress.</haxe_doc>
</token></a></typedef>
	<class path="languageServerProtocol.protocol.WorkDoneProgressCreateRequest" params="" file="src/languageServerProtocol/protocol/Progress.hx" module="languageServerProtocol.protocol.Progress">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;WorkDoneProgressCreateParams,NoData,Never,NoData,NoData&gt;(&quot;window/workDoneProgress/create&quot;)" line="122" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.WorkDoneProgressCreateParams"/>
				<e path="jsonrpc.NoData"/>
				<e path="languageServerProtocol.protocol.Never"/>
				<e path="jsonrpc.NoData"/>
				<e path="jsonrpc.NoData"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<WorkDoneProgressCreateParams,NoData,Never,NoData,NoData>("window/workDoneProgress/create")]]></e></m></meta>
		</type>
		<haxe_doc>The `window/workDoneProgress/create` request is sent from the server to the client to initiate progress
	reporting from the server.</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.WorkDoneProgressCancelParams" params="" file="src/languageServerProtocol/protocol/Progress.hx" module="languageServerProtocol.protocol.Progress"><a><token>
	<t path="jsonrpc.ProgressToken"/>
	<haxe_doc>The token to be used to report progress.</haxe_doc>
</token></a></typedef>
	<class path="languageServerProtocol.protocol.WorkDoneProgressCancelNotification" params="" file="src/languageServerProtocol/protocol/Progress.hx" module="languageServerProtocol.protocol.Progress">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolNotificationType&lt;WorkDoneProgressCancelParams,NoData&gt;(&quot;window/workDoneProgress/cancel&quot;)" line="137" static="1">
			<x path="languageServerProtocol.protocol.ProtocolNotificationType">
				<t path="languageServerProtocol.protocol.WorkDoneProgressCancelParams"/>
				<e path="jsonrpc.NoData"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolNotificationType<WorkDoneProgressCancelParams,NoData>("window/workDoneProgress/cancel")]]></e></m></meta>
		</type>
		<haxe_doc>The `window/workDoneProgress/cancel` notification is sent from  the client to the server to cancel a progress
	initiated on the server side.</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.RequestType" params="TParams:TResponse:TError:TRegistrationOptions" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol"><x path="jsonrpc.RequestType">
	<c path="languageServerProtocol.protocol.RequestType.TParams"/>
	<c path="languageServerProtocol.protocol.RequestType.TResponse"/>
	<c path="languageServerProtocol.protocol.RequestType.TError"/>
</x></typedef>
	<typedef path="languageServerProtocol.protocol.NotificationType" params="TParams:TRegistrationOptions" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol"><x path="jsonrpc.NotificationType"><c path="languageServerProtocol.protocol.NotificationType.TParams"/></x></typedef>
	<abstract path="languageServerProtocol.protocol.ResponseError" params="T" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<this><t path="jsonrpc.ResponseErrorData"/></this>
		<to><icast><t path="jsonrpc.ResponseErrorData"/></icast></to>
		<impl><class path="languageServerProtocol.protocol._Protocol.ResponseError_Impl_" params="" file="src/languageServerProtocol/protocol/Protocol.hx" private="1" module="languageServerProtocol.protocol.Protocol" final="1">
	<RequestCancelled final="1" public="1" get="inline" set="null" expr="-32800" line="29" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>-32800</e></m></meta>
	</RequestCancelled>
	<ContentModified final="1" public="1" get="inline" set="null" expr="-32801" line="30" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>-32801</e></m></meta>
	</ContentModified>
</class></impl>
	</abstract>
	<class path="languageServerProtocol.protocol._Protocol.ResponseError_Impl_" params="" file="src/languageServerProtocol/protocol/Protocol.hx" private="1" module="languageServerProtocol.protocol.Protocol" final="1">
		<RequestCancelled final="1" public="1" get="inline" set="null" expr="-32800" line="29" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-32800</e></m></meta>
		</RequestCancelled>
		<ContentModified final="1" public="1" get="inline" set="null" expr="-32801" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-32801</e></m></meta>
		</ContentModified>
	</class>
	<typedef path="languageServerProtocol.protocol.TextDocumentFilter" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<scheme>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>A Uri [scheme](#Uri.scheme), like `file` or `untitled`.</haxe_doc>
			</scheme>
			<pattern>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>A glob pattern, like `*.{hx,hxml}`.</haxe_doc>
			</pattern>
			<language>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>A language id, like `haxe`.</haxe_doc>
			</language>
		</a>
		<haxe_doc>A document filter denotes a document by different properties like
	the `TextDocument.languageId`, the `Uri.scheme` of
	its resource, or a glob-pattern that is applied to the `TextDocument.fileName`.

	Glob patterns can have the following syntax:
	- `*` to match one or more characters in a path segment
	- `?` to match on one character in a path segment
	- `**` to match any number of path segments, including none
	- `{}` to group conditions (e.g. `**​/*.{ts,js}` matches all TypeScript and JavaScript files)
	- `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, …)
	- `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)

	@sample A language filter that applies to typescript files on disk: `{ language: 'typescript', scheme: 'file' }`
	@sample A language filter that applies to all package.json paths: `{ language: 'json', pattern: '**package.json' }`</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.NotebookDocumentFilter" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<scheme>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>A Uri [scheme](#Uri.scheme), like `file` or `untitled`.</haxe_doc>
			</scheme>
			<pattern>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>A glob pattern.</haxe_doc>
			</pattern>
			<notebookType>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The type of the enclosing notebook.</haxe_doc>
			</notebookType>
		</a>
		<haxe_doc>A notebook document filter denotes a notebook document by
	different properties. The properties will be match
	against the notebook's URI (same as with documents)

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.NotebookCellTextDocumentFilter" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<notebook>
				<x path="haxe.extern.EitherType">
					<c path="String"/>
					<t path="languageServerProtocol.protocol.NotebookDocumentFilter"/>
				</x>
				<haxe_doc>A filter that matches against the notebook
		containing the notebook cell. If a string
		value is provided it matches against the
		notebook type. '*' matches every notebook.</haxe_doc>
			</notebook>
			<language>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>A language id like `python`.

		Will be matched against the language id of the
		notebook cell document. '*' matches every language.</haxe_doc>
			</language>
		</a>
		<haxe_doc>A notebook cell text document filter denotes a cell text
	document by different properties.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.DocumentFilter" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<x path="haxe.extern.EitherType">
			<t path="languageServerProtocol.protocol.TextDocumentFilter"/>
			<t path="languageServerProtocol.protocol.NotebookCellTextDocumentFilter"/>
		</x>
		<haxe_doc>A document filter describes a top level text document or
	a notebook cell document.

	@since 3.17.0 - proposed support for NotebookCellTextDocumentFilter.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.DocumentSelector" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<c path="Array"><x path="haxe.extern.EitherType">
	<c path="String"/>
	<t path="languageServerProtocol.protocol.DocumentFilter"/>
</x></c>
		<haxe_doc>A document selector is the combination of one or many document filters.

	@sample `let sel:DocumentSelector = [{ language: 'typescript' }, { language: 'json', pattern: '**∕tsconfig.json' }]`;</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.Registration" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<registerOptions>
				<x path="Null"><t path="languageServerProtocol.LSPAny"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Options necessary for the registration.</haxe_doc>
			</registerOptions>
			<method>
				<c path="String"/>
				<haxe_doc>The method to register for.</haxe_doc>
			</method>
			<id>
				<c path="String"/>
				<haxe_doc>The id used to register the request. The id can be used to deregister
		the request again.</haxe_doc>
			</id>
		</a>
		<haxe_doc>General parameters to to register for an notification or to register a provider.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.RegistrationParams" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol"><a><registrations><c path="Array"><t path="languageServerProtocol.protocol.Registration"/></c></registrations></a></typedef>
	<class path="languageServerProtocol.protocol.RegistrationRequest" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;RegistrationParams,NoData,Never,NoData,NoData&gt;(&quot;client/registerCapability&quot;)" line="155" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.RegistrationParams"/>
				<e path="jsonrpc.NoData"/>
				<e path="languageServerProtocol.protocol.Never"/>
				<e path="jsonrpc.NoData"/>
				<e path="jsonrpc.NoData"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<RegistrationParams,NoData,Never,NoData,NoData>("client/registerCapability")]]></e></m></meta>
		</type>
		<haxe_doc>The `client/registerCapability` request is sent from the server to the client to register a new capability
	handler on the client side.</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.Unregistration" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<method>
				<c path="String"/>
				<haxe_doc>The method / capability to unregister for.</haxe_doc>
			</method>
			<id>
				<c path="String"/>
				<haxe_doc>The id used to unregister the request or notification. Usually an id
		provided during the register request.</haxe_doc>
			</id>
		</a>
		<haxe_doc>General parameters to unregister a request or notification.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.UnregistrationParams" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol"><a><unregisterations><c path="Array"><t path="languageServerProtocol.protocol.Unregistration"/></c></unregisterations></a></typedef>
	<class path="languageServerProtocol.protocol.UnregistrationRequest" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;UnregistrationParams,NoData,Never,NoData,NoData&gt;(&quot;client/unregisterCapability&quot;)" line="186" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.UnregistrationParams"/>
				<e path="jsonrpc.NoData"/>
				<e path="languageServerProtocol.protocol.Never"/>
				<e path="jsonrpc.NoData"/>
				<e path="jsonrpc.NoData"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<UnregistrationParams,NoData,Never,NoData,NoData>("client/unregisterCapability")]]></e></m></meta>
		</type>
		<haxe_doc>The `client/unregisterCapability` request is sent from the server to the client to unregister a previously registered capability
	handler on the client side.</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.WorkDoneProgressParams" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol"><a><workDoneToken>
	<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>An optional token that a server can use to report work done progress.</haxe_doc>
</workDoneToken></a></typedef>
	<typedef path="languageServerProtocol.protocol.PartialResultParams" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol"><a><partialResultToken>
	<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>An optional token that a server can use to report partial results (e.g. streaming) to
		the client.</haxe_doc>
</partialResultToken></a></typedef>
	<typedef path="languageServerProtocol.protocol.TextDocumentPositionParams" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<textDocument>
				<t path="languageServerProtocol.TextDocumentIdentifier"/>
				<haxe_doc>The text document.</haxe_doc>
			</textDocument>
			<position>
				<t path="languageServerProtocol.textdocument.Position"/>
				<haxe_doc>The position inside the text document.</haxe_doc>
			</position>
		</a>
		<haxe_doc>A parameter literal used in requests to pass a text document and a position inside that document.</haxe_doc>
	</typedef>
	<abstract path="languageServerProtocol.protocol.ResourceOperationKind" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<this><c path="String"/></this>
		<haxe_doc>The kind of resource operations supported by the client.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="languageServerProtocol.protocol._Protocol.ResourceOperationKind_Impl_" params="" file="src/languageServerProtocol/protocol/Protocol.hx" private="1" module="languageServerProtocol.protocol.Protocol" extern="1" final="1">
	<Create public="1" get="inline" set="null" expr="cast &quot;create&quot;" line="228" static="1">
		<x path="languageServerProtocol.protocol.ResourceOperationKind"/>
		<meta>
			<m n=":value"><e>cast "create"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Supports creating new files and folders.</haxe_doc>
	</Create>
	<Rename public="1" get="inline" set="null" expr="cast &quot;rename&quot;" line="233" static="1">
		<x path="languageServerProtocol.protocol.ResourceOperationKind"/>
		<meta>
			<m n=":value"><e>cast "rename"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Supports renaming existing files and folders.</haxe_doc>
	</Rename>
	<Delete public="1" get="inline" set="null" expr="cast &quot;delete&quot;" line="238" static="1">
		<x path="languageServerProtocol.protocol.ResourceOperationKind"/>
		<meta>
			<m n=":value"><e>cast "delete"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Supports deleting existing files and folders.</haxe_doc>
	</Delete>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="languageServerProtocol.protocol._Protocol.ResourceOperationKind_Impl_" params="" file="src/languageServerProtocol/protocol/Protocol.hx" private="1" module="languageServerProtocol.protocol.Protocol" extern="1" final="1">
		<Create public="1" get="inline" set="null" expr="cast &quot;create&quot;" line="228" static="1">
			<x path="languageServerProtocol.protocol.ResourceOperationKind"/>
			<meta>
				<m n=":value"><e>cast "create"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Supports creating new files and folders.</haxe_doc>
		</Create>
		<Rename public="1" get="inline" set="null" expr="cast &quot;rename&quot;" line="233" static="1">
			<x path="languageServerProtocol.protocol.ResourceOperationKind"/>
			<meta>
				<m n=":value"><e>cast "rename"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Supports renaming existing files and folders.</haxe_doc>
		</Rename>
		<Delete public="1" get="inline" set="null" expr="cast &quot;delete&quot;" line="238" static="1">
			<x path="languageServerProtocol.protocol.ResourceOperationKind"/>
			<meta>
				<m n=":value"><e>cast "delete"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Supports deleting existing files and folders.</haxe_doc>
		</Delete>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="languageServerProtocol.protocol.FailureHandlingKind" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="languageServerProtocol.protocol._Protocol.FailureHandlingKind_Impl_" params="" file="src/languageServerProtocol/protocol/Protocol.hx" private="1" module="languageServerProtocol.protocol.Protocol" extern="1" final="1">
	<Abort public="1" get="inline" set="null" expr="cast &quot;abort&quot;" line="246" static="1">
		<x path="languageServerProtocol.protocol.FailureHandlingKind"/>
		<meta>
			<m n=":value"><e>cast "abort"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Applying the workspace change is simply aborted if one of the changes provided
		fails. All operations executed before the failing operation stay executed.</haxe_doc>
	</Abort>
	<Transactional public="1" get="inline" set="null" expr="cast &quot;transactional&quot;" line="252" static="1">
		<x path="languageServerProtocol.protocol.FailureHandlingKind"/>
		<meta>
			<m n=":value"><e>cast "transactional"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>All operations are executed transactional. That means they either all
		succeed or no changes at all are applied to the workspace.</haxe_doc>
	</Transactional>
	<TextOnlyTransactional public="1" get="inline" set="null" expr="cast &quot;textOnlyTransactional&quot;" line="259" static="1">
		<x path="languageServerProtocol.protocol.FailureHandlingKind"/>
		<meta>
			<m n=":value"><e>cast "textOnlyTransactional"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>If the workspace edit contains only textual file changes they are executed transactional.
		If resource changes (create, rename or delete file) are part of the change the failure
		handling startegy is abort.</haxe_doc>
	</TextOnlyTransactional>
	<Undo public="1" get="inline" set="null" expr="cast &quot;undo&quot;" line="265" static="1">
		<x path="languageServerProtocol.protocol.FailureHandlingKind"/>
		<meta>
			<m n=":value"><e>cast "undo"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>The client tries to undo the operations already executed. But there is no
		guaruntee that this is succeeding.</haxe_doc>
	</Undo>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="languageServerProtocol.protocol._Protocol.FailureHandlingKind_Impl_" params="" file="src/languageServerProtocol/protocol/Protocol.hx" private="1" module="languageServerProtocol.protocol.Protocol" extern="1" final="1">
		<Abort public="1" get="inline" set="null" expr="cast &quot;abort&quot;" line="246" static="1">
			<x path="languageServerProtocol.protocol.FailureHandlingKind"/>
			<meta>
				<m n=":value"><e>cast "abort"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Applying the workspace change is simply aborted if one of the changes provided
		fails. All operations executed before the failing operation stay executed.</haxe_doc>
		</Abort>
		<Transactional public="1" get="inline" set="null" expr="cast &quot;transactional&quot;" line="252" static="1">
			<x path="languageServerProtocol.protocol.FailureHandlingKind"/>
			<meta>
				<m n=":value"><e>cast "transactional"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>All operations are executed transactional. That means they either all
		succeed or no changes at all are applied to the workspace.</haxe_doc>
		</Transactional>
		<TextOnlyTransactional public="1" get="inline" set="null" expr="cast &quot;textOnlyTransactional&quot;" line="259" static="1">
			<x path="languageServerProtocol.protocol.FailureHandlingKind"/>
			<meta>
				<m n=":value"><e>cast "textOnlyTransactional"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>If the workspace edit contains only textual file changes they are executed transactional.
		If resource changes (create, rename or delete file) are part of the change the failure
		handling startegy is abort.</haxe_doc>
		</TextOnlyTransactional>
		<Undo public="1" get="inline" set="null" expr="cast &quot;undo&quot;" line="265" static="1">
			<x path="languageServerProtocol.protocol.FailureHandlingKind"/>
			<meta>
				<m n=":value"><e>cast "undo"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>The client tries to undo the operations already executed. But there is no
		guaruntee that this is succeeding.</haxe_doc>
		</Undo>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="languageServerProtocol.protocol.WorkspaceClientCapabilites" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<workspaceFolders>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The client has support for workspace folders

		@since 3.6.0</haxe_doc>
			</workspaceFolders>
			<workspaceEdit>
				<x path="Null"><t path="languageServerProtocol.protocol.WorkspaceEditClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Capabilities specific to `WorkspaceEdit`s</haxe_doc>
			</workspaceEdit>
			<symbol>
				<x path="Null"><t path="languageServerProtocol.protocol.WorkspaceSymbolClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Capabilities specific to the `workspace/symbol` request.</haxe_doc>
			</symbol>
			<semanticTokens>
				<x path="Null"><t path="languageServerProtocol.protocol.SemanticTokensWorkspaceClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Capabilities specific to the semantic token requests scoped to the
		workspace.

		@since 3.16.0</haxe_doc>
			</semanticTokens>
			<inlineValue>
				<x path="Null"><t path="languageServerProtocol.protocol.proposed.InlineValueWorkspaceClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Capabilities specific to the inline values requests scoped to the
		workspace.

		@since 3.17.0
		@proposed</haxe_doc>
			</inlineValue>
			<inlayHint>
				<x path="Null"><t path="languageServerProtocol.protocol.proposed.InlayHintWorkspaceClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Capabilities specific to the inlay hints requests scoped to the
		workspace.

		@since 3.17.0
		@proposed</haxe_doc>
			</inlayHint>
			<fileOperations>
				<x path="Null"><t path="languageServerProtocol.protocol.FileOperationClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The client has support for file notifications/requests for user operations on files.

		Since 3.16.0</haxe_doc>
			</fileOperations>
			<executeCommand>
				<x path="Null"><t path="languageServerProtocol.protocol.ExecuteCommandClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Capabilities specific to the `workspace/executeCommand` request.</haxe_doc>
			</executeCommand>
			<didChangeWatchedFiles>
				<x path="Null"><t path="languageServerProtocol.protocol.DidChangeWatchedFilesClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Capabilities specific to the `workspace/didChangeWatchedFiles` notification.</haxe_doc>
			</didChangeWatchedFiles>
			<didChangeConfiguration>
				<x path="Null"><t path="languageServerProtocol.protocol.DidChangeConfigurationClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Capabilities specific to the `workspace/didChangeConfiguration` notification.</haxe_doc>
			</didChangeConfiguration>
			<diagnostics>
				<x path="Null"><t path="languageServerProtocol.protocol.proposed.DiagnosticWorkspaceClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Capabilities specific to the diagnostic requests scoped to the
		workspace.

		@since 3.17.0
		@proposed</haxe_doc>
			</diagnostics>
			<configuration>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The client supports `workspace/configuration` requests.

		@since 3.6.0</haxe_doc>
			</configuration>
			<codeLens>
				<x path="Null"><t path="languageServerProtocol.protocol.CodeLensWorkspaceClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Capabilities specific to the code lens requests scoped to the
		workspace.

		@since 3.16.0</haxe_doc>
			</codeLens>
			<applyEdit>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The client supports applying batch edits to the workspace by supporting
		the request 'workspace/applyEdit'</haxe_doc>
			</applyEdit>
		</a>
		<haxe_doc>Workspace specific client capabilities.

	Define capabilities the editor / tool provides on the workspace.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.TextDocumentClientCapabilities" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<typeHierarchy>
				<x path="Null"><t path="languageServerProtocol.protocol.proposed.TypeHierarchyClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Capabilities specific to the various type hierarchy requests.

		@since 3.17.0
		@proposed</haxe_doc>
			</typeHierarchy>
			<typeDefinition>
				<x path="Null"><t path="languageServerProtocol.protocol.TypeDefinitionClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Capabilities specific to the `textDocument/typeDefinition`

		@since 3.6.0</haxe_doc>
			</typeDefinition>
			<synchronization>
				<x path="Null"><t path="languageServerProtocol.protocol.TextDocumentSyncClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Defines which synchronization capabilities the client supports.</haxe_doc>
			</synchronization>
			<signatureHelp>
				<x path="Null"><t path="languageServerProtocol.protocol.SignatureHelpClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Capabilities specific to the `textDocument/signatureHelp`</haxe_doc>
			</signatureHelp>
			<semanticTokens>
				<x path="Null"><t path="languageServerProtocol.protocol.SemanticTokensClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Capabilities specific to the various semantic token request.

		@since 3.16.0</haxe_doc>
			</semanticTokens>
			<selectionRange>
				<x path="Null"><t path="languageServerProtocol.protocol.SelectionRangeClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Capabilities specific to `textDocument/selectionRange` requests

		@since 3.15.0</haxe_doc>
			</selectionRange>
			<rename>
				<x path="Null"><t path="languageServerProtocol.protocol.RenameClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Capabilities specific to the `textDocument/rename`</haxe_doc>
			</rename>
			<references>
				<x path="Null"><t path="languageServerProtocol.protocol.ReferenceClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Capabilities specific to the `textDocument/references`</haxe_doc>
			</references>
			<rangeFormatting>
				<x path="Null"><t path="languageServerProtocol.protocol.DocumentRangeFormattingClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Capabilities specific to the `textDocument/rangeFormatting`</haxe_doc>
			</rangeFormatting>
			<publishDiagnostics>
				<x path="Null"><t path="languageServerProtocol.protocol.PublishDiagnosticsClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Capabilities specific to `textDocument/publishDiagnostics`.</haxe_doc>
			</publishDiagnostics>
			<onTypeFormatting>
				<x path="Null"><t path="languageServerProtocol.protocol.DocumentOnTypeFormattingClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Capabilities specific to the `textDocument/onTypeFormatting`</haxe_doc>
			</onTypeFormatting>
			<moniker>
				<x path="Null"><t path="languageServerProtocol.protocol.MonikerClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Client capabilities specific to the moniker request.

		@since 3.16.0</haxe_doc>
			</moniker>
			<linkedEditingRange>
				<x path="Null"><t path="languageServerProtocol.protocol.LinkedEditingRangeClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Capabilities specific to the linked editing range request.

		@since 3.16.0</haxe_doc>
			</linkedEditingRange>
			<inlineValue>
				<x path="Null"><t path="languageServerProtocol.protocol.proposed.InlineValueClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Capabilities specific to the `textDocument/inlineValue` request.

		@since 3.17.0
		@proposed</haxe_doc>
			</inlineValue>
			<inlayHint>
				<x path="Null"><t path="languageServerProtocol.protocol.proposed.InlayHintClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Capabilities specific to the `textDocument/inlayHint` request.

		@since 3.17.0
		@proposed</haxe_doc>
			</inlayHint>
			<implementation>
				<x path="Null"><t path="languageServerProtocol.protocol.ImplementationClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Capabilities specific to the `textDocument/implementation`

		@since 3.6.0</haxe_doc>
			</implementation>
			<hover>
				<x path="Null"><t path="languageServerProtocol.protocol.HoverClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Capabilities specific to the `textDocument/hover`</haxe_doc>
			</hover>
			<formatting>
				<x path="Null"><t path="languageServerProtocol.protocol.DocumentFormattingClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Capabilities specific to the `textDocument/formatting`</haxe_doc>
			</formatting>
			<foldingRange>
				<x path="Null"><t path="languageServerProtocol.protocol.FoldingRangeClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Capabilities specific to `textDocument/foldingRange` requests.

		@since 3.10.0</haxe_doc>
			</foldingRange>
			<documentSymbol>
				<x path="Null"><t path="languageServerProtocol.protocol.DocumentSymbolClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Capabilities specific to the `textDocument/documentSymbol`</haxe_doc>
			</documentSymbol>
			<documentLink>
				<x path="Null"><t path="languageServerProtocol.protocol.DocumentLinkClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Capabilities specific to the `textDocument/documentLink`</haxe_doc>
			</documentLink>
			<documentHighlight>
				<x path="Null"><t path="languageServerProtocol.protocol.DocumentHighlightClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Capabilities specific to the `textDocument/documentHighlight`</haxe_doc>
			</documentHighlight>
			<diagnostic>
				<x path="Null"><t path="languageServerProtocol.protocol.proposed.DiagnosticClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Capabilities specific to the diagnostic pull model.

		@since 3.17.0
		@proposed</haxe_doc>
			</diagnostic>
			<definition>
				<x path="Null"><t path="languageServerProtocol.protocol.DefinitionClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Capabilities specific to the `textDocument/definition`</haxe_doc>
			</definition>
			<declaration>
				<x path="Null"><t path="languageServerProtocol.protocol.DeclarationClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Capabilities specific to the `textDocument/declaration`

		@since 3.14.0</haxe_doc>
			</declaration>
			<completion>
				<x path="Null"><t path="languageServerProtocol.protocol.CompletionClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Capabilities specific to the `textDocument/completion`</haxe_doc>
			</completion>
			<colorProvider>
				<x path="Null"><t path="languageServerProtocol.protocol.DocumentColorClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Capabilities specific to the `textDocument/documentColor`</haxe_doc>
			</colorProvider>
			<codeLens>
				<x path="Null"><t path="languageServerProtocol.protocol.CodeLensClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Capabilities specific to the `textDocument/codeLens`</haxe_doc>
			</codeLens>
			<codeAction>
				<x path="Null"><t path="languageServerProtocol.protocol.CodeActionClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Capabilities specific to the `textDocument/codeAction`</haxe_doc>
			</codeAction>
			<callHierarchy>
				<x path="Null"><t path="languageServerProtocol.protocol.CallHierarchyClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Capabilities specific to the various call hierarchy request.

		@since 3.16.0</haxe_doc>
			</callHierarchy>
		</a>
		<haxe_doc>Text document specific client capabilities.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.WindowClientCapabilities" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol"><a>
	<workDoneProgress>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>It indicates whether the client supports server initiated
		progress using the `window/workDoneProgress/create` request.

		The capability also controls Whether client supports handling
		of progress notifications. If set servers are allowed to report a
		`workDoneProgress` property in the request specific server
		capabilities.

		@since 3.15.0</haxe_doc>
	</workDoneProgress>
	<showMessage>
		<x path="Null"><t path="languageServerProtocol.protocol.ShowMessageRequestClientCapabilities"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Capabilities specific to the showMessage request.

		@since 3.16.0</haxe_doc>
	</showMessage>
	<showDocument>
		<x path="Null"><t path="languageServerProtocol.protocol.ShowDocumentClientCapabilities"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Capabilities specific to the showDocument request.

		@since 3.16.0</haxe_doc>
	</showDocument>
</a></typedef>
	<typedef path="languageServerProtocol.protocol.RegularExpressionsClientCapabilities" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<version>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The engine's version.</haxe_doc>
			</version>
			<engine>
				<c path="String"/>
				<haxe_doc>The engine's name.</haxe_doc>
			</engine>
		</a>
		<haxe_doc>Client capabilities specific to regular expressions.

	@since 3.16.0</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.MarkdownClientCapabilities" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<version>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The version of the parser.</haxe_doc>
			</version>
			<parser>
				<c path="String"/>
				<haxe_doc>The name of the parser.</haxe_doc>
			</parser>
			<allowedTags>
				<x path="Null"><c path="Array"><c path="String"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>A list of HTML tags that the client allows / supports in
		Markdown.

		@since 3.17.0</haxe_doc>
			</allowedTags>
		</a>
		<haxe_doc>Client capabilities specific to the used markdown parser.

	@since 3.16.0</haxe_doc>
	</typedef>
	<abstract path="languageServerProtocol.protocol.PositionEncodingKind" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<this><c path="String"/></this>
		<haxe_doc>A set of predefined position encoding kinds.

	@since 3.17.0
	@proposed</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="languageServerProtocol.protocol._Protocol.PositionEncodingKind_Impl_" params="" file="src/languageServerProtocol/protocol/Protocol.hx" private="1" module="languageServerProtocol.protocol.Protocol" extern="1" final="1">
	<UTF8 public="1" get="inline" set="null" expr="cast &quot;utf-8&quot;" line="636" static="1">
		<x path="languageServerProtocol.protocol.PositionEncodingKind"/>
		<meta>
			<m n=":value"><e>cast "utf-8"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Character offsets count UTF-8 code units.</haxe_doc>
	</UTF8>
	<UTF16 public="1" get="inline" set="null" expr="cast &quot;utf-16&quot;" line="644" static="1">
		<x path="languageServerProtocol.protocol.PositionEncodingKind"/>
		<meta>
			<m n=":value"><e>cast "utf-16"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Character offsets count UTF-16 code units.

		This is the default and must always be supported
		by servers</haxe_doc>
	</UTF16>
	<UTF32 public="1" get="inline" set="null" expr="cast &quot;utf-32&quot;" line="653" static="1">
		<x path="languageServerProtocol.protocol.PositionEncodingKind"/>
		<meta>
			<m n=":value"><e>cast "utf-32"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Character offsets count UTF-32 code units.

		Implementation note: these are the same as Unicode code points,
		so this `PositionEncodingKind` may also be used for an
		encoding-agnostic representation of character offsets.</haxe_doc>
	</UTF32>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="languageServerProtocol.protocol._Protocol.PositionEncodingKind_Impl_" params="" file="src/languageServerProtocol/protocol/Protocol.hx" private="1" module="languageServerProtocol.protocol.Protocol" extern="1" final="1">
		<UTF8 public="1" get="inline" set="null" expr="cast &quot;utf-8&quot;" line="636" static="1">
			<x path="languageServerProtocol.protocol.PositionEncodingKind"/>
			<meta>
				<m n=":value"><e>cast "utf-8"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Character offsets count UTF-8 code units.</haxe_doc>
		</UTF8>
		<UTF16 public="1" get="inline" set="null" expr="cast &quot;utf-16&quot;" line="644" static="1">
			<x path="languageServerProtocol.protocol.PositionEncodingKind"/>
			<meta>
				<m n=":value"><e>cast "utf-16"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Character offsets count UTF-16 code units.

		This is the default and must always be supported
		by servers</haxe_doc>
		</UTF16>
		<UTF32 public="1" get="inline" set="null" expr="cast &quot;utf-32&quot;" line="653" static="1">
			<x path="languageServerProtocol.protocol.PositionEncodingKind"/>
			<meta>
				<m n=":value"><e>cast "utf-32"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Character offsets count UTF-32 code units.

		Implementation note: these are the same as Unicode code points,
		so this `PositionEncodingKind` may also be used for an
		encoding-agnostic representation of character offsets.</haxe_doc>
		</UTF32>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="languageServerProtocol.protocol.GeneralClientCapabilities" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<staleRequestSupport>
				<x path="Null"><a>
	<retryOnContentModified>
		<c path="Array"><c path="String"/></c>
		<haxe_doc>The list of requests for which the client
			will retry the request if it receives a
			response with error code `ContentModified`</haxe_doc>
	</retryOnContentModified>
	<cancel>
		<x path="Bool"/>
		<haxe_doc>The client will actively cancel the request.</haxe_doc>
	</cancel>
</a></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Client capability that signals how the client
		handles stale requests (e.g. a request
		for which the client will not process the response
		anymore since the information is outdated).

		@since 3.17.0
		@proposed</haxe_doc>
			</staleRequestSupport>
			<regularExpressions>
				<x path="Null"><t path="languageServerProtocol.protocol.RegularExpressionsClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Client capabilities specific to regular expressions.

		@since 3.16.0</haxe_doc>
			</regularExpressions>
			<positionEncodings>
				<x path="Null"><c path="Array"><x path="languageServerProtocol.protocol.PositionEncodingKind"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The position encodings supported by the client. Client and server
		have to agree on the same position encoding to ensure that offsets
		(e.g. character position in a line) are interpreted the same on both
		side.

		To keep the protocol backwards compatible the following applies: if
		the value 'utf-16' is missing from the array of position encodings
		servers can assume that the client supports UTF-16. UTF-16 is
		therefore a mandatory encoding.

		If omitted it defaults to ['utf-16'].

		Implementation considerations: since the conversion from one encoding
		into another requires the content of the file / line the conversion
		is best done where the file is read which is usually on the server
		side.

		@since 3.17.0
		@proposed</haxe_doc>
			</positionEncodings>
			<markdown>
				<x path="Null"><t path="languageServerProtocol.protocol.MarkdownClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Client capabilities specific to the client's markdown parser.

		@since 3.16.0</haxe_doc>
			</markdown>
		</a>
		<haxe_doc>A type indicating how positions are encoded,
	specifically what column offsets mean.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.NotebookDocumentClientCapabilities" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a><synchronization>
	<t path="languageServerProtocol.protocol.proposed.NotebookDocumentSyncClientCapabilities"/>
	<haxe_doc>Capabilities specific to notebook document synchronization

		@since 3.17.0
		@proposed</haxe_doc>
</synchronization></a>
		<haxe_doc>Capabilities specific to the notebook document support.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.ClientCapabilities" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<workspace>
				<x path="Null"><t path="languageServerProtocol.protocol.WorkspaceClientCapabilites"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Workspace specific client capabilities.</haxe_doc>
			</workspace>
			<window>
				<x path="Null"><t path="languageServerProtocol.protocol.WorkDoneProgressClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Window specific client capabilities.</haxe_doc>
			</window>
			<textDocument>
				<x path="Null"><t path="languageServerProtocol.protocol.TextDocumentClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Text document specific client capabilities.</haxe_doc>
			</textDocument>
			<notebookDocument>
				<x path="Null"><t path="languageServerProtocol.protocol.NotebookDocumentClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Capabilities specific to the notebook document support.

		@since 3.17.0
		@proposed</haxe_doc>
			</notebookDocument>
			<general>
				<x path="Null"><t path="languageServerProtocol.protocol.GeneralClientCapabilities"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>General client capabilities.

		@since 3.16.0</haxe_doc>
			</general>
			<experimental>
				<x path="Null"><d/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Experimental client capabilities.</haxe_doc>
			</experimental>
		</a>
		<haxe_doc>Define capabilities for dynamic registration, workspace and text document features the client supports.
	The `experimental` can be used to pass experimential capabilities under development.
	For future compatibility a `ClientCapabilities` object literal can have more properties set than currently defined.
	Servers receiving a `ClientCapabilities` object literal with unknown properties should ignore these properties.
	A missing property should be interpreted as an absence of the capability.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.StaticRegistrationOptions" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a><id>
	<x path="Null"><c path="String"/></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>The id used to register the request. The id can be used to deregister
		the request again. See also Registration#id.</haxe_doc>
</id></a>
		<haxe_doc>Static registration options to be returned in the initialize
	request.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.TextDocumentRegistrationOptions" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a><documentSelector>
	<x path="Null"><t path="languageServerProtocol.protocol.DocumentSelector"/></x>
	<haxe_doc>A document selector to identify the scope of the registration. If set to null
		the document selector provided on the client side will be used.</haxe_doc>
</documentSelector></a>
		<haxe_doc>General text document registration options.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.SaveOptions" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a><includeText>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>The client is supposed to include the content on save.</haxe_doc>
</includeText></a>
		<haxe_doc>Save options.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.WorkDoneProgressOptions" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol"><a><workDoneProgress>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
</workDoneProgress></a></typedef>
	<typedef path="languageServerProtocol.protocol.ServerCapabilities" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<workspaceSymbolProvider>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<t path="languageServerProtocol.protocol.WorkspaceSymbolOptions"/>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The server provides workspace symbol support.</haxe_doc>
			</workspaceSymbolProvider>
			<workspace>
				<x path="Null"><a>
	<workspaceFolders>
		<x path="Null"><t path="languageServerProtocol.protocol.WorkspaceFoldersServerCapabilities"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The server supports workspace folder.

			@since 3.6.0</haxe_doc>
	</workspaceFolders>
	<fileOperations>
		<x path="Null"><t path="languageServerProtocol.protocol.FileOperationOptions"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The server is interested in notifications/requests for operations on files.

			@since 3.16.0</haxe_doc>
	</fileOperations>
</a></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Workspace specific server capabilities.</haxe_doc>
			</workspace>
			<typeHierarchyProvider>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<x path="haxe.extern.EitherType">
		<t path="languageServerProtocol.protocol.proposed.TypeHierarchyOptions"/>
		<t path="languageServerProtocol.protocol.proposed.TypeHierarchyRegistrationOptions"/>
	</x>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The server provides type hierarchy support.

		@since 3.17.0
		@proposed</haxe_doc>
			</typeHierarchyProvider>
			<typeDefinitionProvider>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<x path="haxe.extern.EitherType">
		<t path="languageServerProtocol.protocol.TypeDefinitionOptions"/>
		<t path="languageServerProtocol.protocol.TypeDefinitionRegistrationOptions"/>
	</x>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The server provides Goto Type Definition support.</haxe_doc>
			</typeDefinitionProvider>
			<textDocumentSync>
				<x path="Null"><x path="haxe.extern.EitherType">
	<t path="languageServerProtocol.protocol.TextDocumentSyncOptions"/>
	<x path="languageServerProtocol.protocol.TextDocumentSyncKind"/>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Defines how text documents are synced.
		Is either a detailed structure defining each notification or for backwards compatibility the TextDocumentSyncKind number.</haxe_doc>
			</textDocumentSync>
			<supported>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The Server has support for workspace folders</haxe_doc>
			</supported>
			<signatureHelpProvider>
				<x path="Null"><t path="languageServerProtocol.protocol.SignatureHelpOptions"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The server provides signature help support.</haxe_doc>
			</signatureHelpProvider>
			<semanticTokensProvider>
				<x path="Null"><x path="haxe.extern.EitherType">
	<t path="languageServerProtocol.protocol.SemanticTokensOptions"/>
	<t path="languageServerProtocol.protocol.SemanticTokensRegistrationOptions"/>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The server provides semantic tokens support.

		@since 3.16.0</haxe_doc>
			</semanticTokensProvider>
			<selectionRangeProvider>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<x path="haxe.extern.EitherType">
		<t path="languageServerProtocol.protocol.SelectionRangeOptions"/>
		<t path="languageServerProtocol.protocol.SelectionRangeRegistrationOptions"/>
	</x>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The server provides selection range support.</haxe_doc>
			</selectionRangeProvider>
			<renameProvider>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<t path="languageServerProtocol.protocol.RenameOptions"/>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The server provides rename support. RenameOptions may only be
		specified if the client states that it supports
		`prepareSupport` in its initial `initialize` request.</haxe_doc>
			</renameProvider>
			<referencesProvider>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<t path="languageServerProtocol.protocol.ReferenceOptions"/>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The server provides find references support.</haxe_doc>
			</referencesProvider>
			<positionEncoding>
				<x path="Null"><x path="languageServerProtocol.protocol.PositionEncodingKind"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The position encoding the server picked from the encodings offered
		by the client via the client capability `general.positionEncodings`.

		If the client didn't provide any position encodings the only valid
		value that a server can return is 'utf-16'.

		If omitted it defaults to 'utf-16'.

		If for some reason

		@since 3.17.0
		@proposed</haxe_doc>
			</positionEncoding>
			<notebookDocumentSync>
				<x path="Null"><x path="haxe.extern.EitherType">
	<t path="languageServerProtocol.protocol.proposed.NotebookDocumentSyncOptions"/>
	<t path="languageServerProtocol.protocol.proposed.NotebookDocumentSyncRegistrationOptions"/>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Defines how notebook documents are synced.

		@since 3.17.0
		@proposed</haxe_doc>
			</notebookDocumentSync>
			<monikerProvider>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<x path="haxe.extern.EitherType">
		<t path="languageServerProtocol.protocol.MonikerOptions"/>
		<t path="languageServerProtocol.protocol.MonikerRegistrationOptions"/>
	</x>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The server provides moniker support.

		@since 3.16.0</haxe_doc>
			</monikerProvider>
			<linkedEditingRangeProvider>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<x path="haxe.extern.EitherType">
		<t path="languageServerProtocol.protocol.LinkedEditingRangeOptions"/>
		<t path="languageServerProtocol.protocol.LinkedEditingRangeRegistrationOptions"/>
	</x>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The server provides linked editing range support.

		@since 3.16.0</haxe_doc>
			</linkedEditingRangeProvider>
			<inlineValueProvider>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<x path="haxe.extern.EitherType">
		<t path="languageServerProtocol.protocol.proposed.InlineValueOptions"/>
		<t path="languageServerProtocol.protocol.proposed.InlineValueRegistrationOptions"/>
	</x>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The server provides inline values.

		@since 3.17.0
		@proposed</haxe_doc>
			</inlineValueProvider>
			<inlayHintProvider>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<x path="haxe.extern.EitherType">
		<t path="languageServerProtocol.protocol.proposed.InlayHintOptions"/>
		<t path="languageServerProtocol.protocol.proposed.InlayHintRegistrationOptions"/>
	</x>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The server provides inlay hints.

		@since 3.17.0
		@proposed</haxe_doc>
			</inlayHintProvider>
			<implementationProvider>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<x path="haxe.extern.EitherType">
		<t path="languageServerProtocol.protocol.ImplementationOptions"/>
		<t path="languageServerProtocol.protocol.ImplementationRegistrationOptions"/>
	</x>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The server provides Goto Implementation support.</haxe_doc>
			</implementationProvider>
			<hoverProvider>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<t path="languageServerProtocol.protocol.HoverOptions"/>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The server provides hover support.</haxe_doc>
			</hoverProvider>
			<foldingRangeProvider>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<x path="haxe.extern.EitherType">
		<t path="languageServerProtocol.protocol.FoldingRangeOptions"/>
		<t path="languageServerProtocol.protocol.FoldingRangeRegistrationOptions"/>
	</x>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The server provides folding provider support.</haxe_doc>
			</foldingRangeProvider>
			<experimental>
				<x path="Null"><d/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Experimental server capabilities.</haxe_doc>
			</experimental>
			<executeCommandProvider>
				<x path="Null"><t path="languageServerProtocol.protocol.ExecuteCommandOptions"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The server provides execute command support.</haxe_doc>
			</executeCommandProvider>
			<documentSymbolProvider>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<t path="languageServerProtocol.protocol.DocumentSymbolOptions"/>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The server provides document symbol support.</haxe_doc>
			</documentSymbolProvider>
			<documentRangeFormattingProvider>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<t path="languageServerProtocol.protocol.DocumentRangeFormattingOptions"/>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The server provides document range formatting.</haxe_doc>
			</documentRangeFormattingProvider>
			<documentOnTypeFormattingProvider>
				<x path="Null"><t path="languageServerProtocol.protocol.DocumentOnTypeFormattingOptions"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The server provides document formatting on typing.</haxe_doc>
			</documentOnTypeFormattingProvider>
			<documentLinkProvider>
				<x path="Null"><t path="languageServerProtocol.protocol.DocumentLinkOptions"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The server provides document link support.</haxe_doc>
			</documentLinkProvider>
			<documentHighlightProvider>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<t path="languageServerProtocol.protocol.DocumentHighlightOptions"/>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The server provides document highlight support.</haxe_doc>
			</documentHighlightProvider>
			<documentFormattingProvider>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<t path="languageServerProtocol.protocol.DocumentFormattingOptions"/>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The server provides document formatting.</haxe_doc>
			</documentFormattingProvider>
			<diagnosticProvider>
				<x path="Null"><x path="haxe.extern.EitherType">
	<t path="languageServerProtocol.protocol.proposed.DiagnosticOptions"/>
	<t path="languageServerProtocol.protocol.proposed.DiagnosticRegistrationOptions"/>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The server has support for pull model diagnostics.

		@since 3.17.0
		@proposed</haxe_doc>
			</diagnosticProvider>
			<definitionProvider>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<t path="languageServerProtocol.protocol.DefinitionOptions"/>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The server provides goto definition support.</haxe_doc>
			</definitionProvider>
			<declarationProvider>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<x path="haxe.extern.EitherType">
		<t path="languageServerProtocol.protocol.DeclarationOptions"/>
		<t path="languageServerProtocol.protocol.DeclarationRegistrationOptions"/>
	</x>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The server provides Goto Declaration support.</haxe_doc>
			</declarationProvider>
			<completionProvider>
				<x path="Null"><t path="languageServerProtocol.protocol.CompletionOptions"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The server provides completion support.</haxe_doc>
			</completionProvider>
			<colorProvider>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<x path="haxe.extern.EitherType">
		<t path="languageServerProtocol.protocol.DocumentColorOptions"/>
		<t path="languageServerProtocol.protocol.DocumentColorRegistrationOptions"/>
	</x>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The server provides color provider support.</haxe_doc>
			</colorProvider>
			<codeLensProvider>
				<x path="Null"><t path="languageServerProtocol.protocol.CodeLensOptions"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The server provides code lens.</haxe_doc>
			</codeLensProvider>
			<codeActionProvider>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<t path="languageServerProtocol.protocol.CodeActionOptions"/>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The server provides code actions. CodeActionOptions may only be
		specified if the client states that it supports
		`codeActionLiteralSupport` in its initial `initialize` request.</haxe_doc>
			</codeActionProvider>
			<changeNotifications>
				<x path="Null"><x path="haxe.extern.EitherType">
	<c path="String"/>
	<x path="Bool"/>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether the server wants to receive workspace folder
		change notifications.

		If a strings is provided the string is treated as a ID
		under which the notification is registed on the client
		side. The ID can be used to unregister for these events
		using the `client/unregisterCapability` request.</haxe_doc>
			</changeNotifications>
			<callHierarchyProvider>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<x path="haxe.extern.EitherType">
		<t path="languageServerProtocol.protocol.CallHierarchyOptions"/>
		<t path="languageServerProtocol.protocol.CallHierarchyRegistrationOptions"/>
	</x>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The server provides call hierarchy support.

		@since 3.16.0</haxe_doc>
			</callHierarchyProvider>
		</a>
		<haxe_doc>Defines the capabilities provided by a language
	server.</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.InitializeRequest" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;InitializeParams&amp;WorkDoneProgressParams,InitializeResult,Never,InitializeError,NoData&gt;(&quot;initialize&quot;)" line="1071" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<a>
					<workspaceFolders>
						<x path="Null"><c path="Array"><t path="languageServerProtocol.WorkspaceFolder"/></c></x>
						<meta><m n=":optional"/></meta>
						<haxe_doc>The actual configured workspace folders.</haxe_doc>
					</workspaceFolders>
					<workDoneToken>
						<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
						<meta><m n=":optional"/></meta>
						<haxe_doc>An optional token that a server can use to report work done progress.</haxe_doc>
					</workDoneToken>
					<trace>
						<x path="Null"><x path="languageServerProtocol.protocol.TraceMode"/></x>
						<meta><m n=":optional"/></meta>
						<haxe_doc>The initial trace setting.
		If omitted trace is disabled ('off').</haxe_doc>
					</trace>
					<rootUri>
						<x path="Null"><x path="languageServerProtocol.textdocument.DocumentUri"/></x>
						<meta><m n=":deprecated"><e>"deprecated in favour of workspaceFolders"</e></m></meta>
						<haxe_doc>The rootUri of the workspace.
		Is null if no folder is open.
		If both `rootPath` and `rootUri` are set `rootUri` wins.</haxe_doc>
					</rootUri>
					<rootPath>
						<x path="Null"><c path="String"/></x>
						<meta><m n=":deprecated"><e>"deprecated in favour of rootUri"</e></m></meta>
						<haxe_doc>The rootPath of the workspace.
		Is null if no folder is open.</haxe_doc>
					</rootPath>
					<processId>
						<x path="Null"><x path="Int"/></x>
						<haxe_doc>The process Id of the parent process that started the server.
		Is null if the process has not been started by another process.
		If the parent process is not alive then the server should exit (see exit notification) its process.</haxe_doc>
					</processId>
					<initializationOptions>
						<x path="Null"><d/></x>
						<meta><m n=":optional"/></meta>
						<haxe_doc>User provided initialization options.</haxe_doc>
					</initializationOptions>
					<clientInfo>
						<x path="Null"><a>
	<version>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The client's version as defined by the client.</haxe_doc>
	</version>
	<name>
		<c path="String"/>
		<haxe_doc>The name of the client as defined by the client.</haxe_doc>
	</name>
</a></x>
						<meta><m n=":optional"/></meta>
						<haxe_doc>Information about the client

		@since 3.15.0</haxe_doc>
					</clientInfo>
					<capabilities>
						<t path="languageServerProtocol.protocol.ClientCapabilities"/>
						<haxe_doc>The capabilities provided by the client (editor or tool).</haxe_doc>
					</capabilities>
				</a>
				<t path="languageServerProtocol.protocol.InitializeResult"/>
				<e path="languageServerProtocol.protocol.Never"/>
				<t path="languageServerProtocol.protocol.InitializeError"/>
				<e path="jsonrpc.NoData"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<InitializeParams&WorkDoneProgressParams,InitializeResult,Never,InitializeError,NoData>("initialize")]]></e></m></meta>
		</type>
		<haxe_doc>The initialize request is sent from the client to the server.
	It is sent once as the request after starting up the server.
	The requests parameter is of type [InitializeParams](#InitializeParams)
	the response if of type [InitializeResult](#InitializeResult) of a Thenable that
	resolves to such.</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.InitializeParams" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<workspaceFolders>
				<x path="Null"><c path="Array"><t path="languageServerProtocol.WorkspaceFolder"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The actual configured workspace folders.</haxe_doc>
			</workspaceFolders>
			<workDoneToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report work done progress.</haxe_doc>
			</workDoneToken>
			<trace>
				<x path="Null"><x path="languageServerProtocol.protocol.TraceMode"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The initial trace setting.
		If omitted trace is disabled ('off').</haxe_doc>
			</trace>
			<rootUri>
				<x path="Null"><x path="languageServerProtocol.textdocument.DocumentUri"/></x>
				<meta><m n=":deprecated"><e>"deprecated in favour of workspaceFolders"</e></m></meta>
				<haxe_doc>The rootUri of the workspace.
		Is null if no folder is open.
		If both `rootPath` and `rootUri` are set `rootUri` wins.</haxe_doc>
			</rootUri>
			<rootPath>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":deprecated"><e>"deprecated in favour of rootUri"</e></m></meta>
				<haxe_doc>The rootPath of the workspace.
		Is null if no folder is open.</haxe_doc>
			</rootPath>
			<processId>
				<x path="Null"><x path="Int"/></x>
				<haxe_doc>The process Id of the parent process that started the server.
		Is null if the process has not been started by another process.
		If the parent process is not alive then the server should exit (see exit notification) its process.</haxe_doc>
			</processId>
			<initializationOptions>
				<x path="Null"><d/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>User provided initialization options.</haxe_doc>
			</initializationOptions>
			<clientInfo>
				<x path="Null"><a>
	<version>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The client's version as defined by the client.</haxe_doc>
	</version>
	<name>
		<c path="String"/>
		<haxe_doc>The name of the client as defined by the client.</haxe_doc>
	</name>
</a></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Information about the client

		@since 3.15.0</haxe_doc>
			</clientInfo>
			<capabilities>
				<t path="languageServerProtocol.protocol.ClientCapabilities"/>
				<haxe_doc>The capabilities provided by the client (editor or tool).</haxe_doc>
			</capabilities>
		</a>
		<haxe_doc>The initialize parameters</haxe_doc>
	</typedef>
	<abstract path="languageServerProtocol.protocol.TraceMode" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="languageServerProtocol.protocol._Protocol.TraceMode_Impl_" params="" file="src/languageServerProtocol/protocol/Protocol.hx" private="1" module="languageServerProtocol.protocol.Protocol" extern="1" final="1">
	<Off public="1" get="inline" set="null" expr="cast &quot;off&quot;" line="1137" static="1">
		<x path="languageServerProtocol.protocol.TraceMode"/>
		<meta>
			<m n=":value"><e>cast "off"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Off>
	<Messages public="1" get="inline" set="null" expr="cast &quot;messages&quot;" line="1138" static="1">
		<x path="languageServerProtocol.protocol.TraceMode"/>
		<meta>
			<m n=":value"><e>cast "messages"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Messages>
	<Compact public="1" get="inline" set="null" expr="cast &quot;compact&quot;" line="1139" static="1">
		<x path="languageServerProtocol.protocol.TraceMode"/>
		<meta>
			<m n=":value"><e>cast "compact"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Compact>
	<Verbose public="1" get="inline" set="null" expr="cast &quot;verbose&quot;" line="1140" static="1">
		<x path="languageServerProtocol.protocol.TraceMode"/>
		<meta>
			<m n=":value"><e>cast "verbose"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Verbose>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="languageServerProtocol.protocol._Protocol.TraceMode_Impl_" params="" file="src/languageServerProtocol/protocol/Protocol.hx" private="1" module="languageServerProtocol.protocol.Protocol" extern="1" final="1">
		<Off public="1" get="inline" set="null" expr="cast &quot;off&quot;" line="1137" static="1">
			<x path="languageServerProtocol.protocol.TraceMode"/>
			<meta>
				<m n=":value"><e>cast "off"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Off>
		<Messages public="1" get="inline" set="null" expr="cast &quot;messages&quot;" line="1138" static="1">
			<x path="languageServerProtocol.protocol.TraceMode"/>
			<meta>
				<m n=":value"><e>cast "messages"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Messages>
		<Compact public="1" get="inline" set="null" expr="cast &quot;compact&quot;" line="1139" static="1">
			<x path="languageServerProtocol.protocol.TraceMode"/>
			<meta>
				<m n=":value"><e>cast "compact"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Compact>
		<Verbose public="1" get="inline" set="null" expr="cast &quot;verbose&quot;" line="1140" static="1">
			<x path="languageServerProtocol.protocol.TraceMode"/>
			<meta>
				<m n=":value"><e>cast "verbose"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Verbose>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="languageServerProtocol.protocol.InitializeResult" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<serverInfo>
				<x path="Null"><a>
	<version>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The servers's version as defined by the server.</haxe_doc>
	</version>
	<name>
		<c path="String"/>
		<haxe_doc>The name of the server as defined by the server.</haxe_doc>
	</name>
</a></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Information about the server.

		@since 3.15.0</haxe_doc>
			</serverInfo>
			<capabilities>
				<t path="languageServerProtocol.protocol.ServerCapabilities"/>
				<haxe_doc>The capabilities the language server provides.</haxe_doc>
			</capabilities>
		</a>
		<haxe_doc>The result returned from an initialize request.
	This object can contain additional fields of type String.</haxe_doc>
	</typedef>
	<abstract path="languageServerProtocol.protocol.InitializeErrorCodes" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="languageServerProtocol.protocol._Protocol.InitializeErrorCodes_Impl_" params="" file="src/languageServerProtocol/protocol/Protocol.hx" private="1" module="languageServerProtocol.protocol.Protocol" extern="1" final="1">
	<unknownProtocolVersion public="1" get="inline" set="null" expr="cast 1" line="1172" static="1">
		<x path="languageServerProtocol.protocol.InitializeErrorCodes"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</unknownProtocolVersion>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="languageServerProtocol.protocol._Protocol.InitializeErrorCodes_Impl_" params="" file="src/languageServerProtocol/protocol/Protocol.hx" private="1" module="languageServerProtocol.protocol.Protocol" extern="1" final="1">
		<unknownProtocolVersion public="1" get="inline" set="null" expr="cast 1" line="1172" static="1">
			<x path="languageServerProtocol.protocol.InitializeErrorCodes"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</unknownProtocolVersion>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="languageServerProtocol.protocol.InitializeError" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a><retry>
	<x path="Bool"/>
	<haxe_doc>Indicates whether the client execute the following retry logic:
		(1) show the message provided by the ResponseError to the user
		(2) user selects retry or cancel
		(3) if user selected retry the initialize method is sent again.</haxe_doc>
</retry></a>
		<haxe_doc>The data type of the ResponseError if the
	initialize request fails.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.InitializedParams" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol"><a/></typedef>
	<class path="languageServerProtocol.protocol.InitializedNotification" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolNotificationType&lt;InitializedParams,NoData&gt;(&quot;initialized&quot;)" line="1197" static="1">
			<x path="languageServerProtocol.protocol.ProtocolNotificationType">
				<t path="languageServerProtocol.protocol.InitializedParams"/>
				<e path="jsonrpc.NoData"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolNotificationType<InitializedParams,NoData>("initialized")]]></e></m></meta>
		</type>
		<haxe_doc>The intialized notification is sent from the client to the
	server after the client is fully initialized and the server
	is allowed to send requests from the server to the client.</haxe_doc>
	</class>
	<class path="languageServerProtocol.protocol.ShutdownRequest" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;NoData,NoData,Never,NoData,NoData&gt;(&quot;shutdown&quot;)" line="1209" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<e path="jsonrpc.NoData"/>
				<e path="jsonrpc.NoData"/>
				<e path="languageServerProtocol.protocol.Never"/>
				<e path="jsonrpc.NoData"/>
				<e path="jsonrpc.NoData"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<NoData,NoData,Never,NoData,NoData>("shutdown")]]></e></m></meta>
		</type>
		<haxe_doc>A shutdown request is sent from the client to the server.
	It is sent once when the client decides to shutdown the
	server. The only notification that is sent after a shutdown request
	is the exit event.</haxe_doc>
	</class>
	<class path="languageServerProtocol.protocol.ExitNotification" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolNotificationType&lt;NoData,NoData&gt;(&quot;exit&quot;)" line="1219" static="1">
			<x path="languageServerProtocol.protocol.ProtocolNotificationType">
				<e path="jsonrpc.NoData"/>
				<e path="jsonrpc.NoData"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolNotificationType<NoData,NoData>("exit")]]></e></m></meta>
		</type>
		<haxe_doc>The exit event is sent from the client to the server to
	ask the server to exit its process.</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.DidChangeConfigurationClientCapabilities" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol"><a><dynamicRegistration>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>Did change configuration notification supports dynamic registration.</haxe_doc>
</dynamicRegistration></a></typedef>
	<class path="languageServerProtocol.protocol.DidChangeConfigurationNotification" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolNotificationType&lt;DidChangeConfigurationParams,DidChangeConfigurationRegistrationOptions&gt;(&quot;workspace/didChangeConfiguration&quot;)" line="1237" static="1">
			<x path="languageServerProtocol.protocol.ProtocolNotificationType">
				<t path="languageServerProtocol.protocol.DidChangeConfigurationParams"/>
				<t path="languageServerProtocol.protocol.DidChangeConfigurationRegistrationOptions"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolNotificationType<DidChangeConfigurationParams,DidChangeConfigurationRegistrationOptions>("workspace/didChangeConfiguration")]]></e></m></meta>
		</type>
		<haxe_doc>The configuration change notification is sent from the client to the server
	when the client's configuration has changed. The notification contains
	the changed configuration as defined by the language client.</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.DidChangeConfigurationRegistrationOptions" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol"><a><section>
	<x path="Null"><x path="haxe.extern.EitherType">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</x></x>
	<meta><m n=":optional"/></meta>
</section></a></typedef>
	<typedef path="languageServerProtocol.protocol.DidChangeConfigurationParams" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a><settings>
	<d/>
	<haxe_doc>The actual changed settings.</haxe_doc>
</settings></a>
		<haxe_doc>The parameters of a change configuration notification.</haxe_doc>
	</typedef>
	<abstract path="languageServerProtocol.protocol.MessageType" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<haxe_doc>The message type</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="languageServerProtocol.protocol._Protocol.MessageType_Impl_" params="" file="src/languageServerProtocol/protocol/Protocol.hx" private="1" module="languageServerProtocol.protocol.Protocol" extern="1" final="1">
	<Error public="1" get="inline" set="null" expr="cast 1" line="1264" static="1">
		<x path="languageServerProtocol.protocol.MessageType"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>An error message.</haxe_doc>
	</Error>
	<Warning public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
		<x path="languageServerProtocol.protocol.MessageType"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>A warning message.</haxe_doc>
	</Warning>
	<Info public="1" get="inline" set="null" expr="cast 3" line="1" static="1">
		<x path="languageServerProtocol.protocol.MessageType"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>An information message.</haxe_doc>
	</Info>
	<Log public="1" get="inline" set="null" expr="cast 4" line="1" static="1">
		<x path="languageServerProtocol.protocol.MessageType"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>A log message.</haxe_doc>
	</Log>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="languageServerProtocol.protocol._Protocol.MessageType_Impl_" params="" file="src/languageServerProtocol/protocol/Protocol.hx" private="1" module="languageServerProtocol.protocol.Protocol" extern="1" final="1">
		<Error public="1" get="inline" set="null" expr="cast 1" line="1264" static="1">
			<x path="languageServerProtocol.protocol.MessageType"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>An error message.</haxe_doc>
		</Error>
		<Warning public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
			<x path="languageServerProtocol.protocol.MessageType"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>A warning message.</haxe_doc>
		</Warning>
		<Info public="1" get="inline" set="null" expr="cast 3" line="1" static="1">
			<x path="languageServerProtocol.protocol.MessageType"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>An information message.</haxe_doc>
		</Info>
		<Log public="1" get="inline" set="null" expr="cast 4" line="1" static="1">
			<x path="languageServerProtocol.protocol.MessageType"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>A log message.</haxe_doc>
		</Log>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="languageServerProtocol.protocol.ShowMessageParams" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol"><a>
	<type>
		<x path="languageServerProtocol.protocol.MessageType"/>
		<haxe_doc>The message type.</haxe_doc>
	</type>
	<message>
		<c path="String"/>
		<haxe_doc>The actual message.</haxe_doc>
	</message>
</a></typedef>
	<class path="languageServerProtocol.protocol.ShowMessageNotification" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolNotificationType&lt;ShowMessageParams,NoData&gt;(&quot;window/showMessage&quot;)" line="1299" static="1">
			<x path="languageServerProtocol.protocol.ProtocolNotificationType">
				<t path="languageServerProtocol.protocol.ShowMessageParams"/>
				<e path="jsonrpc.NoData"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolNotificationType<ShowMessageParams,NoData>("window/showMessage")]]></e></m></meta>
		</type>
		<haxe_doc>The show message notification is sent from a server to a client to ask
	the client to display a particular message in the user interface.</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.ShowMessageRequestClientCapabilities" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a><messageActionItem>
	<x path="Null"><a><additionalPropertiesSupport>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>Whether the client supports additional attributes which
			are preserved and send back to the server in the
			request's response.</haxe_doc>
</additionalPropertiesSupport></a></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>Capabilities specific to the `MessageActionItem` type.</haxe_doc>
</messageActionItem></a>
		<haxe_doc>Show message request client capabilities</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.MessageActionItem" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol"><a><title>
	<c path="String"/>
	<haxe_doc>A short title like 'Retry', 'Open Log' etc.</haxe_doc>
</title></a></typedef>
	<typedef path="languageServerProtocol.protocol.ShowMessageRequestParams" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol"><a>
	<type>
		<x path="languageServerProtocol.protocol.MessageType"/>
		<haxe_doc>The message type. See {@link MessageType}</haxe_doc>
	</type>
	<message>
		<c path="String"/>
		<haxe_doc>The actual message.</haxe_doc>
	</message>
	<actions>
		<x path="Null"><c path="Array"><t path="languageServerProtocol.protocol.MessageActionItem"/></c></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The message action items to present.</haxe_doc>
	</actions>
</a></typedef>
	<class path="languageServerProtocol.protocol.ShowMessageRequest" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;ShowMessageRequestParams,Null&lt;MessageActionItem&gt;,Never,NoData,NoData&gt;(&quot;window/showMessageRequest&quot;)" line="1348" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.ShowMessageRequestParams"/>
				<x path="Null"><t path="languageServerProtocol.protocol.MessageActionItem"/></x>
				<e path="languageServerProtocol.protocol.Never"/>
				<e path="jsonrpc.NoData"/>
				<e path="jsonrpc.NoData"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<ShowMessageRequestParams,Null<MessageActionItem>,Never,NoData,NoData>("window/showMessageRequest")]]></e></m></meta>
		</type>
		<haxe_doc>The show message request is sent from the server to the client to show a message
	and a set of options actions to the user.</haxe_doc>
	</class>
	<class path="languageServerProtocol.protocol.LogMessageNotification" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolNotificationType&lt;LogMessageParams,NoData&gt;(&quot;window/logMessage&quot;)" line="1357" static="1">
			<x path="languageServerProtocol.protocol.ProtocolNotificationType">
				<t path="languageServerProtocol.protocol.LogMessageParams"/>
				<e path="jsonrpc.NoData"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolNotificationType<LogMessageParams,NoData>("window/logMessage")]]></e></m></meta>
		</type>
		<haxe_doc>The log message notification is sent from the server to the client to ask
	the client to log a particular message.</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.LogMessageParams" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol"><a>
	<type>
		<x path="languageServerProtocol.protocol.MessageType"/>
		<haxe_doc>The message type.</haxe_doc>
	</type>
	<message>
		<c path="String"/>
		<haxe_doc>The actual message.</haxe_doc>
	</message>
</a></typedef>
	<class path="languageServerProtocol.protocol.TelemetryEventNotification" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolNotificationType&lt;Dynamic,NoData&gt;(&quot;telemetry/event&quot;)" line="1379" static="1">
			<x path="languageServerProtocol.protocol.ProtocolNotificationType">
				<d/>
				<e path="jsonrpc.NoData"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolNotificationType<Dynamic,NoData>("telemetry/event")]]></e></m></meta>
		</type>
		<haxe_doc>The telemetry event notification is sent from the server to the client to ask
	the client to log telemetry data.</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.TextDocumentSyncClientCapabilities" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol"><a>
	<willSaveWaitUntil>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The client supports sending a will save request and
		waits for a response providing text edits which will
		be applied to the document before it is saved.</haxe_doc>
	</willSaveWaitUntil>
	<willSave>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The client supports sending will save notifications.</haxe_doc>
	</willSave>
	<dynamicRegistration>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Whether text document synchronization supports dynamic registration.</haxe_doc>
	</dynamicRegistration>
	<didSave>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The client supports did save notifications.</haxe_doc>
	</didSave>
</a></typedef>
	<abstract path="languageServerProtocol.protocol.TextDocumentSyncKind" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<this><x path="Int"/></this>
		<haxe_doc>Defines how the host (editor) should sync document changes to the language server.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="languageServerProtocol.protocol._Protocol.TextDocumentSyncKind_Impl_" params="" file="src/languageServerProtocol/protocol/Protocol.hx" private="1" module="languageServerProtocol.protocol.Protocol" extern="1" final="1">
	<None public="1" get="inline" set="null" expr="cast 0" line="1" static="1">
		<x path="languageServerProtocol.protocol.TextDocumentSyncKind"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Documents should not be synced at all.</haxe_doc>
	</None>
	<Full public="1" get="inline" set="null" expr="cast 1" line="1" static="1">
		<x path="languageServerProtocol.protocol.TextDocumentSyncKind"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Documents are synced by always sending the full content of the document.</haxe_doc>
	</Full>
	<Incremental public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
		<x path="languageServerProtocol.protocol.TextDocumentSyncKind"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Documents are synced by sending the full content on open.
		After that only incremental updates to the document are send.</haxe_doc>
	</Incremental>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="languageServerProtocol.protocol._Protocol.TextDocumentSyncKind_Impl_" params="" file="src/languageServerProtocol/protocol/Protocol.hx" private="1" module="languageServerProtocol.protocol.Protocol" extern="1" final="1">
		<None public="1" get="inline" set="null" expr="cast 0" line="1" static="1">
			<x path="languageServerProtocol.protocol.TextDocumentSyncKind"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Documents should not be synced at all.</haxe_doc>
		</None>
		<Full public="1" get="inline" set="null" expr="cast 1" line="1" static="1">
			<x path="languageServerProtocol.protocol.TextDocumentSyncKind"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Documents are synced by always sending the full content of the document.</haxe_doc>
		</Full>
		<Incremental public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
			<x path="languageServerProtocol.protocol.TextDocumentSyncKind"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Documents are synced by sending the full content on open.
		After that only incremental updates to the document are send.</haxe_doc>
		</Incremental>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="languageServerProtocol.protocol.TextDocumentSyncOptions" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol"><a>
	<willSaveWaitUntil>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>If present will save wait until requests are sent to the server. If omitted the request should not be
		sent.</haxe_doc>
	</willSaveWaitUntil>
	<willSave>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>If present will save notifications are sent to the server. If omitted the notification should not be
		sent.</haxe_doc>
	</willSave>
	<save>
		<x path="Null"><t path="languageServerProtocol.protocol.SaveOptions"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>If present save notifications are sent to the server. If omitted the notification should not be
		sent.</haxe_doc>
	</save>
	<openClose>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Open and close notifications are sent to the server. If omitted open close notification should not
		be sent.</haxe_doc>
	</openClose>
	<change>
		<x path="Null"><x path="languageServerProtocol.protocol.TextDocumentSyncKind"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Change notifications are sent to the server. See TextDocumentSyncKind.None, TextDocumentSyncKind.Full
		and TextDocumentSyncKind.Incremental. If omitted it defaults to TextDocumentSyncKind.None.</haxe_doc>
	</change>
</a></typedef>
	<typedef path="languageServerProtocol.protocol.DidOpenTextDocumentParams" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a><textDocument>
	<t path="languageServerProtocol.TextDocumentItem"/>
	<haxe_doc>The document that was opened.</haxe_doc>
</textDocument></a>
		<haxe_doc>The parameters send in a open text document notification</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.DidOpenTextDocumentNotification" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolNotificationType&lt;DidOpenTextDocumentParams,TextDocumentRegistrationOptions&gt;(&quot;textDocument/didOpen&quot;)" line="1482" static="1">
			<x path="languageServerProtocol.protocol.ProtocolNotificationType">
				<t path="languageServerProtocol.protocol.DidOpenTextDocumentParams"/>
				<t path="languageServerProtocol.protocol.TextDocumentRegistrationOptions"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolNotificationType<DidOpenTextDocumentParams,TextDocumentRegistrationOptions>("textDocument/didOpen")]]></e></m></meta>
		</type>
		<haxe_doc>The document open notification is sent from the client to the server to signal
	newly opened text documents. The document's truth is now managed by the client
	and the server must not try to read the document's truth using the document's
	uri. Open in this sense means it is managed by the client. It doesn't necessarily
	mean that its content is presented in an editor. An open notification must not
	be sent more than once without a corresponding close notification send before.
	This means open and close notification must be balanced and the max open count
	is one.</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.DidChangeTextDocumentParams" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<textDocument>
				<t path="languageServerProtocol.VersionedTextDocumentIdentifier"/>
				<haxe_doc>The document that did change.
		The version number points to the version after all provided content changes have been applied.</haxe_doc>
			</textDocument>
			<contentChanges>
				<c path="Array"><t path="languageServerProtocol.textdocument.TextDocumentContentChangeEvent"/></c>
				<haxe_doc>The actual content changes. The content changes describe single state changes
		to the document. So if there are two content changes c1 (at array index 0) and
		c2 (at array index 1) for a document in state S then c1 moves the document from
		S to S' and c2 from S' to S''. So c1 is computed on the state S and c2 is computed
		on the state S'.

		To mirror the content of a document using change events use the following approach:
		- start with the same initial content
		- apply the 'textDocument/didChange' notifications in the order you recevie them.
		- apply the `TextDocumentContentChangeEvent`s in a single notification in the order
		  you receive them.</haxe_doc>
			</contentChanges>
		</a>
		<haxe_doc>The change text document notification's parameters.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.TextDocumentChangeRegistrationOptions" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<syncKind>
				<x path="languageServerProtocol.protocol.TextDocumentSyncKind"/>
				<haxe_doc>How documents are synced to the server.</haxe_doc>
			</syncKind>
			<documentSelector>
				<x path="Null"><t path="languageServerProtocol.protocol.DocumentSelector"/></x>
				<haxe_doc>A document selector to identify the scope of the registration. If set to null
		the document selector provided on the client side will be used.</haxe_doc>
			</documentSelector>
		</a>
		<haxe_doc>Describe options to be used when registered for text document change events.</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.DidChangeTextDocumentNotification" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolNotificationType&lt;DidChangeTextDocumentParams,TextDocumentChangeRegistrationOptions&gt;(&quot;textDocument/didChange&quot;)" line="1526" static="1">
			<x path="languageServerProtocol.protocol.ProtocolNotificationType">
				<t path="languageServerProtocol.protocol.DidChangeTextDocumentParams"/>
				<t path="languageServerProtocol.protocol.TextDocumentChangeRegistrationOptions"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolNotificationType<DidChangeTextDocumentParams,TextDocumentChangeRegistrationOptions>("textDocument/didChange")]]></e></m></meta>
		</type>
		<haxe_doc>The document change notification is sent from the client to the server to signal
	changes to a text document.</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.DidCloseTextDocumentParams" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a><textDocument>
	<t path="languageServerProtocol.TextDocumentIdentifier"/>
	<haxe_doc>The document that was closed.</haxe_doc>
</textDocument></a>
		<haxe_doc>The parameters send in a close text document notification</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.DidCloseTextDocumentNotification" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolNotificationType&lt;DidCloseTextDocumentParams,TextDocumentRegistrationOptions&gt;(&quot;textDocument/didClose&quot;)" line="1550" static="1">
			<x path="languageServerProtocol.protocol.ProtocolNotificationType">
				<t path="languageServerProtocol.protocol.DidCloseTextDocumentParams"/>
				<t path="languageServerProtocol.protocol.TextDocumentRegistrationOptions"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolNotificationType<DidCloseTextDocumentParams,TextDocumentRegistrationOptions>("textDocument/didClose")]]></e></m></meta>
		</type>
		<haxe_doc>The document close notification is sent from the client to the server when
	the document got closed in the client. The document's truth now exists where
	the document's uri points to (e.g. if the document's uri is a file uri the
	truth now exists on disk). As with the open notification the close notification
	is about managing the document's content. Receiving a close notification
	doesn't mean that the document was open in an editor before. A close
	notification requires a previous open notification to be sent.</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.DidSaveTextDocumentParams" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<textDocument>
				<t path="languageServerProtocol.TextDocumentIdentifier"/>
				<haxe_doc>The document that was saved.</haxe_doc>
			</textDocument>
			<text>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Optional the content when saved. Depends on the `includeText` value when the save notifcation was requested.</haxe_doc>
			</text>
		</a>
		<haxe_doc>The parameters send in a save text document notification</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.TextDocumentSaveRegistrationOptions" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<includeText>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The client is supposed to include the content on save.</haxe_doc>
			</includeText>
			<documentSelector>
				<x path="Null"><t path="languageServerProtocol.protocol.DocumentSelector"/></x>
				<haxe_doc>A document selector to identify the scope of the registration. If set to null
		the document selector provided on the client side will be used.</haxe_doc>
			</documentSelector>
		</a>
		<haxe_doc>Save registration options.</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.DidSaveTextDocumentNotification" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolNotificationType&lt;DidSaveTextDocumentParams,TextDocumentSaveRegistrationOptions&gt;(&quot;textDocument/didSave&quot;)" line="1578" static="1">
			<x path="languageServerProtocol.protocol.ProtocolNotificationType">
				<t path="languageServerProtocol.protocol.DidSaveTextDocumentParams"/>
				<t path="languageServerProtocol.protocol.TextDocumentSaveRegistrationOptions"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolNotificationType<DidSaveTextDocumentParams,TextDocumentSaveRegistrationOptions>("textDocument/didSave")]]></e></m></meta>
		</type>
		<haxe_doc>The document save notification is sent from the client to the server when
	the document got saved in the client.</haxe_doc>
	</class>
	<abstract path="languageServerProtocol.protocol.TextDocumentSaveReason" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<this><x path="Int"/></this>
		<haxe_doc>Represents reasons why a text document is saved.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="languageServerProtocol.protocol._Protocol.TextDocumentSaveReason_Impl_" params="" file="src/languageServerProtocol/protocol/Protocol.hx" private="1" module="languageServerProtocol.protocol.Protocol" extern="1" final="1">
	<Manual public="1" get="inline" set="null" expr="cast 1" line="1588" static="1">
		<x path="languageServerProtocol.protocol.TextDocumentSaveReason"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Manually triggered, e.g. by the user pressing save, by starting debugging, or by an API call.</haxe_doc>
	</Manual>
	<AfterDelay public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
		<x path="languageServerProtocol.protocol.TextDocumentSaveReason"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Automatic after a delay.</haxe_doc>
	</AfterDelay>
	<FocusOut public="1" get="inline" set="null" expr="cast 3" line="1" static="1">
		<x path="languageServerProtocol.protocol.TextDocumentSaveReason"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>When the editor lost focus.</haxe_doc>
	</FocusOut>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="languageServerProtocol.protocol._Protocol.TextDocumentSaveReason_Impl_" params="" file="src/languageServerProtocol/protocol/Protocol.hx" private="1" module="languageServerProtocol.protocol.Protocol" extern="1" final="1">
		<Manual public="1" get="inline" set="null" expr="cast 1" line="1588" static="1">
			<x path="languageServerProtocol.protocol.TextDocumentSaveReason"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Manually triggered, e.g. by the user pressing save, by starting debugging, or by an API call.</haxe_doc>
		</Manual>
		<AfterDelay public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
			<x path="languageServerProtocol.protocol.TextDocumentSaveReason"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Automatic after a delay.</haxe_doc>
		</AfterDelay>
		<FocusOut public="1" get="inline" set="null" expr="cast 3" line="1" static="1">
			<x path="languageServerProtocol.protocol.TextDocumentSaveReason"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>When the editor lost focus.</haxe_doc>
		</FocusOut>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="languageServerProtocol.protocol.WillSaveTextDocumentParams" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<textDocument>
				<t path="languageServerProtocol.TextDocumentIdentifier"/>
				<haxe_doc>The document that will be saved.</haxe_doc>
			</textDocument>
			<reason>
				<x path="languageServerProtocol.protocol.TextDocumentSaveReason"/>
				<haxe_doc>The 'TextDocumentSaveReason'.</haxe_doc>
			</reason>
		</a>
		<haxe_doc>The parameters send in a will save text document notification.</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.WillSaveTextDocumentNotification" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolNotificationType&lt;WillSaveTextDocumentParams,TextDocumentRegistrationOptions&gt;(&quot;textDocument/willSave&quot;)" line="1621" static="1">
			<x path="languageServerProtocol.protocol.ProtocolNotificationType">
				<t path="languageServerProtocol.protocol.WillSaveTextDocumentParams"/>
				<t path="languageServerProtocol.protocol.TextDocumentRegistrationOptions"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolNotificationType<WillSaveTextDocumentParams,TextDocumentRegistrationOptions>("textDocument/willSave")]]></e></m></meta>
		</type>
		<haxe_doc>A document will save notification is sent from the client to the server before
	the document is actually saved.</haxe_doc>
	</class>
	<class path="languageServerProtocol.protocol.WillSaveTextDocumentWaitUntilRequest" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;WillSaveTextDocumentParams,Null&lt;Array&lt;TextEdit&gt;&gt;,Never,NoData,TextDocumentRegistrationOptions&gt;(&quot;textDocument/willSaveWaitUntil&quot;)" line="1633" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.WillSaveTextDocumentParams"/>
				<x path="Null"><c path="Array"><t path="languageServerProtocol.textdocument.TextEdit"/></c></x>
				<e path="languageServerProtocol.protocol.Never"/>
				<e path="jsonrpc.NoData"/>
				<t path="languageServerProtocol.protocol.TextDocumentRegistrationOptions"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<WillSaveTextDocumentParams,Null<Array<TextEdit>>,Never,NoData,TextDocumentRegistrationOptions>("textDocument/willSaveWaitUntil")]]></e></m></meta>
		</type>
		<haxe_doc>A document will save request is sent from the client to the server before
	the document is actually saved. The request can return an array of TextEdits
	which will be applied to the text document before it is saved. Please note that
	clients might drop results if computing the text edits took too long or if a
	server constantly fails on this request. This is done to keep the save fast and
	reliable.</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.DidChangeWatchedFilesClientCapabilities" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol"><a>
	<relativePatternSupport>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Whether the client has support for {@link  RelativePattern relative pattern}
		or not.

		@since 3.17.0</haxe_doc>
	</relativePatternSupport>
	<dynamicRegistration>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Did change watched files notification supports dynamic registration. Please note
		that the current protocol doesn't support static configuration for file changes
		from the server side.</haxe_doc>
	</dynamicRegistration>
</a></typedef>
	<class path="languageServerProtocol.protocol.DidChangeWatchedFilesNotification" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolNotificationType&lt;DidChangeWatchedFilesParams,DidChangeWatchedFilesRegistrationOptions&gt;(&quot;workspace/didChangeWatchedFiles&quot;)" line="1661" static="1">
			<x path="languageServerProtocol.protocol.ProtocolNotificationType">
				<t path="languageServerProtocol.protocol.DidChangeWatchedFilesParams"/>
				<t path="languageServerProtocol.protocol.DidChangeWatchedFilesRegistrationOptions"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolNotificationType<DidChangeWatchedFilesParams,DidChangeWatchedFilesRegistrationOptions>("workspace/didChangeWatchedFiles")]]></e></m></meta>
		</type>
		<haxe_doc>The watched files notification is sent from the client to the server when
	the client detects changes to file watched by the language client.</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.DidChangeWatchedFilesParams" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a><changes>
	<c path="Array"><t path="languageServerProtocol.protocol.FileEvent"/></c>
	<haxe_doc>The actual file events.</haxe_doc>
</changes></a>
		<haxe_doc>The watched files change notification's parameters.</haxe_doc>
	</typedef>
	<abstract path="languageServerProtocol.protocol.FileChangeType" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<haxe_doc>The file event type.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="languageServerProtocol.protocol._Protocol.FileChangeType_Impl_" params="" file="src/languageServerProtocol/protocol/Protocol.hx" private="1" module="languageServerProtocol.protocol.Protocol" extern="1" final="1">
	<Created public="1" get="inline" set="null" expr="cast 1" line="1682" static="1">
		<x path="languageServerProtocol.protocol.FileChangeType"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>The file got created.</haxe_doc>
	</Created>
	<Changed public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
		<x path="languageServerProtocol.protocol.FileChangeType"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>The file got changed.</haxe_doc>
	</Changed>
	<Deleted public="1" get="inline" set="null" expr="cast 3" line="1" static="1">
		<x path="languageServerProtocol.protocol.FileChangeType"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>The file got deleted.</haxe_doc>
	</Deleted>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="languageServerProtocol.protocol._Protocol.FileChangeType_Impl_" params="" file="src/languageServerProtocol/protocol/Protocol.hx" private="1" module="languageServerProtocol.protocol.Protocol" extern="1" final="1">
		<Created public="1" get="inline" set="null" expr="cast 1" line="1682" static="1">
			<x path="languageServerProtocol.protocol.FileChangeType"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>The file got created.</haxe_doc>
		</Created>
		<Changed public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
			<x path="languageServerProtocol.protocol.FileChangeType"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>The file got changed.</haxe_doc>
		</Changed>
		<Deleted public="1" get="inline" set="null" expr="cast 3" line="1" static="1">
			<x path="languageServerProtocol.protocol.FileChangeType"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>The file got deleted.</haxe_doc>
		</Deleted>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="languageServerProtocol.protocol.FileEvent" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<uri>
				<x path="languageServerProtocol.textdocument.DocumentUri"/>
				<haxe_doc>The file's uri.</haxe_doc>
			</uri>
			<type>
				<x path="languageServerProtocol.protocol.FileChangeType"/>
				<haxe_doc>The change type.</haxe_doc>
			</type>
		</a>
		<haxe_doc>An event describing a file change.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.DidChangeWatchedFilesRegistrationOptions" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a><watchers>
	<c path="Array"><t path="languageServerProtocol.protocol.FileSystemWatcher"/></c>
	<haxe_doc>The watchers to register.</haxe_doc>
</watchers></a>
		<haxe_doc>Describe options to be used when registered for text document change events.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.Pattern" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<c path="String"/>
		<haxe_doc>The glob pattern to watch relative to the base path. Glob patterns can have the following syntax:
	- `*` to match one or more characters in a path segment
	- `?` to match on one character in a path segment
	- `**` to match any number of path segments, including none
	- `{}` to group conditions (e.g. `**​/*.{ts,js}` matches all TypeScript and JavaScript files)
	- `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, …)
	- `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)

	@since 3.17.0</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.RelativePattern" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<pattern>
				<t path="languageServerProtocol.protocol.Pattern"/>
				<haxe_doc>The actual glob pattern;</haxe_doc>
			</pattern>
			<baseUri>
				<x path="haxe.extern.EitherType">
					<t path="languageServerProtocol.WorkspaceFolder"/>
					<x path="languageServerProtocol.URI"/>
				</x>
				<haxe_doc>A workspace folder or a base URI to which this pattern will be matched
		against relatively.</haxe_doc>
			</baseUri>
		</a>
		<haxe_doc>A relative pattern is a helper to construct glob patterns that are matched
	relatively to a base URI. The common value for a `baseUri` is a workspace
	folder root, but it can be another absolute URI as well.

	@since 3.17.0</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.GlobPattern" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol"><x path="haxe.extern.EitherType">
	<t path="languageServerProtocol.protocol.Pattern"/>
	<t path="languageServerProtocol.protocol.RelativePattern"/>
</x></typedef>
	<typedef path="languageServerProtocol.protocol.FileSystemWatcher" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol"><a>
	<kind>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The kind of events of interest. If omitted it defaults
		to WatchKind.Create | WatchKind.Change | WatchKind.Delete
		which is 7.</haxe_doc>
	</kind>
	<globPattern>
		<t path="languageServerProtocol.protocol.GlobPattern"/>
		<haxe_doc>The glob pattern to watch. See {@link GlobPattern glob pattern} for more detail.

		@since 3.17.0 support for relative patterns.</haxe_doc>
	</globPattern>
</a></typedef>
	<abstract path="languageServerProtocol.protocol.WatchKind" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="languageServerProtocol.protocol._Protocol.WatchKind_Impl_" params="" file="src/languageServerProtocol/protocol/Protocol.hx" private="1" module="languageServerProtocol.protocol.Protocol" extern="1" final="1">
	<Create public="1" get="inline" set="null" expr="cast 1" line="1775" static="1">
		<x path="languageServerProtocol.protocol.WatchKind"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Interested in create events.</haxe_doc>
	</Create>
	<Change public="1" get="inline" set="null" expr="cast 2" line="1780" static="1">
		<x path="languageServerProtocol.protocol.WatchKind"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Interested in change events</haxe_doc>
	</Change>
	<Delete public="1" get="inline" set="null" expr="cast 4" line="1785" static="1">
		<x path="languageServerProtocol.protocol.WatchKind"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Interested in delete events</haxe_doc>
	</Delete>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="languageServerProtocol.protocol._Protocol.WatchKind_Impl_" params="" file="src/languageServerProtocol/protocol/Protocol.hx" private="1" module="languageServerProtocol.protocol.Protocol" extern="1" final="1">
		<Create public="1" get="inline" set="null" expr="cast 1" line="1775" static="1">
			<x path="languageServerProtocol.protocol.WatchKind"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Interested in create events.</haxe_doc>
		</Create>
		<Change public="1" get="inline" set="null" expr="cast 2" line="1780" static="1">
			<x path="languageServerProtocol.protocol.WatchKind"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Interested in change events</haxe_doc>
		</Change>
		<Delete public="1" get="inline" set="null" expr="cast 4" line="1785" static="1">
			<x path="languageServerProtocol.protocol.WatchKind"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Interested in delete events</haxe_doc>
		</Delete>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="languageServerProtocol.protocol.PublishDiagnosticsClientCapabilities" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<versionSupport>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether the client interprets the version property of the
		`textDocument/publishDiagnostics` notification`s parameter.

		@since 3.15.0</haxe_doc>
			</versionSupport>
			<tagSupport>
				<x path="Null"><a><valueSet>
	<c path="Array"><x path="languageServerProtocol.DiagnosticTag"/></c>
	<haxe_doc>The tags supported by the client.</haxe_doc>
</valueSet></a></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Client supports the tag property to provide meta data about a diagnostic.
		Clients supporting tags have to handle unknown tags gracefully.

		@since 3.15.0</haxe_doc>
			</tagSupport>
			<relatedInformation>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether the clients accepts diagnostics with related information.</haxe_doc>
			</relatedInformation>
			<dataSupport>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether code action supports the `data` property which is
		preserved between a `textDocument/publishDiagnostics` and
		`textDocument/codeAction` request.

		@since 3.16.0</haxe_doc>
			</dataSupport>
			<codeDescriptionSupport>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Client supports a codeDescription property

		@since 3.16.0</haxe_doc>
			</codeDescriptionSupport>
		</a>
		<haxe_doc>The publish diagnostic client capabilities.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.PublishDiagnosticsParams" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<version>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Optional the version number of the document the diagnostics are published for.

		@since 3.15.0</haxe_doc>
			</version>
			<uri>
				<x path="languageServerProtocol.textdocument.DocumentUri"/>
				<haxe_doc>The URI for which diagnostic information is reported.</haxe_doc>
			</uri>
			<diagnostics>
				<c path="Array"><t path="languageServerProtocol.Diagnostic"/></c>
				<haxe_doc>An array of diagnostic information items.</haxe_doc>
			</diagnostics>
		</a>
		<haxe_doc>The publish diagnostic notification's parameters.</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.PublishDiagnosticsNotification" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolNotificationType&lt;PublishDiagnosticsParams,NoData&gt;(&quot;textDocument/publishDiagnostics&quot;)" line="1864" static="1">
			<x path="languageServerProtocol.protocol.ProtocolNotificationType">
				<t path="languageServerProtocol.protocol.PublishDiagnosticsParams"/>
				<e path="jsonrpc.NoData"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolNotificationType<PublishDiagnosticsParams,NoData>("textDocument/publishDiagnostics")]]></e></m></meta>
		</type>
		<haxe_doc>Diagnostics notification are sent from the server to the client to signal
	results of validation runs.</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.CompletionClientCapabilities" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<insertTextMode>
				<x path="Null"><x path="languageServerProtocol.InsertTextMode"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Defines how the client handles whitespace and indentation
		when accepting a completion item that uses multi line
		text in either `insertText` or `textEdit`.

		@since 3.17.0
		@proposed</haxe_doc>
			</insertTextMode>
			<dynamicRegistration>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether completion supports dynamic registration.</haxe_doc>
			</dynamicRegistration>
			<contextSupport>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The client supports to send additional context information for a
		`textDocument/completion` requestion.</haxe_doc>
			</contextSupport>
			<completionList>
				<x path="Null"><a><itemDefaults>
	<x path="Null"><c path="Array"><c path="String"/></c></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>The client supports the the following itemDefaults on
			a completion list.

			The value lists the supported property names of the
			`CompletionList.itemDefaults` object. If omitted
			no properties are supported.

			@since 3.17.0
			@proposed</haxe_doc>
</itemDefaults></a></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The client supports the following `CompletionList` specific
		capabilities.

		@since 3.17.0
		@proposed</haxe_doc>
			</completionList>
			<completionItemKind>
				<x path="Null"><a><valueSet>
	<x path="Null"><c path="Array"><x path="languageServerProtocol.CompletionItemKind"/></c></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>The completion item kind values the client supports. When this
			property exists the client also guarantees that it will
			handle values outside its set gracefully and falls back
			to a default value when unknown.

			If this property is not present the client only supports
			the completion items kinds from `Text` to `Reference` as defined in
			the initial version of the protocol.</haxe_doc>
</valueSet></a></x>
				<meta><m n=":optional"/></meta>
			</completionItemKind>
			<completionItem>
				<x path="Null"><a>
	<tagSupport>
		<x path="Null"><a><valueSet>
	<c path="Array"><x path="languageServerProtocol.CompletionItemTag"/></c>
	<haxe_doc>The tags supported by the client.</haxe_doc>
</valueSet></a></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Client supports the tag property on a completion item. Clients supporting
			tags have to handle unknown tags gracefully. Clients especially need to
			preserve unknown tags when sending a completion item back to the server in
			a resolve call.

			@since 3.15.0</haxe_doc>
	</tagSupport>
	<snippetSupport>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Client supports snippets as insert text.

			A snippet can define tab stops and placeholders with `$1`, `$2`
			and `${3:foo}`. `$0` defines the final tab stop, it defaults to
			the end of the snippet. Placeholders with equal identifiers are linked,
			that is typing in one will update others too.</haxe_doc>
	</snippetSupport>
	<resolveSupport>
		<x path="Null"><a><properties>
	<c path="Array"><c path="String"/></c>
	<haxe_doc>The properties that a client can resolve lazily.</haxe_doc>
</properties></a></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Indicates which properties a client can resolve lazily on a completion
			item. Before version 3.16.0 only the predefined properties `documentation`
			and `details` could be resolved lazily.

			@since 3.16.0</haxe_doc>
	</resolveSupport>
	<preselectSupport>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Client supports the preselect property on a completion item.</haxe_doc>
	</preselectSupport>
	<labelDetailsSupport>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The client has support for completion item label
			details (see also `CompletionItemLabelDetails`).

			@since 3.17.0
			@proposed</haxe_doc>
	</labelDetailsSupport>
	<insertTextModeSupport>
		<x path="Null"><a><valueSet><c path="Array"><x path="languageServerProtocol.InsertTextMode"/></c></valueSet></a></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The client supports the `insertTextMode` property on
			a completion item to override the whitespace handling mode
			as defined by the client (see `insertTextMode`).

			@since 3.16.0</haxe_doc>
	</insertTextModeSupport>
	<insertReplaceSupport>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Client support insert replace edit to control different behavior if a
			completion item is inserted in the text or should replace text.

			@since 3.16.0 - Proposed state</haxe_doc>
	</insertReplaceSupport>
	<documentationFormat>
		<x path="Null"><c path="Array"><x path="languageServerProtocol.MarkupKind"/></c></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Client supports the follow content formats for the documentation
			property. The order describes the preferred format of the client.</haxe_doc>
	</documentationFormat>
	<deprecatedSupport>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Client supports the deprecated property on a completion item.</haxe_doc>
	</deprecatedSupport>
	<commitCharactersSupport>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Client supports commit characters on a completion item.</haxe_doc>
	</commitCharactersSupport>
</a></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The client supports the following `CompletionItem` specific
		capabilities.</haxe_doc>
			</completionItem>
		</a>
		<haxe_doc>Completion client capabilities</haxe_doc>
	</typedef>
	<abstract path="languageServerProtocol.protocol.CompletionTriggerKind" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<this><x path="Int"/></this>
		<haxe_doc>How a completion was triggered</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="languageServerProtocol.protocol._Protocol.CompletionTriggerKind_Impl_" params="" file="src/languageServerProtocol/protocol/Protocol.hx" private="1" module="languageServerProtocol.protocol.Protocol" extern="1" final="1">
	<Invoked public="1" get="inline" set="null" expr="cast 1" line="2033" static="1">
		<x path="languageServerProtocol.protocol.CompletionTriggerKind"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Completion was triggered by typing an identifier (24x7 code
		complete), manual invocation (e.g Ctrl+Space) or via API.</haxe_doc>
	</Invoked>
	<TriggerCharacter public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
		<x path="languageServerProtocol.protocol.CompletionTriggerKind"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Completion was triggered by a trigger character specified by
		the `triggerCharacters` properties of the `CompletionRegistrationOptions`.</haxe_doc>
	</TriggerCharacter>
	<TriggerForIncompleteCompletions public="1" get="inline" set="null" expr="cast 3" line="1" static="1">
		<x path="languageServerProtocol.protocol.CompletionTriggerKind"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Completion was re-triggered as current completion list is incomplete</haxe_doc>
	</TriggerForIncompleteCompletions>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="languageServerProtocol.protocol._Protocol.CompletionTriggerKind_Impl_" params="" file="src/languageServerProtocol/protocol/Protocol.hx" private="1" module="languageServerProtocol.protocol.Protocol" extern="1" final="1">
		<Invoked public="1" get="inline" set="null" expr="cast 1" line="2033" static="1">
			<x path="languageServerProtocol.protocol.CompletionTriggerKind"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Completion was triggered by typing an identifier (24x7 code
		complete), manual invocation (e.g Ctrl+Space) or via API.</haxe_doc>
		</Invoked>
		<TriggerCharacter public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
			<x path="languageServerProtocol.protocol.CompletionTriggerKind"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Completion was triggered by a trigger character specified by
		the `triggerCharacters` properties of the `CompletionRegistrationOptions`.</haxe_doc>
		</TriggerCharacter>
		<TriggerForIncompleteCompletions public="1" get="inline" set="null" expr="cast 3" line="1" static="1">
			<x path="languageServerProtocol.protocol.CompletionTriggerKind"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Completion was re-triggered as current completion list is incomplete</haxe_doc>
		</TriggerForIncompleteCompletions>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="languageServerProtocol.protocol.CompletionContext" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<triggerKind>
				<x path="languageServerProtocol.protocol.CompletionTriggerKind"/>
				<haxe_doc>How the completion was triggered.</haxe_doc>
			</triggerKind>
			<triggerCharacter>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The trigger character (a single character) that has trigger code complete.
		Is undefined if `triggerKind !== CompletionTriggerKind.TriggerCharacter`</haxe_doc>
			</triggerCharacter>
		</a>
		<haxe_doc>Contains additional information about the context in which a completion request is triggered.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.CompletionParams" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<workDoneToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report work done progress.</haxe_doc>
			</workDoneToken>
			<textDocument>
				<t path="languageServerProtocol.TextDocumentIdentifier"/>
				<haxe_doc>The text document.</haxe_doc>
			</textDocument>
			<position>
				<t path="languageServerProtocol.textdocument.Position"/>
				<haxe_doc>The position inside the text document.</haxe_doc>
			</position>
			<partialResultToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report partial results (e.g. streaming) to
		the client.</haxe_doc>
			</partialResultToken>
			<context>
				<x path="Null"><t path="languageServerProtocol.protocol.CompletionContext"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The completion context. This is only available it the client specifies
		to send this using the client capability `textDocument.completion.contextSupport === true`</haxe_doc>
			</context>
		</a>
		<haxe_doc>Completion parameters</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.CompletionOptions" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<workDoneProgress>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
			</workDoneProgress>
			<triggerCharacters>
				<x path="Null"><c path="Array"><c path="String"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Most tools trigger completion request automatically without explicitly requesting
		it using a keyboard shortcut (e.g. Ctrl+Space). Typically they do so when the user
		starts to type an identifier. For example if the user types `c` in a JavaScript file
		code complete will automatically pop up present `console` besides others as a
		completion item. Characters that make up identifiers don't need to be listed here.

		If code complete should automatically be trigger on characters not being valid inside
		an identifier (for example `.` in JavaScript) list them in `triggerCharacters`.</haxe_doc>
			</triggerCharacters>
			<resolveProvider>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The server provides support to resolve additional information for a completion item.</haxe_doc>
			</resolveProvider>
			<completionItem>
				<x path="Null"><a><labelDetailsSupport>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>The server has support for completion item label
			details (see also `CompletionItemLabelDetails`) when
			receiving a completion item in a resolve call.

			@since 3.17.0
			@proposed</haxe_doc>
</labelDetailsSupport></a></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The server supports the following `CompletionItem` specific
		capabilities.

		@since 3.17.0
		@proposed</haxe_doc>
			</completionItem>
			<allCommitCharacters>
				<x path="Null"><c path="Array"><c path="String"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The list of all possible characters that commit a completion. This field can be used
		if clients don't support individual commmit characters per completion item. See
		`ClientCapabilities.textDocument.completion.completionItem.commitCharactersSupport`

		If a server provides both `allCommitCharacters` and commit characters on an individual
		completion item the ones on the completion item win.

		@since 3.2.0</haxe_doc>
			</allCommitCharacters>
		</a>
		<haxe_doc>Completion options.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.CompletionRegistrationOptions" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<workDoneProgress>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
			</workDoneProgress>
			<triggerCharacters>
				<x path="Null"><c path="Array"><c path="String"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Most tools trigger completion request automatically without explicitly requesting
		it using a keyboard shortcut (e.g. Ctrl+Space). Typically they do so when the user
		starts to type an identifier. For example if the user types `c` in a JavaScript file
		code complete will automatically pop up present `console` besides others as a
		completion item. Characters that make up identifiers don't need to be listed here.

		If code complete should automatically be trigger on characters not being valid inside
		an identifier (for example `.` in JavaScript) list them in `triggerCharacters`.</haxe_doc>
			</triggerCharacters>
			<resolveProvider>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The server provides support to resolve additional information for a completion item.</haxe_doc>
			</resolveProvider>
			<documentSelector>
				<x path="Null"><t path="languageServerProtocol.protocol.DocumentSelector"/></x>
				<haxe_doc>A document selector to identify the scope of the registration. If set to null
		the document selector provided on the client side will be used.</haxe_doc>
			</documentSelector>
			<completionItem>
				<x path="Null"><a><labelDetailsSupport>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>The server has support for completion item label
			details (see also `CompletionItemLabelDetails`) when
			receiving a completion item in a resolve call.

			@since 3.17.0
			@proposed</haxe_doc>
</labelDetailsSupport></a></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The server supports the following `CompletionItem` specific
		capabilities.

		@since 3.17.0
		@proposed</haxe_doc>
			</completionItem>
			<allCommitCharacters>
				<x path="Null"><c path="Array"><c path="String"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The list of all possible characters that commit a completion. This field can be used
		if clients don't support individual commmit characters per completion item. See
		`ClientCapabilities.textDocument.completion.completionItem.commitCharactersSupport`

		If a server provides both `allCommitCharacters` and commit characters on an individual
		completion item the ones on the completion item win.

		@since 3.2.0</haxe_doc>
			</allCommitCharacters>
		</a>
		<haxe_doc>Registration options for a [CompletionRequest](#CompletionRequest).</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.CompletionRequest" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;CompletionParams,Null&lt;EitherType&lt;Array&lt;CompletionItem&gt;,CompletionList&gt;&gt;,Array&lt;CompletionItem&gt;,NoData,CompletionRegistrationOptions&gt;(&quot;textDocument/completion&quot;)" line="2146" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.CompletionParams"/>
				<x path="Null"><x path="haxe.extern.EitherType">
	<c path="Array"><t path="languageServerProtocol.CompletionItem"/></c>
	<t path="languageServerProtocol.CompletionList"/>
</x></x>
				<c path="Array"><t path="languageServerProtocol.CompletionItem"/></c>
				<e path="jsonrpc.NoData"/>
				<t path="languageServerProtocol.protocol.CompletionRegistrationOptions"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<CompletionParams,Null<EitherType<Array<CompletionItem>,CompletionList>>,Array<CompletionItem>,NoData,CompletionRegistrationOptions>("textDocument/completion")]]></e></m></meta>
		</type>
		<haxe_doc>Request to request completion at a given text document position. The request's
	parameter is of type [TextDocumentPosition](#TextDocumentPosition) the response
	is of type [CompletionItem[]](#CompletionItem) or [CompletionList](#CompletionList)
	or a Thenable that resolves to such.

	The request can delay the computation of the [`detail`](#CompletionItem.detail)
	and [`documentation`](#CompletionItem.documentation) properties to the `completionItem/resolve`
	request. However, properties that are needed for the initial sorting and filtering, like `sortText`,
	`filterText`, `insertText`, and `textEdit`, must not be changed during resolve.</haxe_doc>
	</class>
	<class path="languageServerProtocol.protocol.CompletionResolveRequest" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;CompletionItem,CompletionItem,Never,NoData,NoData&gt;(&quot;completionItem/resolve&quot;)" line="2156" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.CompletionItem"/>
				<t path="languageServerProtocol.CompletionItem"/>
				<e path="languageServerProtocol.protocol.Never"/>
				<e path="jsonrpc.NoData"/>
				<e path="jsonrpc.NoData"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<CompletionItem,CompletionItem,Never,NoData,NoData>("completionItem/resolve")]]></e></m></meta>
		</type>
		<haxe_doc>Request to resolve additional information for a given completion item.The request's
	parameter is of type [CompletionItem](#CompletionItem) the response
	is of type [CompletionItem](#CompletionItem) or a Thenable that resolves to such.</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.HoverClientCapabilities" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol"><a>
	<dynamicRegistration>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Whether hover supports dynamic registration.</haxe_doc>
	</dynamicRegistration>
	<contentFormat>
		<x path="Null"><c path="Array"><x path="languageServerProtocol.MarkupKind"/></c></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Client supports the follow content formats for the content
		property. The order describes the preferred format of the client.</haxe_doc>
	</contentFormat>
</a></typedef>
	<typedef path="languageServerProtocol.protocol.HoverOptions" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<t path="languageServerProtocol.protocol.WorkDoneProgressOptions"/>
		<haxe_doc>Hover options.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.HoverParams" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<workDoneToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report work done progress.</haxe_doc>
			</workDoneToken>
			<textDocument>
				<t path="languageServerProtocol.TextDocumentIdentifier"/>
				<haxe_doc>The text document.</haxe_doc>
			</textDocument>
			<position>
				<t path="languageServerProtocol.textdocument.Position"/>
				<haxe_doc>The position inside the text document.</haxe_doc>
			</position>
		</a>
		<haxe_doc>Parameters for a [HoverRequest](#HoverRequest).</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.HoverRegistrationOptions" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<workDoneProgress>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
			</workDoneProgress>
			<documentSelector>
				<x path="Null"><t path="languageServerProtocol.protocol.DocumentSelector"/></x>
				<haxe_doc>A document selector to identify the scope of the registration. If set to null
		the document selector provided on the client side will be used.</haxe_doc>
			</documentSelector>
		</a>
		<haxe_doc>Registration options for a [HoverRequest](#HoverRequest).</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.HoverRequest" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;HoverParams,Null&lt;Hover&gt;,Never,NoData,HoverRegistrationOptions&gt;(&quot;textDocument/hover&quot;)" line="2195" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.HoverParams"/>
				<x path="Null"><t path="languageServerProtocol.Hover"/></x>
				<e path="languageServerProtocol.protocol.Never"/>
				<e path="jsonrpc.NoData"/>
				<t path="languageServerProtocol.protocol.HoverRegistrationOptions"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<HoverParams,Null<Hover>,Never,NoData,HoverRegistrationOptions>("textDocument/hover")]]></e></m></meta>
		</type>
		<haxe_doc>Request to request hover information at a given text document position. The request's
	parameter is of type [TextDocumentPosition](#TextDocumentPosition) the response is of
	type [Hover](#Hover) or a Thenable that resolves to such.</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.SignatureHelpClientCapabilities" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<signatureInformation>
				<x path="Null"><a>
	<parameterInformation>
		<x path="Null"><a><labelOffsetSupport>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>The client supports processing label offsets instead of a
				simple label string.

				@since 3.14.0</haxe_doc>
</labelOffsetSupport></a></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Client capabilities specific to parameter information.</haxe_doc>
	</parameterInformation>
	<documentationFormat>
		<x path="Null"><c path="Array"><x path="languageServerProtocol.MarkupKind"/></c></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Client supports the follow content formats for the documentation
			property. The order describes the preferred format of the client.</haxe_doc>
	</documentationFormat>
	<activeParameterSupport>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The client support the `activeParameter` property on `SignatureInformation`
			literal.

			@since 3.16.0</haxe_doc>
	</activeParameterSupport>
</a></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The client supports the following `SignatureInformation`
		specific properties.</haxe_doc>
			</signatureInformation>
			<dynamicRegistration>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether signature help supports dynamic registration.</haxe_doc>
			</dynamicRegistration>
			<contextSupport>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The client supports to send additional context information for a
		`textDocument/signatureHelp` request. A client that opts into
		contextSupport will also support the `retriggerCharacters` on
		`SignatureHelpOptions`.

		@since 3.15.0</haxe_doc>
			</contextSupport>
		</a>
		<haxe_doc>Client Capabilities for a [SignatureHelpRequest](#SignatureHelpRequest).</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.SignatureHelpOptions" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<workDoneProgress>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
			</workDoneProgress>
			<triggerCharacters>
				<x path="Null"><c path="Array"><c path="String"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The characters that trigger signature help automatically.</haxe_doc>
			</triggerCharacters>
			<retriggerCharacters>
				<x path="Null"><c path="Array"><c path="String"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>List of characters that re-trigger signature help.

		These trigger characters are only active when signature help is already showing. All trigger characters
		are also counted as re-trigger characters.

		@since 3.15.0</haxe_doc>
			</retriggerCharacters>
		</a>
		<haxe_doc>Signature help options.</haxe_doc>
	</typedef>
	<abstract path="languageServerProtocol.protocol.SignatureHelpTriggerKind" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<this><x path="Int"/></this>
		<haxe_doc>How a signature help was triggered.

	@since 3.15.0</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="languageServerProtocol.protocol._Protocol.SignatureHelpTriggerKind_Impl_" params="" file="src/languageServerProtocol/protocol/Protocol.hx" private="1" module="languageServerProtocol.protocol.Protocol" extern="1" final="1">
	<Invoked public="1" get="inline" set="null" expr="cast 1" line="2282" static="1">
		<x path="languageServerProtocol.protocol.SignatureHelpTriggerKind"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Signature help was invoked manually by the user or by a command.</haxe_doc>
	</Invoked>
	<TriggerCharacter public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
		<x path="languageServerProtocol.protocol.SignatureHelpTriggerKind"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Signature help was triggered by a trigger character.</haxe_doc>
	</TriggerCharacter>
	<ContentChange public="1" get="inline" set="null" expr="cast 3" line="1" static="1">
		<x path="languageServerProtocol.protocol.SignatureHelpTriggerKind"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Signature help was triggered by the cursor moving or by the document content changing.</haxe_doc>
	</ContentChange>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="languageServerProtocol.protocol._Protocol.SignatureHelpTriggerKind_Impl_" params="" file="src/languageServerProtocol/protocol/Protocol.hx" private="1" module="languageServerProtocol.protocol.Protocol" extern="1" final="1">
		<Invoked public="1" get="inline" set="null" expr="cast 1" line="2282" static="1">
			<x path="languageServerProtocol.protocol.SignatureHelpTriggerKind"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Signature help was invoked manually by the user or by a command.</haxe_doc>
		</Invoked>
		<TriggerCharacter public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
			<x path="languageServerProtocol.protocol.SignatureHelpTriggerKind"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Signature help was triggered by a trigger character.</haxe_doc>
		</TriggerCharacter>
		<ContentChange public="1" get="inline" set="null" expr="cast 3" line="1" static="1">
			<x path="languageServerProtocol.protocol.SignatureHelpTriggerKind"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Signature help was triggered by the cursor moving or by the document content changing.</haxe_doc>
		</ContentChange>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="languageServerProtocol.protocol.SignatureHelpContext" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<triggerKind>
				<x path="languageServerProtocol.protocol.SignatureHelpTriggerKind"/>
				<haxe_doc>Action that caused signature help to be triggered.</haxe_doc>
			</triggerKind>
			<triggerCharacter>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Character that caused signature help to be triggered.

		This is undefined when `triggerKind !== SignatureHelpTriggerKind.TriggerCharacter`</haxe_doc>
			</triggerCharacter>
			<isRetrigger>
				<x path="Bool"/>
				<haxe_doc>`true` if signature help was already showing when it was triggered.

		Retriggers occur when the signature help is already active and can be caused by actions such as
		typing a trigger character, a cursor move, or document content changes.</haxe_doc>
			</isRetrigger>
			<activeSignatureHelp>
				<x path="Null"><t path="languageServerProtocol.SignatureHelp"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The currently active `SignatureHelp`.

		The `activeSignatureHelp` has its `SignatureHelp.activeSignature` field updated based on
		the user navigating through available signatures.</haxe_doc>
			</activeSignatureHelp>
		</a>
		<haxe_doc>Additional information about the context in which a signature help request was triggered.

	@since 3.15.0</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.SignatureHelpParams" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<workDoneToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report work done progress.</haxe_doc>
			</workDoneToken>
			<textDocument>
				<t path="languageServerProtocol.TextDocumentIdentifier"/>
				<haxe_doc>The text document.</haxe_doc>
			</textDocument>
			<position>
				<t path="languageServerProtocol.textdocument.Position"/>
				<haxe_doc>The position inside the text document.</haxe_doc>
			</position>
			<context>
				<x path="Null"><t path="languageServerProtocol.protocol.SignatureHelpContext"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The signature help context. This is only available if the client specifies
		to send this using the client capability `textDocument.signatureHelp.contextSupport === true`

		@since 3.15.0</haxe_doc>
			</context>
		</a>
		<haxe_doc>Parameters for a [SignatureHelpRequest](#SignatureHelpRequest).</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.SignatureHelpRegistrationOptions" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<workDoneProgress>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
			</workDoneProgress>
			<triggerCharacters>
				<x path="Null"><c path="Array"><c path="String"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The characters that trigger signature help automatically.</haxe_doc>
			</triggerCharacters>
			<retriggerCharacters>
				<x path="Null"><c path="Array"><c path="String"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>List of characters that re-trigger signature help.

		These trigger characters are only active when signature help is already showing. All trigger characters
		are also counted as re-trigger characters.

		@since 3.15.0</haxe_doc>
			</retriggerCharacters>
			<documentSelector>
				<x path="Null"><t path="languageServerProtocol.protocol.DocumentSelector"/></x>
				<haxe_doc>A document selector to identify the scope of the registration. If set to null
		the document selector provided on the client side will be used.</haxe_doc>
			</documentSelector>
		</a>
		<haxe_doc>Registration options for a [SignatureHelpRequest](#SignatureHelpRequest).</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.SignatureHelpRequest" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol"><type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;SignatureHelpParams,Null&lt;SignatureHelp&gt;,Never,NoData,SignatureHelpRegistrationOptions&gt;(&quot;textDocument/signatureHelp&quot;)" line="2350" static="1">
	<x path="languageServerProtocol.protocol.ProtocolRequestType">
		<t path="languageServerProtocol.protocol.SignatureHelpParams"/>
		<x path="Null"><t path="languageServerProtocol.SignatureHelp"/></x>
		<e path="languageServerProtocol.protocol.Never"/>
		<e path="jsonrpc.NoData"/>
		<t path="languageServerProtocol.protocol.SignatureHelpRegistrationOptions"/>
	</x>
	<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<SignatureHelpParams,Null<SignatureHelp>,Never,NoData,SignatureHelpRegistrationOptions>("textDocument/signatureHelp")]]></e></m></meta>
</type></class>
	<typedef path="languageServerProtocol.protocol.DefinitionClientCapabilities" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<linkSupport>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The client supports additional metadata in the form of definition links.

		@since 3.14.0</haxe_doc>
			</linkSupport>
			<dynamicRegistration>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether definition supports dynamic registration.</haxe_doc>
			</dynamicRegistration>
		</a>
		<haxe_doc>Client Capabilities for a [DefinitionRequest](#DefinitionRequest).</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.DefinitionOptions" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<t path="languageServerProtocol.protocol.WorkDoneProgressOptions"/>
		<haxe_doc>Server Capabilities for a [DefinitionRequest](#DefinitionRequest).</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.DefinitionParams" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<workDoneToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report work done progress.</haxe_doc>
			</workDoneToken>
			<textDocument>
				<t path="languageServerProtocol.TextDocumentIdentifier"/>
				<haxe_doc>The text document.</haxe_doc>
			</textDocument>
			<position>
				<t path="languageServerProtocol.textdocument.Position"/>
				<haxe_doc>The position inside the text document.</haxe_doc>
			</position>
			<partialResultToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report partial results (e.g. streaming) to
		the client.</haxe_doc>
			</partialResultToken>
		</a>
		<haxe_doc>Parameters for a [DefinitionParams](#DefinitionParams).</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.DefinitionRegistrationOptions" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<workDoneProgress>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
			</workDoneProgress>
			<documentSelector>
				<x path="Null"><t path="languageServerProtocol.protocol.DocumentSelector"/></x>
				<haxe_doc>A document selector to identify the scope of the registration. If set to null
		the document selector provided on the client side will be used.</haxe_doc>
			</documentSelector>
		</a>
		<haxe_doc>Registration options for a [DefinitionRequest](#DefinitionRequest).</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.DefinitionRequest" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;DefinitionParams,Null&lt;EitherType&lt;Definition,Array&lt;DefinitionLink&gt;&gt;&gt;,EitherType&lt;Array&lt;Location&gt;,Array&lt;DefinitionLink&gt;&gt;,NoData,DefinitionRegistrationOptions&gt;(&quot;textDocument/definition&quot;)" line="2396" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.DefinitionParams"/>
				<x path="Null"><x path="haxe.extern.EitherType">
	<t path="languageServerProtocol.Definition"/>
	<c path="Array"><t path="languageServerProtocol.DefinitionLink"/></c>
</x></x>
				<x path="haxe.extern.EitherType">
					<c path="Array"><t path="languageServerProtocol.Location"/></c>
					<c path="Array"><t path="languageServerProtocol.DefinitionLink"/></c>
				</x>
				<e path="jsonrpc.NoData"/>
				<t path="languageServerProtocol.protocol.DefinitionRegistrationOptions"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<DefinitionParams,Null<EitherType<Definition,Array<DefinitionLink>>>,EitherType<Array<Location>,Array<DefinitionLink>>,NoData,DefinitionRegistrationOptions>("textDocument/definition")]]></e></m></meta>
		</type>
		<haxe_doc>A request to resolve the definition location of a symbol at a given text
	document position. The request's parameter is of type [TextDocumentPosition]
	(#TextDocumentPosition) the response is of either type [Definition](#Definition)
	or a typed array of [DefinitionLink](#DefinitionLink) or a Thenable that resolves
	to such.</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.ReferenceClientCapabilities" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a><dynamicRegistration>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>Whether references supports dynamic registration.</haxe_doc>
</dynamicRegistration></a>
		<haxe_doc>Client Capabilities for a [ReferencesRequest](#ReferencesRequest).</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.ReferenceParams" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<workDoneToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report work done progress.</haxe_doc>
			</workDoneToken>
			<textDocument>
				<t path="languageServerProtocol.TextDocumentIdentifier"/>
				<haxe_doc>The text document.</haxe_doc>
			</textDocument>
			<position>
				<t path="languageServerProtocol.textdocument.Position"/>
				<haxe_doc>The position inside the text document.</haxe_doc>
			</position>
			<partialResultToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report partial results (e.g. streaming) to
		the client.</haxe_doc>
			</partialResultToken>
			<context><t path="languageServerProtocol.ReferenceContext"/></context>
		</a>
		<haxe_doc>Parameters for a [ReferencesRequest](#ReferencesRequest).</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.ReferenceOptions" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<t path="languageServerProtocol.protocol.WorkDoneProgressOptions"/>
		<haxe_doc>Reference options.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.ReferenceRegistrationOptions" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<workDoneProgress>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
			</workDoneProgress>
			<documentSelector>
				<x path="Null"><t path="languageServerProtocol.protocol.DocumentSelector"/></x>
				<haxe_doc>A document selector to identify the scope of the registration. If set to null
		the document selector provided on the client side will be used.</haxe_doc>
			</documentSelector>
		</a>
		<haxe_doc>Registration options for a [ReferencesRequest](#ReferencesRequest).</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.ReferencesRequest" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;ReferenceParams,Null&lt;Array&lt;Location&gt;&gt;,Array&lt;Location&gt;,NoData,ReferenceRegistrationOptions&gt;(&quot;textDocument/references&quot;)" line="2438" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.ReferenceParams"/>
				<x path="Null"><c path="Array"><t path="languageServerProtocol.Location"/></c></x>
				<c path="Array"><t path="languageServerProtocol.Location"/></c>
				<e path="jsonrpc.NoData"/>
				<t path="languageServerProtocol.protocol.ReferenceRegistrationOptions"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<ReferenceParams,Null<Array<Location>>,Array<Location>,NoData,ReferenceRegistrationOptions>("textDocument/references")]]></e></m></meta>
		</type>
		<haxe_doc>A request to resolve project-wide references for the symbol denoted
	by the given text document position. The request's parameter is of
	type [ReferenceParams](#ReferenceParams) the response is of type
	[Location[]](#Location) or a Thenable that resolves to such.</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.DocumentHighlightClientCapabilities" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a><dynamicRegistration>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>Whether document highlight supports dynamic registration.</haxe_doc>
</dynamicRegistration></a>
		<haxe_doc>Client Capabilities for a [DocumentHighlightRequest](#DocumentHighlightRequest).</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.DocumentHighlightParams" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<workDoneToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report work done progress.</haxe_doc>
			</workDoneToken>
			<textDocument>
				<t path="languageServerProtocol.TextDocumentIdentifier"/>
				<haxe_doc>The text document.</haxe_doc>
			</textDocument>
			<position>
				<t path="languageServerProtocol.textdocument.Position"/>
				<haxe_doc>The position inside the text document.</haxe_doc>
			</position>
			<partialResultToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report partial results (e.g. streaming) to
		the client.</haxe_doc>
			</partialResultToken>
		</a>
		<haxe_doc>Parameters for a [DocumentHighlightRequest](#DocumentHighlightRequest).</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.DocumentHighlightOptions" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<t path="languageServerProtocol.protocol.WorkDoneProgressOptions"/>
		<haxe_doc>Provider options for a [DocumentHighlightRequest](#DocumentHighlightRequest).</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.DocumentHighlightRegistrationOptions" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<workDoneProgress>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
			</workDoneProgress>
			<documentSelector>
				<x path="Null"><t path="languageServerProtocol.protocol.DocumentSelector"/></x>
				<haxe_doc>A document selector to identify the scope of the registration. If set to null
		the document selector provided on the client side will be used.</haxe_doc>
			</documentSelector>
		</a>
		<haxe_doc>Registration options for a [DocumentHighlightRequest](#DocumentHighlightRequest).</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.DocumentHighlightRequest" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;DocumentHighlightParams,Null&lt;Array&lt;DocumentHighlight&gt;&gt;,Array&lt;DocumentHighlight&gt;,NoData,DocumentHighlightRegistrationOptions&gt;(&quot;textDocument/documentHighlight&quot;)" line="2476" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.DocumentHighlightParams"/>
				<x path="Null"><c path="Array"><t path="languageServerProtocol.DocumentHighlight"/></c></x>
				<c path="Array"><t path="languageServerProtocol.DocumentHighlight"/></c>
				<e path="jsonrpc.NoData"/>
				<t path="languageServerProtocol.protocol.DocumentHighlightRegistrationOptions"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<DocumentHighlightParams,Null<Array<DocumentHighlight>>,Array<DocumentHighlight>,NoData,DocumentHighlightRegistrationOptions>("textDocument/documentHighlight")]]></e></m></meta>
		</type>
		<haxe_doc>Request to resolve a [DocumentHighlight](#DocumentHighlight) for a given
	text document position. The request's parameter is of type [TextDocumentPosition]
	(#TextDocumentPosition) the request response is of type [DocumentHighlight[]]
	(#DocumentHighlight) or a Thenable that resolves to such.</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.DocumentSymbolClientCapabilities" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<tagSupport>
				<x path="Null"><a><valueSet>
	<c path="Array"><x path="languageServerProtocol.SymbolTag"/></c>
	<haxe_doc>The tags supported by the client.</haxe_doc>
</valueSet></a></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The client supports tags on `SymbolInformation`. Tags are supported on
		`DocumentSymbol` if `hierarchicalDocumentSymbolSupport` is set tot true.
		Clients supporting tags have to handle unknown tags gracefully.

		@since 3.16.0 - Proposed state</haxe_doc>
			</tagSupport>
			<symbolKind>
				<x path="Null"><a><valueSet>
	<x path="Null"><c path="Array"><x path="languageServerProtocol.SymbolKind"/></c></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>The symbol kind values the client supports. When this
			property exists the client also guarantees that it will
			handle values outside its set gracefully and falls back
			to a default value when unknown.

			If this property is not present the client only supports
			the symbol kinds from `File` to `Array` as defined in
			the initial version of the protocol.</haxe_doc>
</valueSet></a></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Specific capabilities for the `SymbolKind`.</haxe_doc>
			</symbolKind>
			<labelSupport>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The client supports an additional label presented in the UI when
		registering a document symbol provider.

		@since 3.16.0</haxe_doc>
			</labelSupport>
			<hierarchicalDocumentSymbolSupport>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The client support hierarchical document symbols.</haxe_doc>
			</hierarchicalDocumentSymbolSupport>
			<dynamicRegistration>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether document symbol supports dynamic registration.</haxe_doc>
			</dynamicRegistration>
		</a>
		<haxe_doc>Client Capabilities for a [DocumentSymbolRequest](#DocumentSymbolRequest).</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.DocumentSymbolParams" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<workDoneToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report work done progress.</haxe_doc>
			</workDoneToken>
			<textDocument>
				<t path="languageServerProtocol.TextDocumentIdentifier"/>
				<haxe_doc>The text document.</haxe_doc>
			</textDocument>
			<partialResultToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report partial results (e.g. streaming) to
		the client.</haxe_doc>
			</partialResultToken>
		</a>
		<haxe_doc>Parameters for a [DocumentSymbolRequest](#DocumentSymbolRequest).</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.DocumentSymbolOptions" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<workDoneProgress>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
			</workDoneProgress>
			<label>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>A human-readable string that is shown when multiple outlines trees
		are shown for the same document.

		@since 3.16.0</haxe_doc>
			</label>
		</a>
		<haxe_doc>Provider options for a [DocumentSymbolRequest](#DocumentSymbolRequest).</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.DocumentSymbolRegistrationOptions" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<workDoneProgress>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
			</workDoneProgress>
			<label>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>A human-readable string that is shown when multiple outlines trees
		are shown for the same document.

		@since 3.16.0</haxe_doc>
			</label>
			<documentSelector>
				<x path="Null"><t path="languageServerProtocol.protocol.DocumentSelector"/></x>
				<haxe_doc>A document selector to identify the scope of the registration. If set to null
		the document selector provided on the client side will be used.</haxe_doc>
			</documentSelector>
		</a>
		<haxe_doc>Registration options for a [DocumentSymbolRequest](#DocumentSymbolRequest).</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.DocumentSymbolRequest" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;DocumentSymbolParams,Null&lt;EitherType&lt;Array&lt;SymbolInformation&gt;,Array&lt;DocumentSymbol&gt;&gt;&gt;,EitherType&lt;Array&lt;SymbolInformation&gt;,Array&lt;DocumentSymbol&gt;&gt;,NoData,DocumentSymbolRegistrationOptions&gt;(&quot;textDocument/documentSymbol&quot;)" line="2572" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.DocumentSymbolParams"/>
				<x path="Null"><x path="haxe.extern.EitherType">
	<c path="Array"><t path="languageServerProtocol.SymbolInformation"/></c>
	<c path="Array"><t path="languageServerProtocol.DocumentSymbol"/></c>
</x></x>
				<x path="haxe.extern.EitherType">
					<c path="Array"><t path="languageServerProtocol.SymbolInformation"/></c>
					<c path="Array"><t path="languageServerProtocol.DocumentSymbol"/></c>
				</x>
				<e path="jsonrpc.NoData"/>
				<t path="languageServerProtocol.protocol.DocumentSymbolRegistrationOptions"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<DocumentSymbolParams,Null<EitherType<Array<SymbolInformation>,Array<DocumentSymbol>>>,EitherType<Array<SymbolInformation>,Array<DocumentSymbol>>,NoData,DocumentSymbolRegistrationOptions>("textDocument/documentSymbol")]]></e></m></meta>
		</type>
		<haxe_doc>A request to list all symbols found in a given text document. The request's
	parameter is of type [TextDocumentIdentifier](#TextDocumentIdentifier) the
	response is of type [SymbolInformation[]](#SymbolInformation) or a Thenable
	that resolves to such.</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.CodeActionClientCapabilities" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<resolveSupport>
				<x path="Null"><a><properties>
	<c path="Array"><c path="String"/></c>
	<haxe_doc>The properties that a client can resolve lazily.</haxe_doc>
</properties></a></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether the client support resolving additional code action
		properties via a separate `codeAction/resolve` request.

		@since 3.16.0</haxe_doc>
			</resolveSupport>
			<isPreferredSupport>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether code action supports the `isPreferred` property.
		@since 3.15.0</haxe_doc>
			</isPreferredSupport>
			<honorsChangeAnnotations>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether th client honors the change annotations in
		text edits and resource operations returned via the
		`CodeAction#edit` property by for example presenting
		the workspace edit in the user interface and asking
		for confirmation.

		@since 3.16.0</haxe_doc>
			</honorsChangeAnnotations>
			<dynamicRegistration>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether code action supports dynamic registration.</haxe_doc>
			</dynamicRegistration>
			<disabledSupport>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether code action supports the `disabled` property.

		@since 3.16.0</haxe_doc>
			</disabledSupport>
			<dataSupport>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether code action supports the `data` property which is
		preserved between a `textDocument/codeAction` and a
		`codeAction/resolve` request.

		@since 3.16.0</haxe_doc>
			</dataSupport>
			<codeActionLiteralSupport>
				<x path="Null"><a><codeActionKind>
	<a><valueSet>
	<c path="Array"><x path="languageServerProtocol.CodeActionKind"/></c>
	<haxe_doc>The code action kind values the client supports. When this
				property exists the client also guarantees that it will
				handle values outside its set gracefully and falls back
				to a default value when unknown.</haxe_doc>
</valueSet></a>
	<haxe_doc>The code action kind is support with the following value
			set.</haxe_doc>
</codeActionKind></a></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The client support code action literals as a valid
		response of the `textDocument/codeAction` request.

		@since 3.8.0</haxe_doc>
			</codeActionLiteralSupport>
		</a>
		<haxe_doc>The Client Capabilities of a [CodeActionRequest](#CodeActionRequest).</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.CodeActionParams" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<workDoneToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report work done progress.</haxe_doc>
			</workDoneToken>
			<textDocument>
				<t path="languageServerProtocol.TextDocumentIdentifier"/>
				<haxe_doc>The document in which the command was invoked.</haxe_doc>
			</textDocument>
			<range>
				<t path="languageServerProtocol.textdocument.Range"/>
				<haxe_doc>The range for which the command was invoked.</haxe_doc>
			</range>
			<partialResultToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report partial results (e.g. streaming) to
		the client.</haxe_doc>
			</partialResultToken>
			<context>
				<t path="languageServerProtocol.CodeActionContext"/>
				<haxe_doc>Context carrying additional information.</haxe_doc>
			</context>
		</a>
		<haxe_doc>The parameters of a [CodeActionRequest](#CodeActionRequest).</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.CodeActionOptions" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<workDoneProgress>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
			</workDoneProgress>
			<resolveProvider>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The server provides support to resolve additional
		information for a code action.

		@since 3.16.0</haxe_doc>
			</resolveProvider>
			<codeActionKinds>
				<x path="Null"><c path="Array"><x path="languageServerProtocol.CodeActionKind"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>CodeActionKinds that this server may return.

		The list of kinds may be generic, such as `CodeActionKind.Refactor`, or the server
		may list out every specific kind they provide.</haxe_doc>
			</codeActionKinds>
		</a>
		<haxe_doc>Provider options for a [CodeActionRequest](#CodeActionRequest).</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.CodeActionRegistrationOptions" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<workDoneProgress>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
			</workDoneProgress>
			<resolveProvider>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The server provides support to resolve additional
		information for a code action.

		@since 3.16.0</haxe_doc>
			</resolveProvider>
			<documentSelector>
				<x path="Null"><t path="languageServerProtocol.protocol.DocumentSelector"/></x>
				<haxe_doc>A document selector to identify the scope of the registration. If set to null
		the document selector provided on the client side will be used.</haxe_doc>
			</documentSelector>
			<codeActionKinds>
				<x path="Null"><c path="Array"><x path="languageServerProtocol.CodeActionKind"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>CodeActionKinds that this server may return.

		The list of kinds may be generic, such as `CodeActionKind.Refactor`, or the server
		may list out every specific kind they provide.</haxe_doc>
			</codeActionKinds>
		</a>
		<haxe_doc>Registration options for a [CodeActionRequest](#CodeActionRequest).</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.CodeActionRequest" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;CodeActionParams,Null&lt;Array&lt;EitherType&lt;Command,CodeAction&gt;&gt;&gt;,Array&lt;EitherType&lt;Command,CodeAction&gt;&gt;,NoData,CodeActionRegistrationOptions&gt;(&quot;textDocument/codeAction&quot;)" line="2707" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.CodeActionParams"/>
				<x path="Null"><c path="Array"><x path="haxe.extern.EitherType">
	<t path="languageServerProtocol.Command"/>
	<t path="languageServerProtocol.CodeAction"/>
</x></c></x>
				<c path="Array"><x path="haxe.extern.EitherType">
	<t path="languageServerProtocol.Command"/>
	<t path="languageServerProtocol.CodeAction"/>
</x></c>
				<e path="jsonrpc.NoData"/>
				<t path="languageServerProtocol.protocol.CodeActionRegistrationOptions"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<CodeActionParams,Null<Array<EitherType<Command,CodeAction>>>,Array<EitherType<Command,CodeAction>>,NoData,CodeActionRegistrationOptions>("textDocument/codeAction")]]></e></m></meta>
		</type>
		<haxe_doc>A request to provide commands for the given text document and range.</haxe_doc>
	</class>
	<class path="languageServerProtocol.protocol.CodeActionResolveRequest" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;CodeAction,CodeAction,Never,NoData,NoData&gt;(&quot;codeAction/resolve&quot;)" line="2717" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.CodeAction"/>
				<t path="languageServerProtocol.CodeAction"/>
				<e path="languageServerProtocol.protocol.Never"/>
				<e path="jsonrpc.NoData"/>
				<e path="jsonrpc.NoData"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<CodeAction,CodeAction,Never,NoData,NoData>("codeAction/resolve")]]></e></m></meta>
		</type>
		<haxe_doc>Request to resolve additional information for a given code action.The request's
	parameter is of type [CodeAction](#CodeAction) the response
	is of type [CodeAction](#CodeAction) or a Thenable that resolves to such.</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.WorkspaceSymbolClientCapabilities" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<tagSupport>
				<x path="Null"><a><valueSet>
	<c path="Array"><x path="languageServerProtocol.SymbolTag"/></c>
	<haxe_doc>The tags supported by the client.</haxe_doc>
</valueSet></a></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The client supports tags on `SymbolInformation`.
		Clients supporting tags have to handle unknown tags gracefully.

		@since 3.16.0 - Proposed state</haxe_doc>
			</tagSupport>
			<symbolKind>
				<x path="Null"><a><valueSet>
	<x path="Null"><c path="Array"><x path="languageServerProtocol.SymbolKind"/></c></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>The symbol kind values the client supports. When this
			property exists the client also guarantees that it will
			handle values outside its set gracefully and falls back
			to a default value when unknown.

			If this property is not present the client only supports
			the symbol kinds from `File` to `Array` as defined in
			the initial version of the protocol.</haxe_doc>
</valueSet></a></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Specific capabilities for the `SymbolKind` in the `workspace/symbol` request.</haxe_doc>
			</symbolKind>
			<resolveSupport>
				<a><properties>
	<c path="Array"><c path="String"/></c>
	<haxe_doc>The properties that a client can resolve lazily. Usually
			`location.range`</haxe_doc>
</properties></a>
				<haxe_doc>The client support partial workspace symbols. The client will send the
		request `workspaceSymbol/resolve` to the server to resolve additional
		properties.

		@since 3.17.0
		@proposed</haxe_doc>
			</resolveSupport>
			<dynamicRegistration>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Symbol request supports dynamic registration.</haxe_doc>
			</dynamicRegistration>
		</a>
		<haxe_doc>Client capabilities for a [WorkspaceSymbolRequest](#WorkspaceSymbolRequest).</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.WorkspaceSymbolParams" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<workDoneToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report work done progress.</haxe_doc>
			</workDoneToken>
			<query>
				<c path="String"/>
				<haxe_doc>A query string to filter symbols by. Clients may send an empty
		string here to request all symbols.</haxe_doc>
			</query>
			<partialResultToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report partial results (e.g. streaming) to
		the client.</haxe_doc>
			</partialResultToken>
		</a>
		<haxe_doc>The parameters of a [WorkspaceSymbolRequest](#WorkspaceSymbolRequest).</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.WorkspaceSymbolOptions" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<workDoneProgress>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
			</workDoneProgress>
			<resolveProvider>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The server provides support to resolve additional
		information for a workspace symbol.

		@since 3.17.0
		@proposed</haxe_doc>
			</resolveProvider>
		</a>
		<haxe_doc>Server capabilities for a [WorkspaceSymbolRequest](#WorkspaceSymbolRequest).</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.WorkspaceSymbolRegistrationOptions" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<t path="languageServerProtocol.protocol.WorkspaceSymbolOptions"/>
		<haxe_doc>Registration options for a [WorkspaceSymbolRequest](#WorkspaceSymbolRequest).</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.WorkspaceSymbolRequest" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;WorkspaceSymbolParams,Null&lt;EitherType&lt;Array&lt;SymbolInformation&gt;,Array&lt;WorkspaceSymbol&gt;&gt;&gt;,EitherType&lt;Array&lt;SymbolInformation&gt;,Array&lt;WorkspaceSymbol&gt;&gt;,NoData,WorkspaceSymbolRegistrationOptions&gt;(&quot;workspace/symbol&quot;)" line="2816" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.WorkspaceSymbolParams"/>
				<x path="Null"><x path="haxe.extern.EitherType">
	<c path="Array"><t path="languageServerProtocol.SymbolInformation"/></c>
	<c path="Array"><t path="languageServerProtocol.WorkspaceSymbol"/></c>
</x></x>
				<x path="haxe.extern.EitherType">
					<c path="Array"><t path="languageServerProtocol.SymbolInformation"/></c>
					<c path="Array"><t path="languageServerProtocol.WorkspaceSymbol"/></c>
				</x>
				<e path="jsonrpc.NoData"/>
				<t path="languageServerProtocol.protocol.WorkspaceSymbolRegistrationOptions"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<WorkspaceSymbolParams,Null<EitherType<Array<SymbolInformation>,Array<WorkspaceSymbol>>>,EitherType<Array<SymbolInformation>,Array<WorkspaceSymbol>>,NoData,WorkspaceSymbolRegistrationOptions>("workspace/symbol")]]></e></m></meta>
		</type>
		<haxe_doc>A request to list project-wide symbols matching the query string given
	by the [WorkspaceSymbolParams](#WorkspaceSymbolParams). The response is
	of type [SymbolInformation[]](#SymbolInformation) or a Thenable that
	resolves to such.</haxe_doc>
	</class>
	<class path="languageServerProtocol.protocol.WorkspaceSymbolResolveRequest" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;WorkspaceSymbol,WorkspaceSymbol,Never,NoData,NoData&gt;(&quot;workspaceSymbol/resolve&quot;)" line="2828" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.WorkspaceSymbol"/>
				<t path="languageServerProtocol.WorkspaceSymbol"/>
				<e path="languageServerProtocol.protocol.Never"/>
				<e path="jsonrpc.NoData"/>
				<e path="jsonrpc.NoData"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<WorkspaceSymbol,WorkspaceSymbol,Never,NoData,NoData>("workspaceSymbol/resolve")]]></e></m></meta>
		</type>
		<haxe_doc>A request to resolve the range inside the workspace
	symbol's location.

	@since 3.17.0
	@proposed</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.CodeLensClientCapabilities" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a><dynamicRegistration>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>Whether code lens supports dynamic registration.</haxe_doc>
</dynamicRegistration></a>
		<haxe_doc>The client capabilities  of a [CodeLensRequest](#CodeLensRequest).</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.CodeLensWorkspaceClientCapabilities" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a><refreshSupport>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>Whether the client implementation supports a refresh request sent from the
		server to the client.

		Note that this event is global and will force the client to refresh all
		code lenses currently shown. It should be used with absolute care and is
		useful for situation where a server for example detect a project wide
		change that requires such a calculation.</haxe_doc>
</refreshSupport></a>
		<haxe_doc>@since 3.16.0</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.CodeLensParams" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<workDoneToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report work done progress.</haxe_doc>
			</workDoneToken>
			<textDocument>
				<t path="languageServerProtocol.TextDocumentIdentifier"/>
				<haxe_doc>The document to request code lens for.</haxe_doc>
			</textDocument>
			<partialResultToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report partial results (e.g. streaming) to
		the client.</haxe_doc>
			</partialResultToken>
		</a>
		<haxe_doc>The parameters of a [CodeLensRequest](#CodeLensRequest).</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.CodeLensOptions" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<workDoneProgress>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
			</workDoneProgress>
			<resolveProvider>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Code lens has a resolve provider as well.</haxe_doc>
			</resolveProvider>
		</a>
		<haxe_doc>Code Lens provider options of a [CodeLensRequest](#CodeLensRequest).</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.CodeLensRegistrationOptions" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<workDoneProgress>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
			</workDoneProgress>
			<resolveProvider>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Code lens has a resolve provider as well.</haxe_doc>
			</resolveProvider>
			<documentSelector>
				<x path="Null"><t path="languageServerProtocol.protocol.DocumentSelector"/></x>
				<haxe_doc>A document selector to identify the scope of the registration. If set to null
		the document selector provided on the client side will be used.</haxe_doc>
			</documentSelector>
		</a>
		<haxe_doc>Registration options for a [CodeLensRequest](#CodeLensRequest).</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.CodeLensRequest" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;CodeLensParams,Null&lt;Array&lt;CodeLens&gt;&gt;,Array&lt;CodeLens&gt;,NoData,CodeLensRegistrationOptions&gt;(&quot;textDocument/codeLens&quot;)" line="2889" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.CodeLensParams"/>
				<x path="Null"><c path="Array"><t path="languageServerProtocol.CodeLens"/></c></x>
				<c path="Array"><t path="languageServerProtocol.CodeLens"/></c>
				<e path="jsonrpc.NoData"/>
				<t path="languageServerProtocol.protocol.CodeLensRegistrationOptions"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<CodeLensParams,Null<Array<CodeLens>>,Array<CodeLens>,NoData,CodeLensRegistrationOptions>("textDocument/codeLens")]]></e></m></meta>
		</type>
		<haxe_doc>A request to provide code lens for the given text document.</haxe_doc>
	</class>
	<class path="languageServerProtocol.protocol.CodeLensResolveRequest" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;CodeLens,CodeLens,Never,NoData,NoData&gt;(&quot;codeLens/resolve&quot;)" line="2897" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.CodeLens"/>
				<t path="languageServerProtocol.CodeLens"/>
				<e path="languageServerProtocol.protocol.Never"/>
				<e path="jsonrpc.NoData"/>
				<e path="jsonrpc.NoData"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<CodeLens,CodeLens,Never,NoData,NoData>("codeLens/resolve")]]></e></m></meta>
		</type>
		<haxe_doc>A request to resolve a command for a given code lens.</haxe_doc>
	</class>
	<class path="languageServerProtocol.protocol.CodeLensRefreshRequest" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;NoData,NoData,NoData,NoData,NoData&gt;(&quot;workspace/codeLens/refresh&quot;)" line="2906" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<e path="jsonrpc.NoData"/>
				<e path="jsonrpc.NoData"/>
				<e path="jsonrpc.NoData"/>
				<e path="jsonrpc.NoData"/>
				<e path="jsonrpc.NoData"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<NoData,NoData,NoData,NoData,NoData>("workspace/codeLens/refresh")]]></e></m></meta>
		</type>
		<haxe_doc>A request to refresh all code actions

	@since 3.16.0</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.DocumentLinkClientCapabilities" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<tooltipSupport>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether the client support the `tooltip` property on `DocumentLink`.

		@since 3.15.0</haxe_doc>
			</tooltipSupport>
			<dynamicRegistration>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether document link supports dynamic registration.</haxe_doc>
			</dynamicRegistration>
		</a>
		<haxe_doc>The client capabilities of a [DocumentLinkRequest](#DocumentLinkRequest).</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.DocumentLinkParams" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<workDoneToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report work done progress.</haxe_doc>
			</workDoneToken>
			<textDocument>
				<t path="languageServerProtocol.TextDocumentIdentifier"/>
				<haxe_doc>The document to provide document links for.</haxe_doc>
			</textDocument>
			<partialResultToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report partial results (e.g. streaming) to
		the client.</haxe_doc>
			</partialResultToken>
		</a>
		<haxe_doc>The parameters of a [DocumentLinkRequest](#DocumentLinkRequest).</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.DocumentLinkOptions" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<workDoneProgress>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
			</workDoneProgress>
			<resolveProvider>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Document links have a resolve provider as well.</haxe_doc>
			</resolveProvider>
		</a>
		<haxe_doc>Provider options for a [DocumentLinkRequest](#DocumentLinkRequest).</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.DocumentLinkRegistrationOptions" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<workDoneProgress>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
			</workDoneProgress>
			<resolveProvider>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Document links have a resolve provider as well.</haxe_doc>
			</resolveProvider>
			<documentSelector>
				<x path="Null"><t path="languageServerProtocol.protocol.DocumentSelector"/></x>
				<haxe_doc>A document selector to identify the scope of the registration. If set to null
		the document selector provided on the client side will be used.</haxe_doc>
			</documentSelector>
		</a>
		<haxe_doc>Registration options for a [DocumentLinkRequest](#DocumentLinkRequest).</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.DocumentLinkRequest" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;DocumentLinkParams,Null&lt;Array&lt;DocumentLink&gt;&gt;,Array&lt;DocumentLink&gt;,NoData,DocumentLinkRegistrationOptions&gt;(&quot;textDocument/documentLink&quot;)" line="2958" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.DocumentLinkParams"/>
				<x path="Null"><c path="Array"><t path="languageServerProtocol.DocumentLink"/></c></x>
				<c path="Array"><t path="languageServerProtocol.DocumentLink"/></c>
				<e path="jsonrpc.NoData"/>
				<t path="languageServerProtocol.protocol.DocumentLinkRegistrationOptions"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<DocumentLinkParams,Null<Array<DocumentLink>>,Array<DocumentLink>,NoData,DocumentLinkRegistrationOptions>("textDocument/documentLink")]]></e></m></meta>
		</type>
		<haxe_doc>A request to provide document links</haxe_doc>
	</class>
	<class path="languageServerProtocol.protocol.DocumentLinkResolveRequest" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;DocumentLink,DocumentLink,Never,NoData,NoData&gt;(&quot;documentLink/resolve&quot;)" line="2968" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.DocumentLink"/>
				<t path="languageServerProtocol.DocumentLink"/>
				<e path="languageServerProtocol.protocol.Never"/>
				<e path="jsonrpc.NoData"/>
				<e path="jsonrpc.NoData"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<DocumentLink,DocumentLink,Never,NoData,NoData>("documentLink/resolve")]]></e></m></meta>
		</type>
		<haxe_doc>Request to resolve additional information for a given document link. The request's
	parameter is of type [DocumentLink](#DocumentLink) the response
	is of type [DocumentLink](#DocumentLink) or a Thenable that resolves to such.</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.DocumentFormattingClientCapabilities" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a><dynamicRegistration>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>Whether formatting supports dynamic registration.</haxe_doc>
</dynamicRegistration></a>
		<haxe_doc>Client capabilities of a [DocumentFormattingRequest](#DocumentFormattingRequest).</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.DocumentFormattingParams" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<textDocument>
				<t path="languageServerProtocol.TextDocumentIdentifier"/>
				<haxe_doc>The document to format.</haxe_doc>
			</textDocument>
			<options>
				<t path="languageServerProtocol.FormattingOptions"/>
				<haxe_doc>The format options.</haxe_doc>
			</options>
		</a>
		<haxe_doc>The parameters of a [DocumentFormattingRequest](#DocumentFormattingRequest).</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.DocumentFormattingOptions" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<t path="languageServerProtocol.protocol.WorkDoneProgressOptions"/>
		<haxe_doc>Provider options for a [DocumentFormattingRequest](#DocumentFormattingRequest).</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.DocumentFormattingRegistrationOptions" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<workDoneProgress>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
			</workDoneProgress>
			<documentSelector>
				<x path="Null"><t path="languageServerProtocol.protocol.DocumentSelector"/></x>
				<haxe_doc>A document selector to identify the scope of the registration. If set to null
		the document selector provided on the client side will be used.</haxe_doc>
			</documentSelector>
		</a>
		<haxe_doc>Registration options for a [DocumentFormattingRequest](#DocumentFormattingRequest).</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.DocumentFormattingRequest" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;DocumentFormattingParams,Null&lt;Array&lt;TextEdit&gt;&gt;,Never,NoData,DocumentFormattingRegistrationOptions&gt;(&quot;textDocument/formatting&quot;)" line="3012" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.DocumentFormattingParams"/>
				<x path="Null"><c path="Array"><t path="languageServerProtocol.textdocument.TextEdit"/></c></x>
				<e path="languageServerProtocol.protocol.Never"/>
				<e path="jsonrpc.NoData"/>
				<t path="languageServerProtocol.protocol.DocumentFormattingRegistrationOptions"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<DocumentFormattingParams,Null<Array<TextEdit>>,Never,NoData,DocumentFormattingRegistrationOptions>("textDocument/formatting")]]></e></m></meta>
		</type>
		<haxe_doc>A request to to format a whole document.</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.DocumentRangeFormattingClientCapabilities" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a><dynamicRegistration>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>Whether range formatting supports dynamic registration.</haxe_doc>
</dynamicRegistration></a>
		<haxe_doc>Client capabilities of a [DocumentRangeFormattingRequest](#DocumentRangeFormattingRequest).</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.DocumentRangeFormattingParams" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<workDoneToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report work done progress.</haxe_doc>
			</workDoneToken>
			<textDocument>
				<t path="languageServerProtocol.TextDocumentIdentifier"/>
				<haxe_doc>The document to format.</haxe_doc>
			</textDocument>
			<range>
				<t path="languageServerProtocol.textdocument.Range"/>
				<haxe_doc>The range to format.</haxe_doc>
			</range>
			<options>
				<t path="languageServerProtocol.FormattingOptions"/>
				<haxe_doc>The format options.</haxe_doc>
			</options>
		</a>
		<haxe_doc>The parameters of a [DocumentRangeFormattingRequest](#DocumentRangeFormattingRequest).</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.DocumentRangeFormattingOptions" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<t path="languageServerProtocol.protocol.WorkDoneProgressOptions"/>
		<haxe_doc>Provider options for a [DocumentRangeFormattingRequest](#DocumentRangeFormattingRequest).</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.DocumentRangeFormattingRegistrationOptions" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<workDoneProgress>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
			</workDoneProgress>
			<documentSelector>
				<x path="Null"><t path="languageServerProtocol.protocol.DocumentSelector"/></x>
				<haxe_doc>A document selector to identify the scope of the registration. If set to null
		the document selector provided on the client side will be used.</haxe_doc>
			</documentSelector>
		</a>
		<haxe_doc>Registration options for a [DocumentRangeFormattingRequest](#DocumentRangeFormattingRequest).</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.DocumentRangeFormattingRequest" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;DocumentRangeFormattingParams,Null&lt;Array&lt;TextEdit&gt;&gt;,Never,NoData,DocumentRangeFormattingRegistrationOptions&gt;(&quot;textDocument/rangeFormatting&quot;)" line="3060" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.DocumentRangeFormattingParams"/>
				<x path="Null"><c path="Array"><t path="languageServerProtocol.textdocument.TextEdit"/></c></x>
				<e path="languageServerProtocol.protocol.Never"/>
				<e path="jsonrpc.NoData"/>
				<t path="languageServerProtocol.protocol.DocumentRangeFormattingRegistrationOptions"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<DocumentRangeFormattingParams,Null<Array<TextEdit>>,Never,NoData,DocumentRangeFormattingRegistrationOptions>("textDocument/rangeFormatting")]]></e></m></meta>
		</type>
		<haxe_doc>A request to to format a range in a document.</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.DocumentOnTypeFormattingClientCapabilities" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a><dynamicRegistration>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>Whether on type formatting supports dynamic registration.</haxe_doc>
</dynamicRegistration></a>
		<haxe_doc>Client capabilities of a [DocumentOnTypeFormattingRequest](#DocumentOnTypeFormattingRequest).</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.DocumentOnTypeFormattingParams" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<textDocument>
				<t path="languageServerProtocol.TextDocumentIdentifier"/>
				<haxe_doc>The document to format.</haxe_doc>
			</textDocument>
			<position>
				<t path="languageServerProtocol.textdocument.Position"/>
				<haxe_doc>The position at which this request was send.</haxe_doc>
			</position>
			<options>
				<t path="languageServerProtocol.FormattingOptions"/>
				<haxe_doc>The format options.</haxe_doc>
			</options>
			<ch>
				<c path="String"/>
				<haxe_doc>The character that has been typed.</haxe_doc>
			</ch>
		</a>
		<haxe_doc>The parameters of a [DocumentOnTypeFormattingRequest](#DocumentOnTypeFormattingRequest).</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.DocumentOnTypeFormattingOptions" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<moreTriggerCharacter>
				<x path="Null"><c path="Array"><c path="String"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>More trigger characters.</haxe_doc>
			</moreTriggerCharacter>
			<firstTriggerCharacter>
				<c path="String"/>
				<haxe_doc>A character on which formatting should be triggered, like `}`.</haxe_doc>
			</firstTriggerCharacter>
		</a>
		<haxe_doc>Provider options for a [DocumentOnTypeFormattingRequest](#DocumentOnTypeFormattingRequest).</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.DocumentOnTypeFormattingRegistrationOptions" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<moreTriggerCharacter>
				<x path="Null"><c path="Array"><c path="String"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>More trigger characters.</haxe_doc>
			</moreTriggerCharacter>
			<firstTriggerCharacter>
				<c path="String"/>
				<haxe_doc>A character on which formatting should be triggered, like `}`.</haxe_doc>
			</firstTriggerCharacter>
			<documentSelector>
				<x path="Null"><t path="languageServerProtocol.protocol.DocumentSelector"/></x>
				<haxe_doc>A document selector to identify the scope of the registration. If set to null
		the document selector provided on the client side will be used.</haxe_doc>
			</documentSelector>
		</a>
		<haxe_doc>Registration options for a [DocumentOnTypeFormattingRequest](#DocumentOnTypeFormattingRequest).</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.DocumentOnTypeFormattingRequest" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;DocumentOnTypeFormattingParams,Null&lt;Array&lt;TextEdit&gt;&gt;,Never,NoData,DocumentOnTypeFormattingRegistrationOptions&gt;(&quot;textDocument/onTypeFormatting&quot;)" line="3123" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.DocumentOnTypeFormattingParams"/>
				<x path="Null"><c path="Array"><t path="languageServerProtocol.textdocument.TextEdit"/></c></x>
				<e path="languageServerProtocol.protocol.Never"/>
				<e path="jsonrpc.NoData"/>
				<t path="languageServerProtocol.protocol.DocumentOnTypeFormattingRegistrationOptions"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<DocumentOnTypeFormattingParams,Null<Array<TextEdit>>,Never,NoData,DocumentOnTypeFormattingRegistrationOptions>("textDocument/onTypeFormatting")]]></e></m></meta>
		</type>
		<haxe_doc>A request to format a document on type.</haxe_doc>
	</class>
	<abstract path="languageServerProtocol.protocol.PrepareSupportDefaultBehavior" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="languageServerProtocol.protocol._Protocol.PrepareSupportDefaultBehavior_Impl_" params="" file="src/languageServerProtocol/protocol/Protocol.hx" private="1" module="languageServerProtocol.protocol.Protocol" extern="1" final="1">
	<Identifier public="1" get="inline" set="null" expr="cast 1" line="3130" static="1">
		<x path="languageServerProtocol.protocol.PrepareSupportDefaultBehavior"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Identifier>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="languageServerProtocol.protocol._Protocol.PrepareSupportDefaultBehavior_Impl_" params="" file="src/languageServerProtocol/protocol/Protocol.hx" private="1" module="languageServerProtocol.protocol.Protocol" extern="1" final="1">
		<Identifier public="1" get="inline" set="null" expr="cast 1" line="3130" static="1">
			<x path="languageServerProtocol.protocol.PrepareSupportDefaultBehavior"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Identifier>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="languageServerProtocol.protocol.RenameClientCapabilities" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol"><a>
	<prepareSupportDefaultBehavior>
		<x path="Null"><x path="languageServerProtocol.protocol.PrepareSupportDefaultBehavior"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Client supports the default behavior result.

		The value indicates the default behavior used by the
		client.

		@since 3.16.0</haxe_doc>
	</prepareSupportDefaultBehavior>
	<prepareSupport>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Client supports testing for validity of rename operations
		before execution.

		@since version 3.12.0</haxe_doc>
	</prepareSupport>
	<honorsChangeAnnotations>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Whether th client honors the change annotations in
		text edits and resource operations returned via the
		rename request's workspace edit by for example presenting
		the workspace edit in the user interface and asking
		for confirmation.

		@since 3.16.0</haxe_doc>
	</honorsChangeAnnotations>
	<dynamicRegistration>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Whether rename supports dynamic registration.</haxe_doc>
	</dynamicRegistration>
</a></typedef>
	<typedef path="languageServerProtocol.protocol.RenameParams" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<workDoneToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report work done progress.</haxe_doc>
			</workDoneToken>
			<textDocument>
				<t path="languageServerProtocol.TextDocumentIdentifier"/>
				<haxe_doc>The document to format.</haxe_doc>
			</textDocument>
			<position>
				<t path="languageServerProtocol.textdocument.Position"/>
				<haxe_doc>The position at which this request was send.</haxe_doc>
			</position>
			<newName>
				<c path="String"/>
				<haxe_doc>The new name of the symbol.
		If the given name is not valid the request must return a `ResponseError` with an appropriate message set.</haxe_doc>
			</newName>
		</a>
		<haxe_doc>The parameters of a [RenameRequest](#RenameRequest).</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.RenameOptions" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<workDoneProgress>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
			</workDoneProgress>
			<prepareProvider>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Renames should be checked and tested before being executed.

		@since version 3.12.0</haxe_doc>
			</prepareProvider>
		</a>
		<haxe_doc>Provider options for a [RenameRequest](#RenameRequest).</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.RenameRegistrationOptions" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<workDoneProgress>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
			</workDoneProgress>
			<prepareProvider>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Renames should be checked and tested before being executed.

		@since version 3.12.0</haxe_doc>
			</prepareProvider>
			<documentSelector>
				<x path="Null"><t path="languageServerProtocol.protocol.DocumentSelector"/></x>
				<haxe_doc>A document selector to identify the scope of the registration. If set to null
		the document selector provided on the client side will be used.</haxe_doc>
			</documentSelector>
		</a>
		<haxe_doc>Registration options for a [RenameRequest](#RenameRequest).</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.RenameRequest" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;RenameParams,Null&lt;WorkspaceEdit&gt;,Never,NoData,RenameRegistrationOptions&gt;(&quot;textDocument/rename&quot;)" line="3211" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.RenameParams"/>
				<x path="Null"><t path="languageServerProtocol.WorkspaceEdit"/></x>
				<e path="languageServerProtocol.protocol.Never"/>
				<e path="jsonrpc.NoData"/>
				<t path="languageServerProtocol.protocol.RenameRegistrationOptions"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<RenameParams,Null<WorkspaceEdit>,Never,NoData,RenameRegistrationOptions>("textDocument/rename")]]></e></m></meta>
		</type>
		<haxe_doc>A request to rename a symbol.</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.PrepareRenameParams" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol"><a>
	<workDoneToken>
		<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>An optional token that a server can use to report work done progress.</haxe_doc>
	</workDoneToken>
	<textDocument>
		<t path="languageServerProtocol.TextDocumentIdentifier"/>
		<haxe_doc>The text document.</haxe_doc>
	</textDocument>
	<position>
		<t path="languageServerProtocol.textdocument.Position"/>
		<haxe_doc>The position inside the text document.</haxe_doc>
	</position>
</a></typedef>
	<typedef path="languageServerProtocol.protocol.PrepareRenameResult" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol"><x path="haxe.extern.EitherType">
	<t path="languageServerProtocol.textdocument.Range"/>
	<x path="haxe.extern.EitherType">
		<a>
			<range><t path="languageServerProtocol.textdocument.Range"/></range>
			<placeholder><c path="String"/></placeholder>
		</a>
		<a><defaultBehavior><x path="Bool"/></defaultBehavior></a>
	</x>
</x></typedef>
	<class path="languageServerProtocol.protocol.PrepareRenameRequest" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;PrepareRenameParams,Null&lt;PrepareRenameResult&gt;,Never,NoData,NoData&gt;(&quot;textDocument/prepareRename&quot;)" line="3222" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.PrepareRenameParams"/>
				<x path="Null"><t path="languageServerProtocol.protocol.PrepareRenameResult"/></x>
				<e path="languageServerProtocol.protocol.Never"/>
				<e path="jsonrpc.NoData"/>
				<e path="jsonrpc.NoData"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<PrepareRenameParams,Null<PrepareRenameResult>,Never,NoData,NoData>("textDocument/prepareRename")]]></e></m></meta>
		</type>
		<haxe_doc>A request to test and perform the setup necessary for a rename.</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.ExecuteCommandClientCapabilities" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a><dynamicRegistration>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>Execute command supports dynamic registration.</haxe_doc>
</dynamicRegistration></a>
		<haxe_doc>The client capabilities of a [ExecuteCommandRequest](#ExecuteCommandRequest).</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.ExecuteCommandParams" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<workDoneToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report work done progress.</haxe_doc>
			</workDoneToken>
			<command>
				<c path="String"/>
				<haxe_doc>The identifier of the actual command handler.</haxe_doc>
			</command>
			<arguments>
				<x path="Null"><c path="Array"><d/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Arguments that the command should be invoked with.</haxe_doc>
			</arguments>
		</a>
		<haxe_doc>The parameters of a [ExecuteCommandRequest](#ExecuteCommandRequest).</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.ExecuteCommandOptions" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<workDoneProgress>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
			</workDoneProgress>
			<commands>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The commands to be executed on the server</haxe_doc>
			</commands>
		</a>
		<haxe_doc>The server capabilities of a [ExecuteCommandRequest](#ExecuteCommandRequest).</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.ExecuteCommandRegistrationOptions" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<t path="languageServerProtocol.protocol.ExecuteCommandOptions"/>
		<haxe_doc>Registration options for a [ExecuteCommandRequest](#ExecuteCommandRequest).</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.ExecuteCommandRequest" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;ExecuteCommandParams,Null&lt;Dynamic&gt;,Never,NoData,ExecuteCommandRegistrationOptions&gt;(&quot;workspace/executeCommand&quot;)" line="3273" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.ExecuteCommandParams"/>
				<x path="Null"><d/></x>
				<e path="languageServerProtocol.protocol.Never"/>
				<e path="jsonrpc.NoData"/>
				<t path="languageServerProtocol.protocol.ExecuteCommandRegistrationOptions"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<ExecuteCommandParams,Null<Dynamic>,Never,NoData,ExecuteCommandRegistrationOptions>("workspace/executeCommand")]]></e></m></meta>
		</type>
		<haxe_doc>A request send from the client to the server to execute a command. The request might return
	a workspace edit which the client will apply to the workspace.</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.WorkspaceEditClientCapabilities" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol"><a>
	<resourceOperations>
		<x path="Null"><c path="Array"><x path="languageServerProtocol.protocol.ResourceOperationKind"/></c></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The resource operations the client supports. Clients should at least
		support 'create', 'rename' and 'delete' files and folders.

		@since 3.13.0</haxe_doc>
	</resourceOperations>
	<normalizesLineEndings>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Whether the client normalizes line endings to the client specific
		setting.
		If set to `true` the client will normalize line ending characters
		in a workspace edit containing to the client specific new line
		character.

		@since 3.16.0</haxe_doc>
	</normalizesLineEndings>
	<failureHandling>
		<x path="Null"><x path="languageServerProtocol.protocol.FailureHandlingKind"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The failure handling strategy of a client if applying the workspace edit
		failes.

		@since 3.13.0</haxe_doc>
	</failureHandling>
	<documentChanges>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The client supports versioned document changes in `WorkspaceEdit`s</haxe_doc>
	</documentChanges>
	<changeAnnotationSupport>
		<x path="Null"><a><groupsOnLabel>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>Whether the client groups edits with equal labels into tree nodes,
			for instance all edits labelled with "Changes in Strings" would
			be a tree node.</haxe_doc>
</groupsOnLabel></a></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Whether the client in general supports change annotations on text edits,
		create file, rename file and delete file changes.

		@since 3.16.0</haxe_doc>
	</changeAnnotationSupport>
</a></typedef>
	<typedef path="languageServerProtocol.protocol.ApplyWorkspaceEditParams" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<label>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional label of the workspace edit. This label is
		presented in the user interface for example on an undo
		stack to undo the workspace edit.</haxe_doc>
			</label>
			<edit>
				<t path="languageServerProtocol.WorkspaceEdit"/>
				<haxe_doc>The edits to apply.</haxe_doc>
			</edit>
		</a>
		<haxe_doc>The parameters passed via a apply workspace edit request.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.ApplyWorkspaceEditResult" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<a>
			<failureReason>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional textual description for why the edit was not applied.
		This may be used by the server for diagnostic logging or to provide
		a suitable error for a request that triggered the edit.</haxe_doc>
			</failureReason>
			<failedChange>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Depending on the client's failure handling strategy `failedChange` might
		contain the index of the change that failed. This property is only available
		if the client signals a `failureHandlingStrategy` in its client capabilities.</haxe_doc>
			</failedChange>
			<applied>
				<x path="Bool"/>
				<haxe_doc>Indicates whether the edit was applied or not.</haxe_doc>
			</applied>
		</a>
		<haxe_doc>The result returned from the apply workspace edit request.

	@since 3.17 renamed from ApplyWorkspaceEditResponse</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.ApplyWorkspaceEditResponse" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<t path="languageServerProtocol.protocol.ApplyWorkspaceEditResult"/>
		<haxe_doc>A response returned from the apply workspace edit request.</haxe_doc>
		<meta><m n=":deprecated"><e>"Use ApplyWorkspaceEditResult instead."</e></m></meta>
	</typedef>
	<class path="languageServerProtocol.protocol.ApplyWorkspaceEditRequest" params="" file="src/languageServerProtocol/protocol/Protocol.hx" module="languageServerProtocol.protocol.Protocol">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;ApplyWorkspaceEditParams,ApplyWorkspaceEditResult,Never,NoData,NoData&gt;(&quot;workspace/applyEdit&quot;)" line="3381" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.ApplyWorkspaceEditParams"/>
				<t path="languageServerProtocol.protocol.ApplyWorkspaceEditResult"/>
				<e path="languageServerProtocol.protocol.Never"/>
				<e path="jsonrpc.NoData"/>
				<e path="jsonrpc.NoData"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<ApplyWorkspaceEditParams,ApplyWorkspaceEditResult,Never,NoData,NoData>("workspace/applyEdit")]]></e></m></meta>
		</type>
		<haxe_doc>A request sent from the server to the client to modified certain resources.</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.SelectionRangeClientCapabilities" params="" file="src/languageServerProtocol/protocol/SelectionRange.hx" module="languageServerProtocol.protocol.SelectionRange"><a><dynamicRegistration>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>Whether implementation supports dynamic registration for selection range providers. If this is set to `true`
		the client supports the new `SelectionRangeRegistrationOptions` return value for the corresponding server
		capability as well.</haxe_doc>
</dynamicRegistration></a></typedef>
	<typedef path="languageServerProtocol.protocol.SelectionRangeOptions" params="" file="src/languageServerProtocol/protocol/SelectionRange.hx" module="languageServerProtocol.protocol.SelectionRange"><a><workDoneProgress>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
</workDoneProgress></a></typedef>
	<typedef path="languageServerProtocol.protocol.SelectionRangeRegistrationOptions" params="" file="src/languageServerProtocol/protocol/SelectionRange.hx" module="languageServerProtocol.protocol.SelectionRange"><a>
	<workDoneProgress>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</workDoneProgress>
	<id>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The id used to register the request. The id can be used to deregister
		the request again. See also Registration#id.</haxe_doc>
	</id>
	<documentSelector>
		<x path="Null"><t path="languageServerProtocol.protocol.DocumentSelector"/></x>
		<haxe_doc>A document selector to identify the scope of the registration. If set to null
		the document selector provided on the client side will be used.</haxe_doc>
	</documentSelector>
</a></typedef>
	<typedef path="languageServerProtocol.protocol.SelectionRangeParams" params="" file="src/languageServerProtocol/protocol/SelectionRange.hx" module="languageServerProtocol.protocol.SelectionRange">
		<a>
			<workDoneToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report work done progress.</haxe_doc>
			</workDoneToken>
			<textDocument>
				<t path="languageServerProtocol.TextDocumentIdentifier"/>
				<haxe_doc>The text document.</haxe_doc>
			</textDocument>
			<positions>
				<c path="Array"><t path="languageServerProtocol.textdocument.Position"/></c>
				<haxe_doc>The positions inside the text document.</haxe_doc>
			</positions>
			<partialResultToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report partial results (e.g. streaming) to
		the client.</haxe_doc>
			</partialResultToken>
		</a>
		<haxe_doc>A parameter literal used in selection range requests.</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.SelectionRangeRequest" params="" file="src/languageServerProtocol/protocol/SelectionRange.hx" module="languageServerProtocol.protocol.SelectionRange">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;SelectionRangeParams,Null&lt;Array&lt;SelectionRange&gt;&gt;,Array&lt;SelectionRange&gt;,NoData,SelectionRangeRegistrationOptions&gt;(&quot;textDocument/selectionRange&quot;)" line="43" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.SelectionRangeParams"/>
				<x path="Null"><c path="Array"><t path="languageServerProtocol.SelectionRange"/></c></x>
				<c path="Array"><t path="languageServerProtocol.SelectionRange"/></c>
				<e path="jsonrpc.NoData"/>
				<t path="languageServerProtocol.protocol.SelectionRangeRegistrationOptions"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<SelectionRangeParams,Null<Array<SelectionRange>>,Array<SelectionRange>,NoData,SelectionRangeRegistrationOptions>("textDocument/selectionRange")]]></e></m></meta>
		</type>
		<haxe_doc>A request to provide selection ranges in a document. The request's
	parameter is of type [SelectionRangeParams](#SelectionRangeParams), the
	response is of type [SelectionRange[]](#SelectionRange[]) or a Thenable
	that resolves to such.</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.SemanticTokensPartialResult" params="" file="src/languageServerProtocol/protocol/SemanticTokens.hx" module="languageServerProtocol.protocol.SemanticTokens">
		<a><data><c path="Array"><x path="Int"/></c></data></a>
		<haxe_doc>@since 3.16.0</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.SemanticTokensDeltaPartialResult" params="" file="src/languageServerProtocol/protocol/SemanticTokens.hx" module="languageServerProtocol.protocol.SemanticTokens">
		<a><edits><c path="Array"><t path="languageServerProtocol.SemanticTokensEdit"/></c></edits></a>
		<haxe_doc>@since 3.16.0</haxe_doc>
	</typedef>
	<abstract path="languageServerProtocol.protocol.TokenFormat" params="" file="src/languageServerProtocol/protocol/SemanticTokens.hx" module="languageServerProtocol.protocol.SemanticTokens">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="languageServerProtocol.protocol._SemanticTokens.TokenFormat_Impl_" params="" file="src/languageServerProtocol/protocol/SemanticTokens.hx" private="1" module="languageServerProtocol.protocol.SemanticTokens" extern="1" final="1">
	<Relative public="1" get="inline" set="null" expr="cast &quot;relative&quot;" line="26" static="1">
		<x path="languageServerProtocol.protocol.TokenFormat"/>
		<meta>
			<m n=":value"><e>cast "relative"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Supports creating new files and folders.</haxe_doc>
	</Relative>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="languageServerProtocol.protocol._SemanticTokens.TokenFormat_Impl_" params="" file="src/languageServerProtocol/protocol/SemanticTokens.hx" private="1" module="languageServerProtocol.protocol.SemanticTokens" extern="1" final="1">
		<Relative public="1" get="inline" set="null" expr="cast &quot;relative&quot;" line="26" static="1">
			<x path="languageServerProtocol.protocol.TokenFormat"/>
			<meta>
				<m n=":value"><e>cast "relative"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Supports creating new files and folders.</haxe_doc>
		</Relative>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="languageServerProtocol.protocol.SemanticTokensClientCapabilities" params="" file="src/languageServerProtocol/protocol/SemanticTokens.hx" module="languageServerProtocol.protocol.SemanticTokens">
		<a>
			<tokenTypes>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The token types that the client supports.</haxe_doc>
			</tokenTypes>
			<tokenModifiers>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The token modifiers that the client supports.</haxe_doc>
			</tokenModifiers>
			<serverCancelSupport>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether the client allows the server to actively cancel a
		semantic token request, e.g. supports returning
		LSPErrorCodes.ServerCancelled. If a server does the client
		needs to retrigger the request.

		@since 3.17.0</haxe_doc>
			</serverCancelSupport>
			<requests>
				<a>
					<range>
						<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<a/>
</x></x>
						<meta><m n=":optional"/></meta>
						<haxe_doc>The client will send the `textDocument/semanticTokens/range` request if
			the server provides a corresponding handler.</haxe_doc>
					</range>
					<full>
						<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<a><delta>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>The client will send the `textDocument/semanticTokens/full/delta` request if
				the server provides a corresponding handler.</haxe_doc>
</delta></a>
</x></x>
						<meta><m n=":optional"/></meta>
						<haxe_doc>The client will send the `textDocument/semanticTokens/full` request if
			the server provides a corresponding handler.</haxe_doc>
					</full>
				</a>
				<haxe_doc>Which requests the client supports and might send to the server
		depending on the server's capability. Please note that clients might not
		show semantic tokens or degrade some of the user experience if a range
		or full request is advertised by the client but not provided by the
		server. If for example the client capability `requests.full` and
		`request.range` are both set to true but the server only provides a
		range provider the client might not render a minimap correctly or might
		even decide to not show any semantic tokens at all.</haxe_doc>
			</requests>
			<overlappingTokenSupport>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether the client supports tokens that can overlap each other.</haxe_doc>
			</overlappingTokenSupport>
			<multilineTokenSupport>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether the client supports tokens that can span multiple lines.</haxe_doc>
			</multilineTokenSupport>
			<formats>
				<c path="Array"><x path="languageServerProtocol.protocol.TokenFormat"/></c>
				<haxe_doc>The token formats the clients supports.</haxe_doc>
			</formats>
			<dynamicRegistration>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc><![CDATA[Whether implementation supports dynamic registration. If this is set to `true`
		the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
		return value for the corresponding server capability as well.]]></haxe_doc>
			</dynamicRegistration>
			<augmentsSyntaxTokens>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether the client uses semantic tokens to augment existing
		syntax tokens. If set to `true` client side created syntax
		tokens and semantic tokens are both used for colorization. If
		set to `false` the client only uses the returned semantic tokens
		for colorization.

		If the value is `undefined` then the client behavior is not
		specified.

		@since 3.17.0</haxe_doc>
			</augmentsSyntaxTokens>
		</a>
		<haxe_doc>@since 3.16.0</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.SemanticTokensOptions" params="" file="src/languageServerProtocol/protocol/SemanticTokens.hx" module="languageServerProtocol.protocol.SemanticTokens">
		<a>
			<workDoneProgress>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
			</workDoneProgress>
			<range>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<a/>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Server supports providing semantic tokens for a specific range
		of a document.</haxe_doc>
			</range>
			<legend>
				<t path="languageServerProtocol.SemanticTokensLegend"/>
				<haxe_doc>The legend used by the server</haxe_doc>
			</legend>
			<full>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<a><delta>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>The server supports deltas for full documents.</haxe_doc>
</delta></a>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Server supports providing semantic tokens for a full document.</haxe_doc>
			</full>
		</a>
		<haxe_doc>@since 3.16.0</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.SemanticTokensRegistrationOptions" params="" file="src/languageServerProtocol/protocol/SemanticTokens.hx" module="languageServerProtocol.protocol.SemanticTokens">
		<a>
			<workDoneProgress>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
			</workDoneProgress>
			<range>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<a/>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Server supports providing semantic tokens for a specific range
		of a document.</haxe_doc>
			</range>
			<legend>
				<t path="languageServerProtocol.SemanticTokensLegend"/>
				<haxe_doc>The legend used by the server</haxe_doc>
			</legend>
			<id>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The id used to register the request. The id can be used to deregister
		the request again. See also Registration#id.</haxe_doc>
			</id>
			<full>
				<x path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<a><delta>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>The server supports deltas for full documents.</haxe_doc>
</delta></a>
</x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Server supports providing semantic tokens for a full document.</haxe_doc>
			</full>
			<documentSelector>
				<x path="Null"><t path="languageServerProtocol.protocol.DocumentSelector"/></x>
				<haxe_doc>A document selector to identify the scope of the registration. If set to null
		the document selector provided on the client side will be used.</haxe_doc>
			</documentSelector>
		</a>
		<haxe_doc>@since 3.16.0</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.SemanticTokensRegistrationType" params="" file="src/languageServerProtocol/protocol/SemanticTokens.hx" module="languageServerProtocol.protocol.SemanticTokens"><type final="1" public="1" get="inline" set="null" expr="new RegistrationType&lt;SemanticTokensRegistrationOptions&gt;(&quot;textDocument/semanticTokens&quot;)" line="152" static="1">
	<x path="languageServerProtocol.protocol.RegistrationType"><t path="languageServerProtocol.protocol.SemanticTokensRegistrationOptions"/></x>
	<meta><m n=":value"><e><![CDATA[new RegistrationType<SemanticTokensRegistrationOptions>("textDocument/semanticTokens")]]></e></m></meta>
</type></class>
	<typedef path="languageServerProtocol.protocol.SemanticTokensParams" params="" file="src/languageServerProtocol/protocol/SemanticTokens.hx" module="languageServerProtocol.protocol.SemanticTokens">
		<a>
			<workDoneToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report work done progress.</haxe_doc>
			</workDoneToken>
			<textDocument>
				<t path="languageServerProtocol.TextDocumentIdentifier"/>
				<haxe_doc>The text document.</haxe_doc>
			</textDocument>
			<partialResultToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report partial results (e.g. streaming) to
		the client.</haxe_doc>
			</partialResultToken>
		</a>
		<haxe_doc>@since 3.16.0</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.SemanticTokensRequest" params="" file="src/languageServerProtocol/protocol/SemanticTokens.hx" module="languageServerProtocol.protocol.SemanticTokens">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;SemanticTokensParams,Null&lt;SemanticTokens&gt;,SemanticTokensPartialResult,NoData,SemanticTokensRegistrationOptions&gt;(&quot;textDocument/semanticTokens/full&quot;)" line="172" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.SemanticTokensParams"/>
				<x path="Null"><t path="languageServerProtocol.SemanticTokens"/></x>
				<t path="languageServerProtocol.protocol.SemanticTokensPartialResult"/>
				<e path="jsonrpc.NoData"/>
				<t path="languageServerProtocol.protocol.SemanticTokensRegistrationOptions"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<SemanticTokensParams,Null<SemanticTokens>,SemanticTokensPartialResult,NoData,SemanticTokensRegistrationOptions>("textDocument/semanticTokens/full")]]></e></m></meta>
		</type>
		<haxe_doc>@since 3.16.0</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.SemanticTokensDeltaParams" params="" file="src/languageServerProtocol/protocol/SemanticTokens.hx" module="languageServerProtocol.protocol.SemanticTokens">
		<a>
			<workDoneToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report work done progress.</haxe_doc>
			</workDoneToken>
			<textDocument>
				<t path="languageServerProtocol.TextDocumentIdentifier"/>
				<haxe_doc>The text document.</haxe_doc>
			</textDocument>
			<previousResultId>
				<c path="String"/>
				<haxe_doc>The result id of a previous response. The result Id can either point to a full response
		or a delta response depending on what was received last.</haxe_doc>
			</previousResultId>
			<partialResultToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report partial results (e.g. streaming) to
		the client.</haxe_doc>
			</partialResultToken>
		</a>
		<haxe_doc>@since 3.16.0</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.SemanticTokensDeltaRequest" params="" file="src/languageServerProtocol/protocol/SemanticTokens.hx" module="languageServerProtocol.protocol.SemanticTokens">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;SemanticTokensDeltaParams,Null&lt;EitherType&lt;SemanticTokens,SemanticTokensDelta&gt;&gt;,EitherType&lt;SemanticTokensPartialResult,SemanticTokensDeltaPartialResult&gt;,NoData,SemanticTokensRegistrationOptions&gt;(&quot;textDocument/semanticTokens/full/delta&quot;)" line="199" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.SemanticTokensDeltaParams"/>
				<x path="Null"><x path="haxe.extern.EitherType">
	<t path="languageServerProtocol.SemanticTokens"/>
	<t path="languageServerProtocol.SemanticTokensDelta"/>
</x></x>
				<x path="haxe.extern.EitherType">
					<t path="languageServerProtocol.protocol.SemanticTokensPartialResult"/>
					<t path="languageServerProtocol.protocol.SemanticTokensDeltaPartialResult"/>
				</x>
				<e path="jsonrpc.NoData"/>
				<t path="languageServerProtocol.protocol.SemanticTokensRegistrationOptions"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<SemanticTokensDeltaParams,Null<EitherType<SemanticTokens,SemanticTokensDelta>>,EitherType<SemanticTokensPartialResult,SemanticTokensDeltaPartialResult>,NoData,SemanticTokensRegistrationOptions>("textDocument/semanticTokens/full/delta")]]></e></m></meta>
		</type>
		<haxe_doc>@since 3.16.0</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.SemanticTokensRangeParams" params="" file="src/languageServerProtocol/protocol/SemanticTokens.hx" module="languageServerProtocol.protocol.SemanticTokens">
		<a>
			<workDoneToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report work done progress.</haxe_doc>
			</workDoneToken>
			<textDocument>
				<t path="languageServerProtocol.TextDocumentIdentifier"/>
				<haxe_doc>The text document.</haxe_doc>
			</textDocument>
			<range>
				<t path="languageServerProtocol.textdocument.Range"/>
				<haxe_doc>The range the semantic tokens are requested for.</haxe_doc>
			</range>
			<partialResultToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report partial results (e.g. streaming) to
		the client.</haxe_doc>
			</partialResultToken>
		</a>
		<haxe_doc>@since 3.16.0</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.SemanticTokensRangeRequest" params="" file="src/languageServerProtocol/protocol/SemanticTokens.hx" module="languageServerProtocol.protocol.SemanticTokens">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;SemanticTokensRangeParams,Null&lt;SemanticTokens&gt;,SemanticTokensPartialResult,NoData,NoData&gt;(&quot;textDocument/semanticTokens/range&quot;)" line="226" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.SemanticTokensRangeParams"/>
				<x path="Null"><t path="languageServerProtocol.SemanticTokens"/></x>
				<t path="languageServerProtocol.protocol.SemanticTokensPartialResult"/>
				<e path="jsonrpc.NoData"/>
				<e path="jsonrpc.NoData"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<SemanticTokensRangeParams,Null<SemanticTokens>,SemanticTokensPartialResult,NoData,NoData>("textDocument/semanticTokens/range")]]></e></m></meta>
		</type>
		<haxe_doc>@since 3.16.0</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.SemanticTokensWorkspaceClientCapabilities" params="" file="src/languageServerProtocol/protocol/SemanticTokens.hx" module="languageServerProtocol.protocol.SemanticTokens">
		<a><refreshSupport>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>Whether the client implementation supports a refresh request sent from
		the server to the client.

		Note that this event is global and will force the client to refresh all
		semantic tokens currently shown. It should be used with absolute care
		and is useful for situation where a server for example detects a project
		wide change that requires such a calculation.</haxe_doc>
</refreshSupport></a>
		<haxe_doc>@since 3.16.0</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.SemanticTokensRefreshRequest" params="" file="src/languageServerProtocol/protocol/SemanticTokens.hx" module="languageServerProtocol.protocol.SemanticTokens">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;NoData,NoData,NoData,NoData,NoData&gt;(&quot;workspace/semanticTokens/refresh&quot;)" line="252" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<e path="jsonrpc.NoData"/>
				<e path="jsonrpc.NoData"/>
				<e path="jsonrpc.NoData"/>
				<e path="jsonrpc.NoData"/>
				<e path="jsonrpc.NoData"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<NoData,NoData,NoData,NoData,NoData>("workspace/semanticTokens/refresh")]]></e></m></meta>
		</type>
		<haxe_doc>@since 3.16.0</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.ShowDocumentClientCapabilities" params="" file="src/languageServerProtocol/protocol/ShowDocument.hx" module="languageServerProtocol.protocol.ShowDocument">
		<a><support>
	<x path="Bool"/>
	<haxe_doc>The client has support for the show document
		request.</haxe_doc>
</support></a>
		<haxe_doc>Client capabilities for the show document request.

	@since 3.16.0</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.ShowDocumentParams" params="" file="src/languageServerProtocol/protocol/ShowDocument.hx" module="languageServerProtocol.protocol.ShowDocument">
		<a>
			<uri>
				<x path="languageServerProtocol.URI"/>
				<haxe_doc>The document uri to show.</haxe_doc>
			</uri>
			<takeFocus>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional property to indicate whether the editor
		showing the document should take focus or not.
		Clients might ignore this property if an external
		program in started.</haxe_doc>
			</takeFocus>
			<selection>
				<x path="Null"><t path="languageServerProtocol.textdocument.Range"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional selection range if the document is a text
		document. Clients might ignore the property if an
		external program is started or the file is not a text
		file.</haxe_doc>
			</selection>
			<external>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Indicates to show the resource in an external program.
		To show for example `https://code.visualstudio.com/`
		in the default WEB browser set `external` to `true`.</haxe_doc>
			</external>
		</a>
		<haxe_doc>Params to show a document.

	@since 3.16.0</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.ShowDocumentResult" params="" file="src/languageServerProtocol/protocol/ShowDocument.hx" module="languageServerProtocol.protocol.ShowDocument">
		<a><success>
	<x path="Bool"/>
	<haxe_doc>A boolean indicating if the show was successful.</haxe_doc>
</success></a>
		<haxe_doc>The result of an show document request.

	@since 3.16.0</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.ShowDocumentRequest" params="" file="src/languageServerProtocol/protocol/ShowDocument.hx" module="languageServerProtocol.protocol.ShowDocument">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;ShowDocumentParams,ShowDocumentResult,NoData,NoData,NoData&gt;(&quot;window/showDocument&quot;)" line="74" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.ShowDocumentParams"/>
				<t path="languageServerProtocol.protocol.ShowDocumentResult"/>
				<e path="jsonrpc.NoData"/>
				<e path="jsonrpc.NoData"/>
				<e path="jsonrpc.NoData"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<ShowDocumentParams,ShowDocumentResult,NoData,NoData,NoData>("window/showDocument")]]></e></m></meta>
		</type>
		<haxe_doc>A request to show a document. This request might open an
	external program depending on the value of the URI to open.
	For example a request to open `https://code.visualstudio.com/`
	will very likely open the URI in a WEB browser.

	@since 3.16.0</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.TypeDefinitionClientCapabilities" params="" file="src/languageServerProtocol/protocol/TypeDefinition.hx" module="languageServerProtocol.protocol.TypeDefinition">
		<a>
			<linkSupport>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The client supports additional metadata in the form of definition links.

		Since 3.14.0</haxe_doc>
			</linkSupport>
			<dynamicRegistration>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether implementation supports dynamic registration. If this is set to `true`
		the client supports the new `TypeDefinitionRegistrationOptions` return value
		for the corresponding server capability as well.</haxe_doc>
			</dynamicRegistration>
		</a>
		<haxe_doc>Since 3.6.0</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.TypeDefinitionOptions" params="" file="src/languageServerProtocol/protocol/TypeDefinition.hx" module="languageServerProtocol.protocol.TypeDefinition"><a><workDoneProgress>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
</workDoneProgress></a></typedef>
	<typedef path="languageServerProtocol.protocol.TypeDefinitionRegistrationOptions" params="" file="src/languageServerProtocol/protocol/TypeDefinition.hx" module="languageServerProtocol.protocol.TypeDefinition"><a>
	<workDoneProgress>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</workDoneProgress>
	<id>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The id used to register the request. The id can be used to deregister
		the request again. See also Registration#id.</haxe_doc>
	</id>
	<documentSelector>
		<x path="Null"><t path="languageServerProtocol.protocol.DocumentSelector"/></x>
		<haxe_doc>A document selector to identify the scope of the registration. If set to null
		the document selector provided on the client side will be used.</haxe_doc>
	</documentSelector>
</a></typedef>
	<typedef path="languageServerProtocol.protocol.TypeDefinitionParams" params="" file="src/languageServerProtocol/protocol/TypeDefinition.hx" module="languageServerProtocol.protocol.TypeDefinition"><a>
	<workDoneToken>
		<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>An optional token that a server can use to report work done progress.</haxe_doc>
	</workDoneToken>
	<textDocument>
		<t path="languageServerProtocol.TextDocumentIdentifier"/>
		<haxe_doc>The text document.</haxe_doc>
	</textDocument>
	<position>
		<t path="languageServerProtocol.textdocument.Position"/>
		<haxe_doc>The position inside the text document.</haxe_doc>
	</position>
	<partialResultToken>
		<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>An optional token that a server can use to report partial results (e.g. streaming) to
		the client.</haxe_doc>
	</partialResultToken>
</a></typedef>
	<class path="languageServerProtocol.protocol.TypeDefinitionRequest" params="" file="src/languageServerProtocol/protocol/TypeDefinition.hx" module="languageServerProtocol.protocol.TypeDefinition">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;TypeDefinitionParams,Null&lt;EitherType&lt;Definition,Array&lt;DefinitionLink&gt;&gt;&gt;,EitherType&lt;Array&lt;Location&gt;,Array&lt;DefinitionLink&gt;&gt;,NoData,TypeDefinitionRegistrationOptions&gt;(&quot;textDocument/typeDefinition&quot;)" line="36" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.TypeDefinitionParams"/>
				<x path="Null"><x path="haxe.extern.EitherType">
	<t path="languageServerProtocol.Definition"/>
	<c path="Array"><t path="languageServerProtocol.DefinitionLink"/></c>
</x></x>
				<x path="haxe.extern.EitherType">
					<c path="Array"><t path="languageServerProtocol.Location"/></c>
					<c path="Array"><t path="languageServerProtocol.DefinitionLink"/></c>
				</x>
				<e path="jsonrpc.NoData"/>
				<t path="languageServerProtocol.protocol.TypeDefinitionRegistrationOptions"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<TypeDefinitionParams,Null<EitherType<Definition,Array<DefinitionLink>>>,EitherType<Array<Location>,Array<DefinitionLink>>,NoData,TypeDefinitionRegistrationOptions>("textDocument/typeDefinition")]]></e></m></meta>
		</type>
		<haxe_doc>A request to resolve the type definition locations of a symbol at a given text
	document position. The request's parameter is of type [TextDocumentPositioParams]
	(#TextDocumentPositionParams) the response is of type [Definition](#Definition) or a
	Thenable that resolves to such.</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.WorkspaceFoldersInitializeParams" params="" file="src/languageServerProtocol/protocol/WorkspaceFolders.hx" module="languageServerProtocol.protocol.WorkspaceFolders"><a><workspaceFolders>
	<x path="Null"><c path="Array"><t path="languageServerProtocol.WorkspaceFolder"/></c></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>The actual configured workspace folders.</haxe_doc>
</workspaceFolders></a></typedef>
	<typedef path="languageServerProtocol.protocol.WorkspaceFoldersServerCapabilities" params="" file="src/languageServerProtocol/protocol/WorkspaceFolders.hx" module="languageServerProtocol.protocol.WorkspaceFolders"><a>
	<supported>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The Server has support for workspace folders</haxe_doc>
	</supported>
	<changeNotifications>
		<x path="Null"><x path="haxe.extern.EitherType">
	<c path="String"/>
	<x path="Bool"/>
</x></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Whether the server wants to receive workspace folder
		change notifications.

		If a strings is provided the string is treated as a ID
		under which the notification is registed on the client
		side. The ID can be used to unregister for these events
		using the `client/unregisterCapability` request.</haxe_doc>
	</changeNotifications>
</a></typedef>
	<class path="languageServerProtocol.protocol.WorkspaceFoldersRequest" params="" file="src/languageServerProtocol/protocol/WorkspaceFolders.hx" module="languageServerProtocol.protocol.WorkspaceFolders">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;NoData,Null&lt;Array&lt;WorkspaceFolder&gt;&gt;,Never,NoData,NoData&gt;(&quot;workspace/workspaceFolders&quot;)" line="35" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<e path="jsonrpc.NoData"/>
				<x path="Null"><c path="Array"><t path="languageServerProtocol.WorkspaceFolder"/></c></x>
				<e path="languageServerProtocol.protocol.Never"/>
				<e path="jsonrpc.NoData"/>
				<e path="jsonrpc.NoData"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<NoData,Null<Array<WorkspaceFolder>>,Never,NoData,NoData>("workspace/workspaceFolders")]]></e></m></meta>
		</type>
		<haxe_doc>The `workspace/workspaceFolders` is sent from the server to the client to fetch the open workspace folders.</haxe_doc>
	</class>
	<class path="languageServerProtocol.protocol.DidChangeWorkspaceFoldersNotification" params="" file="src/languageServerProtocol/protocol/WorkspaceFolders.hx" module="languageServerProtocol.protocol.WorkspaceFolders">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolNotificationType&lt;DidChangeWorkspaceFoldersParams,NoData&gt;(&quot;workspace/didChangeWorkspaceFolders&quot;)" line="43" static="1">
			<x path="languageServerProtocol.protocol.ProtocolNotificationType">
				<t path="languageServerProtocol.protocol.DidChangeWorkspaceFoldersParams"/>
				<e path="jsonrpc.NoData"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolNotificationType<DidChangeWorkspaceFoldersParams,NoData>("workspace/didChangeWorkspaceFolders")]]></e></m></meta>
		</type>
		<haxe_doc>The `workspace/didChangeWorkspaceFolders` notification is sent from the client to the server when the workspace
	folder configuration changes.</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.DidChangeWorkspaceFoldersParams" params="" file="src/languageServerProtocol/protocol/WorkspaceFolders.hx" module="languageServerProtocol.protocol.WorkspaceFolders">
		<a><event>
	<t path="languageServerProtocol.protocol.WorkspaceFoldersChangeEvent"/>
	<haxe_doc>The actual workspace folder change event.</haxe_doc>
</event></a>
		<haxe_doc>The parameters of a `workspace/didChangeWorkspaceFolders` notification.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.WorkspaceFoldersChangeEvent" params="" file="src/languageServerProtocol/protocol/WorkspaceFolders.hx" module="languageServerProtocol.protocol.WorkspaceFolders">
		<a>
			<removed>
				<c path="Array"><t path="languageServerProtocol.WorkspaceFolder"/></c>
				<haxe_doc>The array of the removed workspace folders</haxe_doc>
			</removed>
			<added>
				<c path="Array"><t path="languageServerProtocol.WorkspaceFolder"/></c>
				<haxe_doc>The array of added workspace folders</haxe_doc>
			</added>
		</a>
		<haxe_doc>The workspace folder change event.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.proposed.DiagnosticClientCapabilities" params="" file="src/languageServerProtocol/protocol/proposed/Diagnostics.hx" module="languageServerProtocol.protocol.proposed.Diagnostics">
		<a>
			<relatedDocumentSupport>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether the clients supports related documents for document diagnostic pulls.</haxe_doc>
			</relatedDocumentSupport>
			<dynamicRegistration>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc><![CDATA[Whether implementation supports dynamic registration. If this is set to `true`
		the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
		return value for the corresponding server capability as well.]]></haxe_doc>
			</dynamicRegistration>
		</a>
		<haxe_doc>Client capabilities specific to diagnostic pull requests.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.proposed.DiagnosticWorkspaceClientCapabilities" params="" file="src/languageServerProtocol/protocol/proposed/Diagnostics.hx" module="languageServerProtocol.protocol.proposed.Diagnostics">
		<a><refreshSupport>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>Whether the client implementation supports a refresh request sent from
		the server to the client.

		Note that this event is global and will force the client to refresh all
		pulled diagnostics currently shown. It should be used with absolute care and
		is useful for situation where a server for example detects a project wide
		change that requires such a calculation.</haxe_doc>
</refreshSupport></a>
		<haxe_doc>Workspace client capabilities specific to diagnostic pull requests.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.proposed.DiagnosticOptions" params="" file="src/languageServerProtocol/protocol/proposed/Diagnostics.hx" module="languageServerProtocol.protocol.proposed.Diagnostics">
		<a>
			<workspaceDiagnostics>
				<x path="Bool"/>
				<haxe_doc>The server provides support for workspace diagnostics as well.</haxe_doc>
			</workspaceDiagnostics>
			<workDoneProgress>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
			</workDoneProgress>
			<interFileDependencies>
				<x path="Bool"/>
				<haxe_doc>Whether the language has inter file dependencies meaning that
		editing code in one file can result in a different diagnostic
		set in another file. Inter file dependencies are common for
		most programming languages and typically uncommon for linters.</haxe_doc>
			</interFileDependencies>
			<identifier>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional identifier under which the diagnostics are
		managed by the client.</haxe_doc>
			</identifier>
		</a>
		<haxe_doc>Diagnostic options.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.proposed.DiagnosticRegistrationOptions" params="" file="src/languageServerProtocol/protocol/proposed/Diagnostics.hx" module="languageServerProtocol.protocol.proposed.Diagnostics">
		<a>
			<workspaceDiagnostics>
				<x path="Bool"/>
				<haxe_doc>The server provides support for workspace diagnostics as well.</haxe_doc>
			</workspaceDiagnostics>
			<workDoneProgress>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
			</workDoneProgress>
			<interFileDependencies>
				<x path="Bool"/>
				<haxe_doc>Whether the language has inter file dependencies meaning that
		editing code in one file can result in a different diagnostic
		set in another file. Inter file dependencies are common for
		most programming languages and typically uncommon for linters.</haxe_doc>
			</interFileDependencies>
			<identifier>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional identifier under which the diagnostics are
		managed by the client.</haxe_doc>
			</identifier>
			<id>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The id used to register the request. The id can be used to deregister
		the request again. See also Registration#id.</haxe_doc>
			</id>
			<documentSelector>
				<x path="Null"><t path="languageServerProtocol.protocol.DocumentSelector"/></x>
				<haxe_doc>A document selector to identify the scope of the registration. If set to null
		the document selector provided on the client side will be used.</haxe_doc>
			</documentSelector>
		</a>
		<haxe_doc>Diagnostic registration options.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.proposed.DiagnosticServerCapabilities" params="" file="src/languageServerProtocol/protocol/proposed/Diagnostics.hx" module="languageServerProtocol.protocol.proposed.Diagnostics"><a><diagnosticProvider>
	<x path="Null"><t path="languageServerProtocol.protocol.proposed.DiagnosticOptions"/></x>
	<meta><m n=":optional"/></meta>
</diagnosticProvider></a></typedef>
	<typedef path="languageServerProtocol.protocol.proposed.DiagnosticServerCancellationData" params="" file="src/languageServerProtocol/protocol/proposed/Diagnostics.hx" module="languageServerProtocol.protocol.proposed.Diagnostics">
		<a><retriggerRequest><x path="Bool"/></retriggerRequest></a>
		<haxe_doc>Cancellation data returned from a diagnostic request.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.proposed.DocumentDiagnosticParams" params="" file="src/languageServerProtocol/protocol/proposed/Diagnostics.hx" module="languageServerProtocol.protocol.proposed.Diagnostics">
		<a>
			<workDoneToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report work done progress.</haxe_doc>
			</workDoneToken>
			<textDocument>
				<t path="languageServerProtocol.TextDocumentIdentifier"/>
				<haxe_doc>The text document.</haxe_doc>
			</textDocument>
			<previousResultId>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The result id of a previous response if provided.</haxe_doc>
			</previousResultId>
			<partialResultToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report partial results (e.g. streaming) to
		the client.</haxe_doc>
			</partialResultToken>
			<identifier>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The additional identifier  provided during registration.</haxe_doc>
			</identifier>
		</a>
		<haxe_doc>Parameters of the document diagnostic request.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<abstract path="languageServerProtocol.protocol.proposed.DocumentDiagnosticReportFullKind" params="" file="src/languageServerProtocol/protocol/proposed/Diagnostics.hx" module="languageServerProtocol.protocol.proposed.Diagnostics">
		<this><c path="String"/></this>
		<haxe_doc>The document diagnostic report kinds.

	@since 3.17.0
	@proposed</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="languageServerProtocol.protocol.proposed._Diagnostics.DocumentDiagnosticReportFullKind_Impl_" params="" file="src/languageServerProtocol/protocol/proposed/Diagnostics.hx" private="1" module="languageServerProtocol.protocol.proposed.Diagnostics" extern="1" final="1">
	<Full public="1" get="inline" set="null" expr="cast &quot;full&quot;" line="129" static="1">
		<x path="languageServerProtocol.protocol.proposed.DocumentDiagnosticReportFullKind"/>
		<meta>
			<m n=":value"><e>cast "full"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>A diagnostic report with a full
		set of problems.</haxe_doc>
	</Full>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="languageServerProtocol.protocol.proposed._Diagnostics.DocumentDiagnosticReportFullKind_Impl_" params="" file="src/languageServerProtocol/protocol/proposed/Diagnostics.hx" private="1" module="languageServerProtocol.protocol.proposed.Diagnostics" extern="1" final="1">
		<Full public="1" get="inline" set="null" expr="cast &quot;full&quot;" line="129" static="1">
			<x path="languageServerProtocol.protocol.proposed.DocumentDiagnosticReportFullKind"/>
			<meta>
				<m n=":value"><e>cast "full"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>A diagnostic report with a full
		set of problems.</haxe_doc>
		</Full>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="languageServerProtocol.protocol.proposed.DocumentDiagnosticReportUnchangedKind" params="" file="src/languageServerProtocol/protocol/proposed/Diagnostics.hx" module="languageServerProtocol.protocol.proposed.Diagnostics">
		<this><c path="String"/></this>
		<haxe_doc>The document diagnostic report kinds.

	@since 3.17.0
	@proposed</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="languageServerProtocol.protocol.proposed._Diagnostics.DocumentDiagnosticReportUnchangedKind_Impl_" params="" file="src/languageServerProtocol/protocol/proposed/Diagnostics.hx" private="1" module="languageServerProtocol.protocol.proposed.Diagnostics" extern="1" final="1">
	<Unchanged public="1" get="inline" set="null" expr="cast &quot;unchanged&quot;" line="143" static="1">
		<x path="languageServerProtocol.protocol.proposed.DocumentDiagnosticReportUnchangedKind"/>
		<meta>
			<m n=":value"><e>cast "unchanged"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>A report indicating that the last
		returned report is still accurate.</haxe_doc>
	</Unchanged>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="languageServerProtocol.protocol.proposed._Diagnostics.DocumentDiagnosticReportUnchangedKind_Impl_" params="" file="src/languageServerProtocol/protocol/proposed/Diagnostics.hx" private="1" module="languageServerProtocol.protocol.proposed.Diagnostics" extern="1" final="1">
		<Unchanged public="1" get="inline" set="null" expr="cast &quot;unchanged&quot;" line="143" static="1">
			<x path="languageServerProtocol.protocol.proposed.DocumentDiagnosticReportUnchangedKind"/>
			<meta>
				<m n=":value"><e>cast "unchanged"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>A report indicating that the last
		returned report is still accurate.</haxe_doc>
		</Unchanged>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="languageServerProtocol.protocol.proposed.FullDocumentDiagnosticReport" params="" file="src/languageServerProtocol/protocol/proposed/Diagnostics.hx" module="languageServerProtocol.protocol.proposed.Diagnostics">
		<a>
			<resultId>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional result id. If provided it will
		be sent on the next diagnostic request for the
		same document.</haxe_doc>
			</resultId>
			<kind>
				<x path="languageServerProtocol.protocol.proposed.DocumentDiagnosticReportFullKind"/>
				<haxe_doc>A full document diagnostic report.</haxe_doc>
			</kind>
			<items>
				<c path="Array"><t path="languageServerProtocol.Diagnostic"/></c>
				<haxe_doc>The actual items.</haxe_doc>
			</items>
		</a>
		<haxe_doc>A diagnostic report with a full set of problems.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.proposed.RelatedFullDocumentDiagnosticReport" params="" file="src/languageServerProtocol/protocol/proposed/Diagnostics.hx" module="languageServerProtocol.protocol.proposed.Diagnostics">
		<a>
			<resultId>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional result id. If provided it will
		be sent on the next diagnostic request for the
		same document.</haxe_doc>
			</resultId>
			<relatedDocuments>
				<x path="Null"><x path="haxe.DynamicAccess"><x path="haxe.extern.EitherType">
	<t path="languageServerProtocol.protocol.proposed.FullDocumentDiagnosticReport"/>
	<t path="languageServerProtocol.protocol.proposed.UnchangedDocumentDiagnosticReport"/>
</x></x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Diagnostics of related documents. This information is useful
		in programming languages where code in a file A can generate
		diagnostics in a file B which A depends on. An example of
		such a language is C/C++ where marco definitions in a file
		a.cpp and result in errors in a header file b.hpp.

		@since 3.17.0
		@proposed</haxe_doc>
			</relatedDocuments>
			<kind>
				<x path="languageServerProtocol.protocol.proposed.DocumentDiagnosticReportFullKind"/>
				<haxe_doc>A full document diagnostic report.</haxe_doc>
			</kind>
			<items>
				<c path="Array"><t path="languageServerProtocol.Diagnostic"/></c>
				<haxe_doc>The actual items.</haxe_doc>
			</items>
		</a>
		<haxe_doc>A full diagnostic report with a set of related documents.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.proposed.UnchangedDocumentDiagnosticReport" params="" file="src/languageServerProtocol/protocol/proposed/Diagnostics.hx" module="languageServerProtocol.protocol.proposed.Diagnostics">
		<a>
			<resultId>
				<c path="String"/>
				<haxe_doc>A result id which will be sent on the next
		diagnostic request for the same document.</haxe_doc>
			</resultId>
			<kind>
				<x path="languageServerProtocol.protocol.proposed.DocumentDiagnosticReportUnchangedKind"/>
				<haxe_doc>A document diagnostic report indicating
		no changes to the last result. A server can
		only return `unchanged` if result ids are
		provided.</haxe_doc>
			</kind>
		</a>
		<haxe_doc>A diagnostic report indicating that the last returned
	report is still accurate.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.proposed.RelatedUnchangedDocumentDiagnosticReport" params="" file="src/languageServerProtocol/protocol/proposed/Diagnostics.hx" module="languageServerProtocol.protocol.proposed.Diagnostics">
		<a>
			<resultId>
				<c path="String"/>
				<haxe_doc>A result id which will be sent on the next
		diagnostic request for the same document.</haxe_doc>
			</resultId>
			<relatedDocuments>
				<x path="Null"><x path="haxe.DynamicAccess"><x path="haxe.extern.EitherType">
	<t path="languageServerProtocol.protocol.proposed.FullDocumentDiagnosticReport"/>
	<t path="languageServerProtocol.protocol.proposed.UnchangedDocumentDiagnosticReport"/>
</x></x></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Diagnostics of related documents. This information is useful
		in programming languages where code in a file A can generate
		diagnostics in a file B which A depends on. An example of
		such a language is C/C++ where marco definitions in a file
		a.cpp and result in errors in a header file b.hpp.

		@since 3.17.0
		@proposed</haxe_doc>
			</relatedDocuments>
			<kind>
				<x path="languageServerProtocol.protocol.proposed.DocumentDiagnosticReportUnchangedKind"/>
				<haxe_doc>A document diagnostic report indicating
		no changes to the last result. A server can
		only return `unchanged` if result ids are
		provided.</haxe_doc>
			</kind>
		</a>
		<haxe_doc>An unchanged diagnostic report with a set of related documents.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.proposed.DocumentDiagnosticReport" params="" file="src/languageServerProtocol/protocol/proposed/Diagnostics.hx" module="languageServerProtocol.protocol.proposed.Diagnostics">
		<x path="haxe.extern.EitherType">
			<t path="languageServerProtocol.protocol.proposed.RelatedFullDocumentDiagnosticReport"/>
			<t path="languageServerProtocol.protocol.proposed.RelatedUnchangedDocumentDiagnosticReport"/>
		</x>
		<haxe_doc>The result of a document diagnostic pull request. A report can
	either be a full report containing all diagnostics for the
	requested document or a unchanged report indicating that nothing
	has changed in terms of diagnostics in comparison to the last
	pull request.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.proposed.DocumentDiagnosticReportPartialResult" params="" file="src/languageServerProtocol/protocol/proposed/Diagnostics.hx" module="languageServerProtocol.protocol.proposed.Diagnostics">
		<a><relatedDocuments><x path="haxe.DynamicAccess"><x path="haxe.extern.EitherType">
	<t path="languageServerProtocol.protocol.proposed.FullDocumentDiagnosticReport"/>
	<t path="languageServerProtocol.protocol.proposed.UnchangedDocumentDiagnosticReport"/>
</x></x></relatedDocuments></a>
		<haxe_doc>A partial result for a document diagnostic report.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.proposed.DocumentDiagnosticRequest" params="" file="src/languageServerProtocol/protocol/proposed/Diagnostics.hx" module="languageServerProtocol.protocol.proposed.Diagnostics">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;DocumentDiagnosticParams,DocumentDiagnosticReport,DocumentDiagnosticReportPartialResult,DiagnosticServerCancellationData,DiagnosticRegistrationOptions&gt;(&quot;textDocument/diagnostic&quot;)" line="263" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.proposed.DocumentDiagnosticParams"/>
				<t path="languageServerProtocol.protocol.proposed.DocumentDiagnosticReport"/>
				<t path="languageServerProtocol.protocol.proposed.DocumentDiagnosticReportPartialResult"/>
				<t path="languageServerProtocol.protocol.proposed.DiagnosticServerCancellationData"/>
				<t path="languageServerProtocol.protocol.proposed.DiagnosticRegistrationOptions"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<DocumentDiagnosticParams,DocumentDiagnosticReport,DocumentDiagnosticReportPartialResult,DiagnosticServerCancellationData,DiagnosticRegistrationOptions>("textDocument/diagnostic")]]></e></m></meta>
		</type>
		<haxe_doc>The document diagnostic request definition.

	@since 3.17.0
	@proposed</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.proposed.PreviousResultId" params="" file="src/languageServerProtocol/protocol/proposed/Diagnostics.hx" module="languageServerProtocol.protocol.proposed.Diagnostics">
		<a>
			<value>
				<c path="String"/>
				<haxe_doc>The value of the previous result id.</haxe_doc>
			</value>
			<uri>
				<x path="languageServerProtocol.textdocument.DocumentUri"/>
				<haxe_doc>The URI for which the client knowns a
		result id.</haxe_doc>
			</uri>
		</a>
		<haxe_doc>A previous result id in a workspace pull request.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.proposed.WorkspaceDiagnosticParams" params="" file="src/languageServerProtocol/protocol/proposed/Diagnostics.hx" module="languageServerProtocol.protocol.proposed.Diagnostics">
		<a>
			<workDoneToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report work done progress.</haxe_doc>
			</workDoneToken>
			<previousResultIds>
				<c path="Array"><t path="languageServerProtocol.protocol.proposed.PreviousResultId"/></c>
				<haxe_doc>The currently known diagnostic reports with their
		previous result ids.</haxe_doc>
			</previousResultIds>
			<partialResultToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report partial results (e.g. streaming) to
		the client.</haxe_doc>
			</partialResultToken>
			<identifier>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The additional identifier provided during registration.</haxe_doc>
			</identifier>
		</a>
		<haxe_doc>Parameters of the workspace diagnostic request.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.proposed.WorkspaceFullDocumentDiagnosticReport" params="" file="src/languageServerProtocol/protocol/proposed/Diagnostics.hx" module="languageServerProtocol.protocol.proposed.Diagnostics">
		<a>
			<version>
				<x path="Null"><x path="Int"/></x>
				<haxe_doc>The version number for which the diagnostics are reported.
		If the document is not marked as open `null` can be provided.</haxe_doc>
			</version>
			<uri>
				<x path="languageServerProtocol.textdocument.DocumentUri"/>
				<haxe_doc>The URI for which diagnostic information is reported.</haxe_doc>
			</uri>
			<resultId>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional result id. If provided it will
		be sent on the next diagnostic request for the
		same document.</haxe_doc>
			</resultId>
			<kind>
				<x path="languageServerProtocol.protocol.proposed.DocumentDiagnosticReportFullKind"/>
				<haxe_doc>A full document diagnostic report.</haxe_doc>
			</kind>
			<items>
				<c path="Array"><t path="languageServerProtocol.Diagnostic"/></c>
				<haxe_doc>The actual items.</haxe_doc>
			</items>
		</a>
		<haxe_doc>A full document diagnostic report for a workspace diagnostic result.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.proposed.WorkspaceUnchangedDocumentDiagnosticReport" params="" file="src/languageServerProtocol/protocol/proposed/Diagnostics.hx" module="languageServerProtocol.protocol.proposed.Diagnostics">
		<a>
			<version>
				<x path="Null"><x path="Int"/></x>
				<haxe_doc>The version number for which the diagnostics are reported.
		If the document is not marked as open `null` can be provided.</haxe_doc>
			</version>
			<uri>
				<x path="languageServerProtocol.textdocument.DocumentUri"/>
				<haxe_doc>The URI for which diagnostic information is reported.</haxe_doc>
			</uri>
			<resultId>
				<c path="String"/>
				<haxe_doc>A result id which will be sent on the next
		diagnostic request for the same document.</haxe_doc>
			</resultId>
			<kind>
				<x path="languageServerProtocol.protocol.proposed.DocumentDiagnosticReportUnchangedKind"/>
				<haxe_doc>A document diagnostic report indicating
		no changes to the last result. A server can
		only return `unchanged` if result ids are
		provided.</haxe_doc>
			</kind>
		</a>
		<haxe_doc>An unchanged document diagnostic report for a workspace diagnostic result.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.proposed.WorkspaceDocumentDiagnosticReport" params="" file="src/languageServerProtocol/protocol/proposed/Diagnostics.hx" module="languageServerProtocol.protocol.proposed.Diagnostics">
		<x path="haxe.extern.EitherType">
			<t path="languageServerProtocol.protocol.proposed.WorkspaceFullDocumentDiagnosticReport"/>
			<t path="languageServerProtocol.protocol.proposed.WorkspaceUnchangedDocumentDiagnosticReport"/>
		</x>
		<haxe_doc>A workspace diagnostic document report.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.proposed.WorkspaceDiagnosticReport" params="" file="src/languageServerProtocol/protocol/proposed/Diagnostics.hx" module="languageServerProtocol.protocol.proposed.Diagnostics">
		<a><items><c path="Array"><t path="languageServerProtocol.protocol.proposed.WorkspaceDocumentDiagnosticReport"/></c></items></a>
		<haxe_doc>A workspace diagnostic report.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.proposed.WorkspaceDiagnosticReportPartialResult" params="" file="src/languageServerProtocol/protocol/proposed/Diagnostics.hx" module="languageServerProtocol.protocol.proposed.Diagnostics">
		<a><items><c path="Array"><t path="languageServerProtocol.protocol.proposed.WorkspaceDocumentDiagnosticReport"/></c></items></a>
		<haxe_doc>A partial result for a workspace diagnostic report.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.proposed.WorkspaceDiagnosticRequest" params="" file="src/languageServerProtocol/protocol/proposed/Diagnostics.hx" module="languageServerProtocol.protocol.proposed.Diagnostics">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;WorkspaceDiagnosticParams,WorkspaceDiagnosticReport,WorkspaceDiagnosticReportPartialResult,DiagnosticServerCancellationData,NoData&gt;(&quot;workspace/diagnostic&quot;)" line="379" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.proposed.WorkspaceDiagnosticParams"/>
				<t path="languageServerProtocol.protocol.proposed.WorkspaceDiagnosticReport"/>
				<t path="languageServerProtocol.protocol.proposed.WorkspaceDiagnosticReportPartialResult"/>
				<t path="languageServerProtocol.protocol.proposed.DiagnosticServerCancellationData"/>
				<e path="jsonrpc.NoData"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<WorkspaceDiagnosticParams,WorkspaceDiagnosticReport,WorkspaceDiagnosticReportPartialResult,DiagnosticServerCancellationData,NoData>("workspace/diagnostic")]]></e></m></meta>
		</type>
		<haxe_doc>The workspace diagnostic request definition.

	@since 3.17.0
	@proposed</haxe_doc>
	</class>
	<class path="languageServerProtocol.protocol.proposed.DiagnosticRefreshRequest" params="" file="src/languageServerProtocol/protocol/proposed/Diagnostics.hx" module="languageServerProtocol.protocol.proposed.Diagnostics">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;NoData,NoData,NoData,NoData,NoData&gt;(&quot;workspace/diagnostic/refresh&quot;)" line="390" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<e path="jsonrpc.NoData"/>
				<e path="jsonrpc.NoData"/>
				<e path="jsonrpc.NoData"/>
				<e path="jsonrpc.NoData"/>
				<e path="jsonrpc.NoData"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<NoData,NoData,NoData,NoData,NoData>("workspace/diagnostic/refresh")]]></e></m></meta>
		</type>
		<haxe_doc>The diagnostic refresh request definition.

	@since 3.17.0
	@proposed</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.proposed.InlayHintClientCapabilities" params="" file="src/languageServerProtocol/protocol/proposed/InlayHints.hx" module="languageServerProtocol.protocol.proposed.InlayHints">
		<a>
			<resolveSupport>
				<x path="Null"><a><properties>
	<c path="Array"><c path="String"/></c>
	<haxe_doc>The properties that a client can resolve lazily.</haxe_doc>
</properties></a></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Indicates which properties a client can resolve lazily on a inlay
		hint.</haxe_doc>
			</resolveSupport>
			<dynamicRegistration>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether inlay hints support dynamic registration.</haxe_doc>
			</dynamicRegistration>
		</a>
		<haxe_doc>Inlay hint client capabilities

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.proposed.InlayHintWorkspaceClientCapabilities" params="" file="src/languageServerProtocol/protocol/proposed/InlayHints.hx" module="languageServerProtocol.protocol.proposed.InlayHints">
		<a><refreshSupport>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>Whether the client implementation supports a refresh request sent from
		the server to the client.

		Note that this event is global and will force the client to refresh all
		inlay hints currently shown. It should be used with absolute care and
		is useful for situation where a server for example detects a project wide
		change that requires such a calculation.</haxe_doc>
</refreshSupport></a>
		<haxe_doc>Client workspace capabilities specific to inlay hints.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.proposed.InlayHintOptions" params="" file="src/languageServerProtocol/protocol/proposed/InlayHints.hx" module="languageServerProtocol.protocol.proposed.InlayHints">
		<a>
			<workDoneProgress>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
			</workDoneProgress>
			<resolveProvider>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The server provides support to resolve additional
		information for an inlay hint item.</haxe_doc>
			</resolveProvider>
		</a>
		<haxe_doc>Inlay hint options used during static registration.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.proposed.InlayHintRegistrationOptions" params="" file="src/languageServerProtocol/protocol/proposed/InlayHints.hx" module="languageServerProtocol.protocol.proposed.InlayHints">
		<a>
			<workDoneProgress>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
			</workDoneProgress>
			<resolveProvider>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The server provides support to resolve additional
		information for an inlay hint item.</haxe_doc>
			</resolveProvider>
			<id>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The id used to register the request. The id can be used to deregister
		the request again. See also Registration#id.</haxe_doc>
			</id>
			<documentSelector>
				<x path="Null"><t path="languageServerProtocol.protocol.DocumentSelector"/></x>
				<haxe_doc>A document selector to identify the scope of the registration. If set to null
		the document selector provided on the client side will be used.</haxe_doc>
			</documentSelector>
		</a>
		<haxe_doc>Inlay hint options used during static or dynamic registration.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.proposed.InlayHintParams" params="" file="src/languageServerProtocol/protocol/proposed/InlayHints.hx" module="languageServerProtocol.protocol.proposed.InlayHints">
		<a>
			<workDoneToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report work done progress.</haxe_doc>
			</workDoneToken>
			<textDocument>
				<t path="languageServerProtocol.TextDocumentIdentifier"/>
				<haxe_doc>The text document.</haxe_doc>
			</textDocument>
			<range>
				<t path="languageServerProtocol.textdocument.Range"/>
				<haxe_doc>The document range for which inlay hints should be computed.</haxe_doc>
			</range>
		</a>
		<haxe_doc>A parameter literal used in inlay hints requests.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.proposed.InlayHintRequest" params="" file="src/languageServerProtocol/protocol/proposed/InlayHints.hx" module="languageServerProtocol.protocol.proposed.InlayHints">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;InlayHintParams,Null&lt;Array&lt;InlayHint&gt;&gt;,Array&lt;InlayHint&gt;,NoData,InlayHintRegistrationOptions&gt;(&quot;textDocument/inlayHint&quot;)" line="98" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.proposed.InlayHintParams"/>
				<x path="Null"><c path="Array"><t path="languageServerProtocol.InlayHint"/></c></x>
				<c path="Array"><t path="languageServerProtocol.InlayHint"/></c>
				<e path="jsonrpc.NoData"/>
				<t path="languageServerProtocol.protocol.proposed.InlayHintRegistrationOptions"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<InlayHintParams,Null<Array<InlayHint>>,Array<InlayHint>,NoData,InlayHintRegistrationOptions>("textDocument/inlayHint")]]></e></m></meta>
		</type>
		<haxe_doc>A request to provide inlay hints in a document. The request's parameter is of
	type [InlayHintsParams](#InlayHintsParams), the response is of type
	[InlayHint[]](#InlayHint[]) or a Thenable that resolves to such.

	@since 3.17.0
	@proposed</haxe_doc>
	</class>
	<class path="languageServerProtocol.protocol.proposed.InlayHintResolveRequest" params="" file="src/languageServerProtocol/protocol/proposed/InlayHints.hx" module="languageServerProtocol.protocol.proposed.InlayHints">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;InlayHint,InlayHint,Never,NoData,NoData&gt;(&quot;inlayHint/resolve&quot;)" line="111" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.InlayHint"/>
				<t path="languageServerProtocol.InlayHint"/>
				<e path="languageServerProtocol.protocol.Never"/>
				<e path="jsonrpc.NoData"/>
				<e path="jsonrpc.NoData"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<InlayHint,InlayHint,Never,NoData,NoData>("inlayHint/resolve")]]></e></m></meta>
		</type>
		<haxe_doc>A request to resolve additional properties for a inlay hint.
	The request's parameter is of type [InlayHint](#InlayHint), the response is
	of type [InlayHint](#InlayHint) or a Thenable that resolves to such.

	@since 3.17.0
	@proposed</haxe_doc>
	</class>
	<class path="languageServerProtocol.protocol.proposed.InlayHintRefreshRequest" params="" file="src/languageServerProtocol/protocol/proposed/InlayHints.hx" module="languageServerProtocol.protocol.proposed.InlayHints">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;NoData,NoData,NoData,NoData,NoData&gt;(&quot;workspace/inlayHint/refresh&quot;)" line="119" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<e path="jsonrpc.NoData"/>
				<e path="jsonrpc.NoData"/>
				<e path="jsonrpc.NoData"/>
				<e path="jsonrpc.NoData"/>
				<e path="jsonrpc.NoData"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<NoData,NoData,NoData,NoData,NoData>("workspace/inlayHint/refresh")]]></e></m></meta>
		</type>
		<haxe_doc>@since 3.17.0
	@proposed</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.proposed.InlineValueClientCapabilities" params="" file="src/languageServerProtocol/protocol/proposed/InlineValue.hx" module="languageServerProtocol.protocol.proposed.InlineValue">
		<a><dynamicRegistration>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>Whether implementation supports dynamic registration for inline value providers.</haxe_doc>
</dynamicRegistration></a>
		<haxe_doc>Client capabilities specific to inline values.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.proposed.InlineValueWorkspaceClientCapabilities" params="" file="src/languageServerProtocol/protocol/proposed/InlineValue.hx" module="languageServerProtocol.protocol.proposed.InlineValue">
		<a><refreshSupport>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>Whether the client implementation supports a refresh request sent from the
		server to the client.

		Note that this event is global and will force the client to refresh all
		inline values currently shown. It should be used with absolute care and is
		useful for situation where a server for example detects a project wide
		change that requires such a calculation.</haxe_doc>
</refreshSupport></a>
		<haxe_doc>Client workspace capabilities specific to inline values.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.proposed.InlineValueOptions" params="" file="src/languageServerProtocol/protocol/proposed/InlineValue.hx" module="languageServerProtocol.protocol.proposed.InlineValue">
		<t path="languageServerProtocol.protocol.WorkDoneProgressOptions"/>
		<haxe_doc>Inline value options used during static registration.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.proposed.InlineValueRegistrationOptions" params="" file="src/languageServerProtocol/protocol/proposed/InlineValue.hx" module="languageServerProtocol.protocol.proposed.InlineValue">
		<a>
			<workDoneProgress>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
			</workDoneProgress>
			<id>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The id used to register the request. The id can be used to deregister
		the request again. See also Registration#id.</haxe_doc>
			</id>
			<documentSelector>
				<x path="Null"><t path="languageServerProtocol.protocol.DocumentSelector"/></x>
				<haxe_doc>A document selector to identify the scope of the registration. If set to null
		the document selector provided on the client side will be used.</haxe_doc>
			</documentSelector>
		</a>
		<haxe_doc>Inline value options used during static or dynamic registration.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.proposed.InlineValueParams" params="" file="src/languageServerProtocol/protocol/proposed/InlineValue.hx" module="languageServerProtocol.protocol.proposed.InlineValue">
		<a>
			<workDoneToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report work done progress.</haxe_doc>
			</workDoneToken>
			<textDocument>
				<t path="languageServerProtocol.TextDocumentIdentifier"/>
				<haxe_doc>The text document.</haxe_doc>
			</textDocument>
			<range>
				<t path="languageServerProtocol.textdocument.Range"/>
				<haxe_doc>The document range for which inline values should be computed.</haxe_doc>
			</range>
			<context>
				<t path="languageServerProtocol.InlineValueContext"/>
				<haxe_doc>Additional information about the context in which inline values were
		requested.</haxe_doc>
			</context>
		</a>
		<haxe_doc>A parameter literal used in inline value requests.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.proposed.InlineValueRequest" params="" file="src/languageServerProtocol/protocol/proposed/InlineValue.hx" module="languageServerProtocol.protocol.proposed.InlineValue">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;InlineValueParams,Null&lt;Array&lt;InlineValueParams&gt;&gt;,Array&lt;InlineValueParams&gt;,NoData,InlineValueRegistrationOptions&gt;(&quot;textDocument/inlineValue&quot;)" line="89" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.proposed.InlineValueParams"/>
				<x path="Null"><c path="Array"><t path="languageServerProtocol.protocol.proposed.InlineValueParams"/></c></x>
				<c path="Array"><t path="languageServerProtocol.protocol.proposed.InlineValueParams"/></c>
				<e path="jsonrpc.NoData"/>
				<t path="languageServerProtocol.protocol.proposed.InlineValueRegistrationOptions"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<InlineValueParams,Null<Array<InlineValueParams>>,Array<InlineValueParams>,NoData,InlineValueRegistrationOptions>("textDocument/inlineValue")]]></e></m></meta>
		</type>
		<haxe_doc>A request to provide inline values in a document. The request's parameter is of
	type [InlineValueParams](#InlineValueParams), the response is of type
	[InlineValue[]](#InlineValue[]) or a Thenable that resolves to such.

	@since 3.17.0
	@proposed</haxe_doc>
	</class>
	<class path="languageServerProtocol.protocol.proposed.InlineValueRefreshRequest" params="" file="src/languageServerProtocol/protocol/proposed/InlineValue.hx" module="languageServerProtocol.protocol.proposed.InlineValue">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;NoData,NoData,NoData,NoData,NoData&gt;(&quot;workspace/inlineValue/refresh&quot;)" line="98" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<e path="jsonrpc.NoData"/>
				<e path="jsonrpc.NoData"/>
				<e path="jsonrpc.NoData"/>
				<e path="jsonrpc.NoData"/>
				<e path="jsonrpc.NoData"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<NoData,NoData,NoData,NoData,NoData>("workspace/inlineValue/refresh")]]></e></m></meta>
		</type>
		<haxe_doc>@since 3.17.0
	@proposed</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.proposed.NotebookDocumentSyncClientCapabilities" params="" file="src/languageServerProtocol/protocol/proposed/Notebook.hx" module="languageServerProtocol.protocol.proposed.Notebook">
		<a>
			<executionSummarySupport>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The client supports sending execution summary data per cell.</haxe_doc>
			</executionSummarySupport>
			<dynamicRegistration>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc><![CDATA[Whether implementation supports dynamic registration. If this is
		set to `true` the client supports the new
		`(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
		return value for the corresponding server capability as well.]]></haxe_doc>
			</dynamicRegistration>
		</a>
		<haxe_doc>Notebook specific client capabilities.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<abstract path="languageServerProtocol.protocol.proposed.NotebookCellKind" params="" file="src/languageServerProtocol/protocol/proposed/Notebook.hx" module="languageServerProtocol.protocol.proposed.Notebook">
		<this><x path="Int"/></this>
		<haxe_doc>A notebook cell kind.

	@since 3.17.0
	@proposed</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="languageServerProtocol.protocol.proposed._Notebook.NotebookCellKind_Impl_" params="" file="src/languageServerProtocol/protocol/proposed/Notebook.hx" private="1" module="languageServerProtocol.protocol.proposed.Notebook" extern="1" final="1">
	<Markup public="1" get="inline" set="null" expr="cast 1" line="37" static="1">
		<x path="languageServerProtocol.protocol.proposed.NotebookCellKind"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>A markup-cell is formatted source that is used for display.</haxe_doc>
	</Markup>
	<Code public="1" get="inline" set="null" expr="cast 2" line="42" static="1">
		<x path="languageServerProtocol.protocol.proposed.NotebookCellKind"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>A code-cell is source code.</haxe_doc>
	</Code>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="languageServerProtocol.protocol.proposed._Notebook.NotebookCellKind_Impl_" params="" file="src/languageServerProtocol/protocol/proposed/Notebook.hx" private="1" module="languageServerProtocol.protocol.proposed.Notebook" extern="1" final="1">
		<Markup public="1" get="inline" set="null" expr="cast 1" line="37" static="1">
			<x path="languageServerProtocol.protocol.proposed.NotebookCellKind"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>A markup-cell is formatted source that is used for display.</haxe_doc>
		</Markup>
		<Code public="1" get="inline" set="null" expr="cast 2" line="42" static="1">
			<x path="languageServerProtocol.protocol.proposed.NotebookCellKind"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>A code-cell is source code.</haxe_doc>
		</Code>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="languageServerProtocol.protocol.proposed.ExecutionSummary" params="" file="src/languageServerProtocol/protocol/proposed/Notebook.hx" module="languageServerProtocol.protocol.proposed.Notebook"><a>
	<success>
		<x path="Bool"/>
		<haxe_doc>Whether the execution was successful or
		not if known by the client.</haxe_doc>
	</success>
	<executionOrder>
		<x path="Int"/>
		<haxe_doc>A strict monotonically increasing value
		indicating the execution order of a cell
		inside a notebook.</haxe_doc>
	</executionOrder>
</a></typedef>
	<typedef path="languageServerProtocol.protocol.proposed.NotebookCell" params="" file="src/languageServerProtocol/protocol/proposed/Notebook.hx" module="languageServerProtocol.protocol.proposed.Notebook">
		<a>
			<metadata>
				<x path="Null"><t path="languageServerProtocol.LSPObject"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Additional metadata stored with the cell.</haxe_doc>
			</metadata>
			<kind>
				<x path="languageServerProtocol.protocol.proposed.NotebookCellKind"/>
				<haxe_doc>The cell's kind</haxe_doc>
			</kind>
			<executionSummary>
				<t path="languageServerProtocol.protocol.proposed.ExecutionSummary"/>
				<haxe_doc>Additional execution summary information
		if supported by the client.</haxe_doc>
			</executionSummary>
			<document>
				<x path="languageServerProtocol.textdocument.DocumentUri"/>
				<haxe_doc>The URI of the cell's text document
		content.</haxe_doc>
			</document>
		</a>
		<haxe_doc>A notebook cell.

	A cell's document URI must be unique across ALL notebook
	cells and can therefore be used to uniquely identify a
	notebook cell or the cell's text document.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.proposed.NotebookDocument" params="" file="src/languageServerProtocol/protocol/proposed/Notebook.hx" module="languageServerProtocol.protocol.proposed.Notebook">
		<a>
			<version>
				<x path="Int"/>
				<haxe_doc>The version number of this document (it will increase after each
		change, including undo/redo).</haxe_doc>
			</version>
			<uri>
				<x path="languageServerProtocol.URI"/>
				<haxe_doc>The notebook document's uri.</haxe_doc>
			</uri>
			<notebookType>
				<c path="String"/>
				<haxe_doc>The type of the notebook.</haxe_doc>
			</notebookType>
			<metadata>
				<x path="Null"><t path="languageServerProtocol.LSPObject"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Additional metadata stored with the notebook
		document.</haxe_doc>
			</metadata>
			<cells>
				<c path="Array"><t path="languageServerProtocol.protocol.proposed.NotebookCell"/></c>
				<haxe_doc>The cells of a notebook.</haxe_doc>
			</cells>
		</a>
		<haxe_doc>A notebook document.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.proposed.NotebookDocumentIdentifier" params="" file="src/languageServerProtocol/protocol/proposed/Notebook.hx" module="languageServerProtocol.protocol.proposed.Notebook">
		<a><uri>
	<x path="languageServerProtocol.URI"/>
	<haxe_doc>The notebook document's uri.</haxe_doc>
</uri></a>
		<haxe_doc>A literal to identify a notebook document in the client.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.proposed.VersionedNotebookDocumentIdentifier" params="" file="src/languageServerProtocol/protocol/proposed/Notebook.hx" module="languageServerProtocol.protocol.proposed.Notebook">
		<a>
			<version>
				<x path="Int"/>
				<haxe_doc>The version number of this notebook document.</haxe_doc>
			</version>
			<uri>
				<x path="languageServerProtocol.URI"/>
				<haxe_doc>The notebook document's uri.</haxe_doc>
			</uri>
		</a>
		<haxe_doc>A versioned notebook document identifier.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.proposed.NotebookDocumentSyncOptions" params="" file="src/languageServerProtocol/protocol/proposed/Notebook.hx" module="languageServerProtocol.protocol.proposed.Notebook">
		<a>
			<save>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether save notification should be forwarded to
		the server. Will only be honored if mode === `notebook`.</haxe_doc>
			</save>
			<notebookSelector>
				<c path="Array"><a>
	<notebook>
		<x path="Null"><x path="haxe.extern.EitherType">
	<c path="String"/>
	<t path="languageServerProtocol.protocol.NotebookDocumentFilter"/>
</x></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The notebook to be synced If a string
			 	 	value is provided it matches against the
			notebook type. '*' matches every notebook.</haxe_doc>
	</notebook>
	<cells>
		<x path="Null"><c path="Array"><a><language><c path="String"/></language></a></c></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The cells of the matching notebook to be synced.</haxe_doc>
	</cells>
</a></c>
				<haxe_doc>The notebooks to be synced</haxe_doc>
			</notebookSelector>
		</a>
		<haxe_doc>Options specific to a notebook plus its cells
	to be synced to the server.

	If a selector provide a notebook document
	filter but no cell selector all cells of a
	matching notebook document will be synced.

	If a selector provides no notebook document
	filter but only a cell selector all notebook
	document that contain at least one matching
	cell will be synced.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.proposed.NotebookDocumentSyncRegistrationOptions" params="" file="src/languageServerProtocol/protocol/proposed/Notebook.hx" module="languageServerProtocol.protocol.proposed.Notebook">
		<a>
			<save>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether save notification should be forwarded to
		the server. Will only be honored if mode === `notebook`.</haxe_doc>
			</save>
			<notebookSelector>
				<c path="Array"><a>
	<notebook>
		<x path="Null"><x path="haxe.extern.EitherType">
	<c path="String"/>
	<t path="languageServerProtocol.protocol.NotebookDocumentFilter"/>
</x></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The notebook to be synced If a string
			 	 	value is provided it matches against the
			notebook type. '*' matches every notebook.</haxe_doc>
	</notebook>
	<cells>
		<x path="Null"><c path="Array"><a><language><c path="String"/></language></a></c></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>The cells of the matching notebook to be synced.</haxe_doc>
	</cells>
</a></c>
				<haxe_doc>The notebooks to be synced</haxe_doc>
			</notebookSelector>
			<id>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The id used to register the request. The id can be used to deregister
		the request again. See also Registration#id.</haxe_doc>
			</id>
		</a>
		<haxe_doc>Registration options specific to a notebook.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.proposed.NotebookDocumentSyncRegistrationType" params="" file="src/languageServerProtocol/protocol/proposed/Notebook.hx" module="languageServerProtocol.protocol.proposed.Notebook"><type final="1" public="1" get="inline" set="null" expr="new RegistrationType&lt;NotebookDocumentSyncRegistrationOptions&gt;(&quot;notebookDocument/sync&quot;)" line="210" static="1">
	<x path="languageServerProtocol.protocol.RegistrationType"><t path="languageServerProtocol.protocol.proposed.NotebookDocumentSyncRegistrationOptions"/></x>
	<meta><m n=":value"><e><![CDATA[new RegistrationType<NotebookDocumentSyncRegistrationOptions>("notebookDocument/sync")]]></e></m></meta>
</type></class>
	<typedef path="languageServerProtocol.protocol.proposed.DidOpenNotebookDocumentParams" params="" file="src/languageServerProtocol/protocol/proposed/Notebook.hx" module="languageServerProtocol.protocol.proposed.Notebook">
		<a>
			<notebookDocument>
				<t path="languageServerProtocol.protocol.proposed.NotebookDocument"/>
				<haxe_doc>The notebook document that got opened.</haxe_doc>
			</notebookDocument>
			<cellTextDocuments>
				<c path="Array"><t path="languageServerProtocol.TextDocumentItem"/></c>
				<haxe_doc>The text documents that represent the content
		of a notebook cell.</haxe_doc>
			</cellTextDocuments>
		</a>
		<haxe_doc>The params sent in a open notebook document notification.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.proposed.DidOpenNotebookDocumentNotification" params="" file="src/languageServerProtocol/protocol/proposed/Notebook.hx" module="languageServerProtocol.protocol.proposed.Notebook">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolNotificationType&lt;DidOpenNotebookDocumentParams,NoData&gt;(&quot;notebookDocument/didOpen&quot;)" line="239" static="1">
			<x path="languageServerProtocol.protocol.ProtocolNotificationType">
				<t path="languageServerProtocol.protocol.proposed.DidOpenNotebookDocumentParams"/>
				<e path="jsonrpc.NoData"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolNotificationType<DidOpenNotebookDocumentParams,NoData>("notebookDocument/didOpen")]]></e></m></meta>
		</type>
		<haxe_doc>A notification sent when a notebook opens.

	@since 3.17.0
	@proposed</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.proposed.NotebookCellArrayChange" params="" file="src/languageServerProtocol/protocol/proposed/Notebook.hx" module="languageServerProtocol.protocol.proposed.Notebook">
		<a>
			<start>
				<x path="Int"/>
				<haxe_doc>The start oftest of the cell that changed.</haxe_doc>
			</start>
			<deleteCount>
				<x path="Int"/>
				<haxe_doc>The deleted cells</haxe_doc>
			</deleteCount>
			<cells>
				<x path="Null"><c path="Array"><t path="languageServerProtocol.protocol.proposed.NotebookCell"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The new cells, if any</haxe_doc>
			</cells>
		</a>
		<haxe_doc>A change describing how to move a `NotebookCell`
	array from state S to S'.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.proposed.NotebookDocumentChangeEvent" params="" file="src/languageServerProtocol/protocol/proposed/Notebook.hx" module="languageServerProtocol.protocol.proposed.Notebook">
		<a>
			<metadata>
				<x path="Null"><t path="languageServerProtocol.LSPObject"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The changed meta data if any.</haxe_doc>
			</metadata>
			<cells>
				<x path="Null"><a>
	<textContent>
		<x path="Null"><c path="Array"><a>
	<document><t path="languageServerProtocol.VersionedTextDocumentIdentifier"/></document>
	<changes><c path="Array"><t path="languageServerProtocol.textdocument.TextDocumentContentChangeEvent"/></c></changes>
</a></c></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Changes to the text content of notebook cells.</haxe_doc>
	</textContent>
	<structure>
		<x path="Null"><a>
	<didOpen>
		<x path="Null"><c path="Array"><t path="languageServerProtocol.TextDocumentItem"/></c></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Additional opened cell text documents.</haxe_doc>
	</didOpen>
	<didClose>
		<x path="Null"><c path="Array"><t path="languageServerProtocol.TextDocumentIdentifier"/></c></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Additional closed cell text documents.</haxe_doc>
	</didClose>
	<array>
		<t path="languageServerProtocol.protocol.proposed.NotebookCellArrayChange"/>
		<haxe_doc>The change to the cell array.</haxe_doc>
	</array>
</a></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Changes to the cell structure to add or
			remove cells.</haxe_doc>
	</structure>
	<data>
		<x path="Null"><c path="Array"><t path="languageServerProtocol.protocol.proposed.NotebookCell"/></c></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>Changes to notebook cells properties like its
			kind, execution summary or metadata.</haxe_doc>
	</data>
</a></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Changes to cells</haxe_doc>
			</cells>
		</a>
		<haxe_doc>A change event for a notebook document.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.proposed.DidChangeNotebookDocumentParams" params="" file="src/languageServerProtocol/protocol/proposed/Notebook.hx" module="languageServerProtocol.protocol.proposed.Notebook">
		<a>
			<notebookDocument>
				<t path="languageServerProtocol.protocol.proposed.VersionedNotebookDocumentIdentifier"/>
				<haxe_doc>The notebook document that did change. The version number points
		to the version after all provided changes have been applied. If
		only the text document content of a cell changes the notebook version
		doesn't necessarily have to change.</haxe_doc>
			</notebookDocument>
			<change>
				<t path="languageServerProtocol.protocol.proposed.NotebookDocumentChangeEvent"/>
				<haxe_doc>The actual changes to the notebook document.

		The changes describe single state changes to the notebook document.
		So if there are two changes c1 (at array index 0) and c2 (at array
		index 1) for a notebook in state S then c1 moves the notebook from
		S to S' and c2 from S' to S''. So c1 is computed on the state S and
		c2 is computed on the state S'.

		To mirror the content of a notebook using change events use the following approach:
		- start with the same initial content
		- apply the 'notebookDocument/didChange' notifications in the order you receive them.
		- apply the `NotebookChangeEvent`s in a single notification in the order
		  you receive them.</haxe_doc>
			</change>
		</a>
		<haxe_doc>The params sent in a change notebook document notification.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.proposed.DidChangeNotebookDocumentNotification" params="" file="src/languageServerProtocol/protocol/proposed/Notebook.hx" module="languageServerProtocol.protocol.proposed.Notebook"><type final="1" public="1" get="inline" set="null" expr="new ProtocolNotificationType&lt;DidChangeNotebookDocumentParams,NoData&gt;(&quot;notebookDocument/didChange&quot;)" line="353" static="1">
	<x path="languageServerProtocol.protocol.ProtocolNotificationType">
		<t path="languageServerProtocol.protocol.proposed.DidChangeNotebookDocumentParams"/>
		<e path="jsonrpc.NoData"/>
	</x>
	<meta><m n=":value"><e><![CDATA[new ProtocolNotificationType<DidChangeNotebookDocumentParams,NoData>("notebookDocument/didChange")]]></e></m></meta>
</type></class>
	<typedef path="languageServerProtocol.protocol.proposed.DidSaveNotebookDocumentParams" params="" file="src/languageServerProtocol/protocol/proposed/Notebook.hx" module="languageServerProtocol.protocol.proposed.Notebook">
		<a><notebookDocument>
	<t path="languageServerProtocol.protocol.proposed.NotebookDocumentIdentifier"/>
	<haxe_doc>The notebook document that got saved.</haxe_doc>
</notebookDocument></a>
		<haxe_doc>The params sent in a save notebook document notification.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.proposed.DidSaveNotebookDocumentNotification" params="" file="src/languageServerProtocol/protocol/proposed/Notebook.hx" module="languageServerProtocol.protocol.proposed.Notebook">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolNotificationType&lt;DidSaveNotebookDocumentParams,NoData&gt;(&quot;notebookDocument/didSave&quot;)" line="376" static="1">
			<x path="languageServerProtocol.protocol.ProtocolNotificationType">
				<t path="languageServerProtocol.protocol.proposed.DidSaveNotebookDocumentParams"/>
				<e path="jsonrpc.NoData"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolNotificationType<DidSaveNotebookDocumentParams,NoData>("notebookDocument/didSave")]]></e></m></meta>
		</type>
		<haxe_doc>A notification sent when a notebook document is saved.

	@since 3.17.0
	@proposed</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.proposed.DidCloseNotebookDocumentParams" params="" file="src/languageServerProtocol/protocol/proposed/Notebook.hx" module="languageServerProtocol.protocol.proposed.Notebook">
		<a>
			<notebookDocument>
				<t path="languageServerProtocol.protocol.proposed.NotebookDocumentIdentifier"/>
				<haxe_doc>The notebook document that got closed.</haxe_doc>
			</notebookDocument>
			<cellTextDocuments>
				<c path="Array"><t path="languageServerProtocol.TextDocumentIdentifier"/></c>
				<haxe_doc>The text documents that represent the content
		of a notebook cell that got closed.</haxe_doc>
			</cellTextDocuments>
		</a>
		<haxe_doc>The params sent in a close notebook document notification.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.proposed.DidCloseNotebookDocumentNotification" params="" file="src/languageServerProtocol/protocol/proposed/Notebook.hx" module="languageServerProtocol.protocol.proposed.Notebook">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolNotificationType&lt;DidCloseNotebookDocumentParams,NoData&gt;(&quot;notebookDocument/didClose&quot;)" line="405" static="1">
			<x path="languageServerProtocol.protocol.ProtocolNotificationType">
				<t path="languageServerProtocol.protocol.proposed.DidCloseNotebookDocumentParams"/>
				<e path="jsonrpc.NoData"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolNotificationType<DidCloseNotebookDocumentParams,NoData>("notebookDocument/didClose")]]></e></m></meta>
		</type>
		<haxe_doc>A notification sent when a notebook closes.

	@since 3.17.0
	@proposed</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.proposed.TypeHierarchyClientCapabilities" params="" file="src/languageServerProtocol/protocol/proposed/TypeHierarchy.hx" module="languageServerProtocol.protocol.proposed.TypeHierarchy">
		<a><dynamicRegistration>
	<x path="Null"><x path="Bool"/></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc><![CDATA[Whether implementation supports dynamic registration. If this is set to `true`
		the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
		return value for the corresponding server capability as well.]]></haxe_doc>
</dynamicRegistration></a>
		<haxe_doc>@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.proposed.TypeHierarchyOptions" params="" file="src/languageServerProtocol/protocol/proposed/TypeHierarchy.hx" module="languageServerProtocol.protocol.proposed.TypeHierarchy">
		<t path="languageServerProtocol.protocol.WorkDoneProgressOptions"/>
		<haxe_doc>Type hierarchy options used during static registration.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.proposed.TypeHierarchyRegistrationOptions" params="" file="src/languageServerProtocol/protocol/proposed/TypeHierarchy.hx" module="languageServerProtocol.protocol.proposed.TypeHierarchy">
		<a>
			<workDoneProgress>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
			</workDoneProgress>
			<id>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The id used to register the request. The id can be used to deregister
		the request again. See also Registration#id.</haxe_doc>
			</id>
			<documentSelector>
				<x path="Null"><t path="languageServerProtocol.protocol.DocumentSelector"/></x>
				<haxe_doc>A document selector to identify the scope of the registration. If set to null
		the document selector provided on the client side will be used.</haxe_doc>
			</documentSelector>
		</a>
		<haxe_doc>Type hierarchy options used during static or dynamic registration.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.protocol.proposed.TypeHierarchyPrepareParams" params="" file="src/languageServerProtocol/protocol/proposed/TypeHierarchy.hx" module="languageServerProtocol.protocol.proposed.TypeHierarchy">
		<a>
			<workDoneToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report work done progress.</haxe_doc>
			</workDoneToken>
			<textDocument>
				<t path="languageServerProtocol.TextDocumentIdentifier"/>
				<haxe_doc>The text document.</haxe_doc>
			</textDocument>
			<position>
				<t path="languageServerProtocol.textdocument.Position"/>
				<haxe_doc>The position inside the text document.</haxe_doc>
			</position>
		</a>
		<haxe_doc>The parameter of a `textDocument/prepareTypeHierarchy` request.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.proposed.TypeHierarchyPrepareRequest" params="" file="src/languageServerProtocol/protocol/proposed/TypeHierarchy.hx" module="languageServerProtocol.protocol.proposed.TypeHierarchy">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;TypeHierarchyPrepareParams,Null&lt;Array&lt;TypeHierarchyItem&gt;&gt;,Never,NoData,TypeHierarchyRegistrationOptions&gt;(&quot;textDocument/prepareTypeHierarchy&quot;)" line="51" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.proposed.TypeHierarchyPrepareParams"/>
				<x path="Null"><c path="Array"><t path="languageServerProtocol.TypeHierarchyItem"/></c></x>
				<e path="languageServerProtocol.protocol.Never"/>
				<e path="jsonrpc.NoData"/>
				<t path="languageServerProtocol.protocol.proposed.TypeHierarchyRegistrationOptions"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<TypeHierarchyPrepareParams,Null<Array<TypeHierarchyItem>>,Never,NoData,TypeHierarchyRegistrationOptions>("textDocument/prepareTypeHierarchy")]]></e></m></meta>
		</type>
		<haxe_doc>A request to result a `TypeHierarchyItem` in a document at a given position.
	Can be used as an input to a subtypes or supertypes type hierarchy.

	@since 3.17.0
	@proposed</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.proposed.TypeHierarchySupertypesParams" params="" file="src/languageServerProtocol/protocol/proposed/TypeHierarchy.hx" module="languageServerProtocol.protocol.proposed.TypeHierarchy">
		<a>
			<workDoneToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report work done progress.</haxe_doc>
			</workDoneToken>
			<partialResultToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report partial results (e.g. streaming) to
		the client.</haxe_doc>
			</partialResultToken>
			<item><t path="languageServerProtocol.TypeHierarchyItem"/></item>
		</a>
		<haxe_doc>The parameter of a `typeHierarchy/supertypes` request.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.proposed.TypeHierarchySupertypesRequest" params="" file="src/languageServerProtocol/protocol/proposed/TypeHierarchy.hx" module="languageServerProtocol.protocol.proposed.TypeHierarchy">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;TypeHierarchySupertypesParams,Null&lt;Array&lt;TypeHierarchyItem&gt;&gt;,Array&lt;TypeHierarchyItem&gt;,NoData,NoData&gt;(&quot;typeHierarchy/supertypes&quot;)" line="73" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.proposed.TypeHierarchySupertypesParams"/>
				<x path="Null"><c path="Array"><t path="languageServerProtocol.TypeHierarchyItem"/></c></x>
				<c path="Array"><t path="languageServerProtocol.TypeHierarchyItem"/></c>
				<e path="jsonrpc.NoData"/>
				<e path="jsonrpc.NoData"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<TypeHierarchySupertypesParams,Null<Array<TypeHierarchyItem>>,Array<TypeHierarchyItem>,NoData,NoData>("typeHierarchy/supertypes")]]></e></m></meta>
		</type>
		<haxe_doc>A request to resolve the supertypes for a given `TypeHierarchyItem`.

	@since 3.17.0
	@proposed</haxe_doc>
	</class>
	<typedef path="languageServerProtocol.protocol.proposed.TypeHierarchySubtypesParams" params="" file="src/languageServerProtocol/protocol/proposed/TypeHierarchy.hx" module="languageServerProtocol.protocol.proposed.TypeHierarchy">
		<a>
			<workDoneToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report work done progress.</haxe_doc>
			</workDoneToken>
			<partialResultToken>
				<x path="Null"><t path="jsonrpc.ProgressToken"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional token that a server can use to report partial results (e.g. streaming) to
		the client.</haxe_doc>
			</partialResultToken>
			<item><t path="languageServerProtocol.TypeHierarchyItem"/></item>
		</a>
		<haxe_doc>The parameter of a `typeHierarchy/subtypes` request.

	@since 3.17.0
	@proposed</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.protocol.proposed.TypeHierarchySubtypesRequest" params="" file="src/languageServerProtocol/protocol/proposed/TypeHierarchy.hx" module="languageServerProtocol.protocol.proposed.TypeHierarchy">
		<type final="1" public="1" get="inline" set="null" expr="new ProtocolRequestType&lt;TypeHierarchySubtypesParams,Null&lt;Array&lt;TypeHierarchyItem&gt;&gt;,Array&lt;TypeHierarchyItem&gt;,NoData,NoData&gt;(&quot;typeHierarchy/subtypes&quot;)" line="95" static="1">
			<x path="languageServerProtocol.protocol.ProtocolRequestType">
				<t path="languageServerProtocol.protocol.proposed.TypeHierarchySubtypesParams"/>
				<x path="Null"><c path="Array"><t path="languageServerProtocol.TypeHierarchyItem"/></c></x>
				<c path="Array"><t path="languageServerProtocol.TypeHierarchyItem"/></c>
				<e path="jsonrpc.NoData"/>
				<e path="jsonrpc.NoData"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new ProtocolRequestType<TypeHierarchySubtypesParams,Null<Array<TypeHierarchyItem>>,Array<TypeHierarchyItem>,NoData,NoData>("typeHierarchy/subtypes")]]></e></m></meta>
		</type>
		<haxe_doc>A request to resolve the subtypes for a given `TypeHierarchyItem`.

	@since 3.17.0
	@proposed</haxe_doc>
	</class>
	<abstract path="languageServerProtocol.textdocument.DocumentUri" params="" file="src/languageServerProtocol/textdocument/TextDocument.hx" module="languageServerProtocol.textdocument.TextDocument">
		<this><c path="String"/></this>
		<haxe_doc>A tagging type for string properties that are actually document URIs.</haxe_doc>
		<impl><class path="languageServerProtocol.textdocument._TextDocument.DocumentUri_Impl_" params="" file="src/languageServerProtocol/textdocument/TextDocument.hx" private="1" module="languageServerProtocol.textdocument.TextDocument" final="1">
	<_new public="1" get="inline" set="null" line="7" static="1">
		<f a="uri">
			<c path="String"/>
			<x path="languageServerProtocol.textdocument.DocumentUri"/>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</_new>
	<toString public="1" get="inline" set="null" line="11" static="1"><f a="this">
	<c path="String"/>
	<c path="String"/>
</f></toString>
</class></impl>
	</abstract>
	<class path="languageServerProtocol.textdocument._TextDocument.DocumentUri_Impl_" params="" file="src/languageServerProtocol/textdocument/TextDocument.hx" private="1" module="languageServerProtocol.textdocument.TextDocument" final="1">
		<_new public="1" get="inline" set="null" line="7" static="1">
			<f a="uri">
				<c path="String"/>
				<x path="languageServerProtocol.textdocument.DocumentUri"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_new>
		<toString public="1" get="inline" set="null" line="11" static="1"><f a="this">
	<c path="String"/>
	<c path="String"/>
</f></toString>
	</class>
	<typedef path="languageServerProtocol.textdocument.Position" params="" file="src/languageServerProtocol/textdocument/TextDocument.hx" module="languageServerProtocol.textdocument.TextDocument">
		<a>
			<line>
				<x path="Int"/>
				<haxe_doc>Line position in a document (zero-based).
		If a line number is greater than the number of lines in a document, it defaults back to the number of lines in the document.
		If a line number is negative, it defaults to 0.</haxe_doc>
			</line>
			<character>
				<x path="Int"/>
				<haxe_doc>Character offset on a line in a document (zero-based). Assuming that the line is
		represented as a string, the `character` value represents the gap between the
		`character` and `character + 1`.

		If the character value is greater than the line length it defaults back to the
		line length.
		If a line number is negative, it defaults to 0.</haxe_doc>
			</character>
		</a>
		<haxe_doc>Position in a text document expressed as zero-based line and character offset.
	The offsets are based on a UTF-16 string representation. So a string of the form
	`a𐐀b` the character offset of the character `a` is 0, the character offset of `𐐀`
	is 1 and the character offset of b is 3 since `𐐀` is represented using two code
	units in UTF-16.

	Positions are line end character agnostic. So you can not specify a position that
	denotes `\r|\n` or `\n|` where `|` represents the character offset.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.textdocument.Range" params="" file="src/languageServerProtocol/textdocument/TextDocument.hx" module="languageServerProtocol.textdocument.TextDocument">
		<a>
			<start>
				<t path="languageServerProtocol.textdocument.Position"/>
				<haxe_doc>The range's start position</haxe_doc>
			</start>
			<end>
				<t path="languageServerProtocol.textdocument.Position"/>
				<haxe_doc>The range's end position.</haxe_doc>
			</end>
		</a>
		<haxe_doc>A range in a text document expressed as (zero-based) start and end positions.

	If you want to specify a range that contains a line including the line ending
	character(s) then use an end position denoting the start of the next line.
	For example:
	```ts
	{
	start: { line: 5, character: 23 }
	end : { line 6, character : 0 }
	}
	```</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.textdocument.TextEdit" params="" file="src/languageServerProtocol/textdocument/TextDocument.hx" module="languageServerProtocol.textdocument.TextDocument">
		<a>
			<range>
				<t path="languageServerProtocol.textdocument.Range"/>
				<haxe_doc>The range of the text document to be manipulated. To insert
		text into a document create a range where start === end.</haxe_doc>
			</range>
			<newText>
				<c path="String"/>
				<haxe_doc>The string to be inserted. For delete operations use an
		empty string.</haxe_doc>
			</newText>
		</a>
		<haxe_doc>A text edit applicable to a text document.</haxe_doc>
	</typedef>
	<typedef path="languageServerProtocol.textdocument.TextDocumentContentChangeEvent" params="" file="src/languageServerProtocol/textdocument/TextDocument.hx" module="languageServerProtocol.textdocument.TextDocument">
		<a>
			<text>
				<c path="String"/>
				<haxe_doc>The new text for the provided range.</haxe_doc>
			</text>
			<rangeLength>
				<x path="Null"><x path="Int"/></x>
				<meta>
					<m n=":optional"/>
					<m n=":deprecated"><e>"use range instead."</e></m>
				</meta>
				<haxe_doc>The optional length of the range that got replaced.</haxe_doc>
			</rangeLength>
			<range>
				<x path="Null"><t path="languageServerProtocol.textdocument.Range"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The range of the document that changed.</haxe_doc>
			</range>
		</a>
		<haxe_doc>An event describing a change to a text document. If range and rangeLength are omitted
	the new text is considered to be the full content of the document.</haxe_doc>
	</typedef>
	<class path="languageServerProtocol.textdocument.TextDocument" params="" file="src/languageServerProtocol/textdocument/TextDocument.hx" extern="1">
		<create public="1" set="method" static="1">
			<f a="uri:languageId:version:content">
				<x path="languageServerProtocol.textdocument.DocumentUri"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
				<c path="languageServerProtocol.textdocument.TextDocument"/>
			</f>
			<haxe_doc>Creates a new text document.

		@param uri The document's uri.
		@param languageId  The document's language Id.
		@param version The document's initial version number.
		@param content The document's content.</haxe_doc>
		</create>
		<update public="1" set="method" static="1">
			<f a="document:changes:version">
				<c path="languageServerProtocol.textdocument.TextDocument"/>
				<c path="Array"><t path="languageServerProtocol.textdocument.TextDocumentContentChangeEvent"/></c>
				<x path="Int"/>
				<c path="languageServerProtocol.textdocument.TextDocument"/>
			</f>
			<haxe_doc>Updates a TextDocument by modifying its content.

		@param document the document to update. Only documents created by TextDocument.create are valid inputs.
		@param changes the changes to apply to the document.
		@param version the changes version for the document.
		@returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.</haxe_doc>
		</update>
		<applyEdits public="1" set="method" static="1"><f a="document:edits">
	<c path="languageServerProtocol.textdocument.TextDocument"/>
	<c path="Array"><t path="languageServerProtocol.textdocument.TextEdit"/></c>
	<c path="String"/>
</f></applyEdits>
		<uri public="1">
			<x path="languageServerProtocol.textdocument.DocumentUri"/>
			<haxe_doc>The associated URI for this document. Most documents have the __file__-scheme, indicating that they
		represent files on disk. However, some documents may have other schemes indicating that they are not
		available on disk.

		@readonly</haxe_doc>
		</uri>
		<languageId public="1">
			<c path="String"/>
			<haxe_doc>The identifier of the language associated with this document.

		@readonly</haxe_doc>
		</languageId>
		<version public="1">
			<x path="Int"/>
			<haxe_doc>The version number of this document (it will increase after each
		change, including undo/redo).

		@readonly</haxe_doc>
		</version>
		<getText public="1" set="method">
			<f a="?range">
				<x path="Null"><t path="languageServerProtocol.textdocument.Range"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Get the text of this document. A substring can be retrieved by
		providing a range.

		@param range (optional) An range within the document to return.
		If no range is passed, the full content is returned.
		Invalid range positions are adjusted as described in [Position.line](#Position.line)
		and [Position.character](#Position.character).
		If the start range position is greater than the end range position,
		then the effect of getText is as if the two positions were swapped.

		@return The text of this document or a substring of the text if a
				range is provided.</haxe_doc>
		</getText>
		<positionAt public="1" set="method">
			<f a="offset">
				<x path="Int"/>
				<t path="languageServerProtocol.textdocument.Position"/>
			</f>
			<haxe_doc>Converts a zero-based offset to a position.

		@param offset A zero-based offset.
		@return A valid [position](#Position).</haxe_doc>
		</positionAt>
		<offsetAt public="1" set="method">
			<f a="position">
				<t path="languageServerProtocol.textdocument.Position"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Converts the position to a zero-based offset.
		Invalid positions are adjusted as described in [Position.line](#Position.line)
		and [Position.character](#Position.character).

		@param position A position.
		@return A valid zero-based offset.</haxe_doc>
		</offsetAt>
		<lineCount public="1">
			<x path="Int"/>
			<haxe_doc>The number of lines in this document.

		@readonly</haxe_doc>
		</lineCount>
		<haxe_doc>A simple text document. Not to be implemented. The document keeps the content
	as string.</haxe_doc>
		<meta><m n=":native"><e>"TextDocument"</e></m></meta>
	</class>
</haxe>